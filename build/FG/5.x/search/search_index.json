{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ForgeGradle Documentation This is the official documentation for ForgeGradle , a Gradle plugin for developing MinecraftForge and mods using MinecraftForge. This documentation is only for ForgeGradle, this is not a Java, Groovy, or Gradle tutorial . If you would like to contribute to the docs, read Contributing to the Docs . Adding the Plugin ForgeGradle can be added using the plugins block by adding the MinecraftForge maven to the available plugin repositories: // In settings.gradle pluginManagement { repositories { // ... // Add the MinecraftForge maven maven { url = 'https://maven.minecraftforge.net/' } } } // In build.gradle plugins { // Add the ForgeGradle plugin id 'net.minecraftforge.gradle' version '5.1.+' // ... }","title":"Home"},{"location":"#forgegradle-documentation","text":"This is the official documentation for ForgeGradle , a Gradle plugin for developing MinecraftForge and mods using MinecraftForge. This documentation is only for ForgeGradle, this is not a Java, Groovy, or Gradle tutorial . If you would like to contribute to the docs, read Contributing to the Docs .","title":"ForgeGradle Documentation"},{"location":"#adding-the-plugin","text":"ForgeGradle can be added using the plugins block by adding the MinecraftForge maven to the available plugin repositories: // In settings.gradle pluginManagement { repositories { // ... // Add the MinecraftForge maven maven { url = 'https://maven.minecraftforge.net/' } } } // In build.gradle plugins { // Add the ForgeGradle plugin id 'net.minecraftforge.gradle' version '5.1.+' // ... }","title":"Adding the Plugin"},{"location":"contributing/","text":"Contributing to This Documentation You can make a contribution via a PR on Github . This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to use ForgeGradle. Please don\u2019t try to turn this documentation into a tutorial on Java or Groovy Development - it is intended for people who understand how a class and other fundamental structures work. ForgeGradle configuration code examples should be written in Groovy . Style Guide Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). JSON code block snippets should use js syntax highlighting. All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path. Admonitions (represented by !!! <type> ) must be formatted as documented ; otherwise they may end up rendering incorrectly.","title":"Contributing to the Docs"},{"location":"contributing/#contributing-to-this-documentation","text":"You can make a contribution via a PR on Github . This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to use ForgeGradle. Please don\u2019t try to turn this documentation into a tutorial on Java or Groovy Development - it is intended for people who understand how a class and other fundamental structures work. ForgeGradle configuration code examples should be written in Groovy .","title":"Contributing to This Documentation"},{"location":"contributing/#style-guide","text":"Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). JSON code block snippets should use js syntax highlighting. All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path. Admonitions (represented by !!! <type> ) must be formatted as documented ; otherwise they may end up rendering incorrectly.","title":"Style Guide"},{"location":"configuration/","text":"ForgeGradle Configurations ForgeGradle has numerous configurations that can change how the development environment is configured. Most configurations are set using the minecraft block; however, some others can be specified within the dependencies block or modify the built jar , such as reobfJar . Enabling Access Transformers Access Transformers can widen the visibility or modify the final flag of Minecraft classes, methods, and fields. To enable access transformers in the production environment, you can set accessTransformer to configuration file in question: minecraft { // ... // Add an access transformer file relative to the project's directory accessTransformer = project.file('src/main/resources/META-INF/accesstransformer.cfg') } Important While the access transformer in the development environment can be read from anywhere the user specifies, in production, the file will only be read from META-INF/accesstransformer.cfg . Human-Readable Mappings Minecraft\u2019s source code is obfuscated. As such, all classes, methods, and fields have machine-generated names with no package structures. Function-local variable names, meanwhile, are turned into a snowman ( \u2603 ) due to how the Local Variable Table is stored. It is difficult to create mods using obfuscated names as reverse engineering them is tedious, may change between versions, and may be invalid in the language itself but not in the bytecode. To address the last two issues, Forge fuzzily maps each class, method, field, and parameter to a unique identifier, known as the SRG name, via the ForgeAutoRenamingTool . SRG mappings are used in production when the game is being run by the user client. To allow easier development, ForgeGradle allows the user to choose a mapping set to apply on top of SRG mappings, which we will refer to as human-readable mappings. ForgeGradle knows how to convert the mod jar to SRG mappings for use in production via the reobf* task. The mapping set used can be specified by setting the mappings field in the minecraft block. The mappings field takes in two arguments: channel which is the type of the mapping set, and version which is the version of the mapping set to apply. Currently, there are three default mapping sets built into ForgeGradle: official - This uses the mapping set provided by Mojang. These mappings do not have parameter names and only exist from 1.14 onward. stable - This uses a mapping set generated by MCP. These are typically incomplete and no longer exist as of 1.17. snapshot - This also is a mapping set generated by MCP, similar to a nightly build of a program. These are also typically incomplete and no longer exist as of 1.17. Note The class names used in production are from stable prior to 1.17 and from official from 1.17 onwards. mappings { // Sets the mappings to use those from Mojang for Minecraft 1.19.4. mappings channel: 'official', version: '1.19.4' // ... } Parchment Parchment is an official project maintained by ParchmentMC which provides open, community-sourced parameter names and javadocs on top of the official mapping set. You can learn how setup and use the parchment mapping set on their website .","title":"Introduction"},{"location":"configuration/#forgegradle-configurations","text":"ForgeGradle has numerous configurations that can change how the development environment is configured. Most configurations are set using the minecraft block; however, some others can be specified within the dependencies block or modify the built jar , such as reobfJar .","title":"ForgeGradle Configurations"},{"location":"configuration/#enabling-access-transformers","text":"Access Transformers can widen the visibility or modify the final flag of Minecraft classes, methods, and fields. To enable access transformers in the production environment, you can set accessTransformer to configuration file in question: minecraft { // ... // Add an access transformer file relative to the project's directory accessTransformer = project.file('src/main/resources/META-INF/accesstransformer.cfg') } Important While the access transformer in the development environment can be read from anywhere the user specifies, in production, the file will only be read from META-INF/accesstransformer.cfg .","title":"Enabling Access Transformers"},{"location":"configuration/#human-readable-mappings","text":"Minecraft\u2019s source code is obfuscated. As such, all classes, methods, and fields have machine-generated names with no package structures. Function-local variable names, meanwhile, are turned into a snowman ( \u2603 ) due to how the Local Variable Table is stored. It is difficult to create mods using obfuscated names as reverse engineering them is tedious, may change between versions, and may be invalid in the language itself but not in the bytecode. To address the last two issues, Forge fuzzily maps each class, method, field, and parameter to a unique identifier, known as the SRG name, via the ForgeAutoRenamingTool . SRG mappings are used in production when the game is being run by the user client. To allow easier development, ForgeGradle allows the user to choose a mapping set to apply on top of SRG mappings, which we will refer to as human-readable mappings. ForgeGradle knows how to convert the mod jar to SRG mappings for use in production via the reobf* task. The mapping set used can be specified by setting the mappings field in the minecraft block. The mappings field takes in two arguments: channel which is the type of the mapping set, and version which is the version of the mapping set to apply. Currently, there are three default mapping sets built into ForgeGradle: official - This uses the mapping set provided by Mojang. These mappings do not have parameter names and only exist from 1.14 onward. stable - This uses a mapping set generated by MCP. These are typically incomplete and no longer exist as of 1.17. snapshot - This also is a mapping set generated by MCP, similar to a nightly build of a program. These are also typically incomplete and no longer exist as of 1.17. Note The class names used in production are from stable prior to 1.17 and from official from 1.17 onwards. mappings { // Sets the mappings to use those from Mojang for Minecraft 1.19.4. mappings channel: 'official', version: '1.19.4' // ... }","title":"Human-Readable Mappings"},{"location":"configuration/#parchment","text":"Parchment is an official project maintained by ParchmentMC which provides open, community-sourced parameter names and javadocs on top of the official mapping set. You can learn how setup and use the parchment mapping set on their website .","title":"Parchment"},{"location":"configuration/runs/","text":"Run Configurations Run configurations define how an instance of the game is going to run. This includes arguments, working directories, task names, etc. Run configurations are defined within the minecraft.runs block. While no runs are configured by default, Forge does provide the configurations client , server , data , or gameTestServer . minecraft { // ... runs { // Configure runs here } } Run configurations can be added similar to any NamedDomainObjectContainer using closures. // Inside the minecraft block runs { // Creates or configures the run configuration named 'client' client { // Configure run } } The following configurations properties are available: // Inside the runs block client { // The name of the Gradle run tasks, // Defaults to 'runX' where X is the container name taskName 'runThing' // Sets the entrypoint of the program to launch // Forge sets userdev main to be 'cpw.mods.bootstraplauncher.BootstrapLauncher' main 'com.example.Main' // Sets the working directory of the config // Defaults to './run' workingDirectory 'run' // Sets the name of the module for IntelliJ IDEA to configure for its runs // Defaults to '<project_name>.main' ideaModule 'example.main' // Sets whether this should run a Minecraft client // If not specified, checks the following // - Is there an environment property 'thing' that contains 'client' // - Does the configuration name contain 'client' // - Is main set to 'mcp.client.Start' // - Is main set to 'net.minecraft.client.main.Main' client true // Set the parent of this configuration to inherit from parent runs.example // Sets the children of this configuration children runs.child // Merges this configuration and specifies whether to overwrite existing properties merge runs.server, true // If not false, will merge the arguments of the parent with this configuration inheritArgs false // If not false, will merge the JVM arguments of the parent with this configuration inheritJvmArgs false // Adds a sourceset to the classpath // If none is specified, adds sourceSet.main source sourceSets.api // Sets an environment property for the run // Value will be interpreted as a file or a string environment 'envKey', 'value' // Sets a system property // Value will be interpreted as a file or a string property 'propKey', 'value' // Sets an argument to be passed into the application // Can specify multiple with 'args' arg 'hello' // Sets a JVM argument // Can specify multiple with 'jvmArgs' jvmArg '-Xmx2G' // Sets a token // Currently, the following tokens are being used: // - runtime_classpath // - minecraft_classpath token 'tokenKey', 'value' // Sets a token that's lazily initialized // Should usually be used instead of 'token', for example when the token resolves Gradle configurations lazyToken('lazyTokenKey') { 'value' } // If not false, Gradle will stop once the process has finished forceExit true // If true, compile all projects instead of for the current task // This is only used by IntelliJ IDEA buildAllProjects false } Tip You can see a list of all configured userdev properties within the MinecraftForge buildscript . Mod Configurations A mod in the current environment can be added using the mods block within a Run configuration. Mod blocks are also NamedDomainObjectContainer s. // Inside the runs block client { // ... mods { // Configures the 'example' mod example { // Add a source set to a mod's sources // This is recommended over manually adding classes and resources source sourceSets.main // Sets the location of the mod's classes classes sourceSets.api.output // Sets the location of the mod's resources resources files('./my_resources') } } }","title":"Run Configs"},{"location":"configuration/runs/#run-configurations","text":"Run configurations define how an instance of the game is going to run. This includes arguments, working directories, task names, etc. Run configurations are defined within the minecraft.runs block. While no runs are configured by default, Forge does provide the configurations client , server , data , or gameTestServer . minecraft { // ... runs { // Configure runs here } } Run configurations can be added similar to any NamedDomainObjectContainer using closures. // Inside the minecraft block runs { // Creates or configures the run configuration named 'client' client { // Configure run } } The following configurations properties are available: // Inside the runs block client { // The name of the Gradle run tasks, // Defaults to 'runX' where X is the container name taskName 'runThing' // Sets the entrypoint of the program to launch // Forge sets userdev main to be 'cpw.mods.bootstraplauncher.BootstrapLauncher' main 'com.example.Main' // Sets the working directory of the config // Defaults to './run' workingDirectory 'run' // Sets the name of the module for IntelliJ IDEA to configure for its runs // Defaults to '<project_name>.main' ideaModule 'example.main' // Sets whether this should run a Minecraft client // If not specified, checks the following // - Is there an environment property 'thing' that contains 'client' // - Does the configuration name contain 'client' // - Is main set to 'mcp.client.Start' // - Is main set to 'net.minecraft.client.main.Main' client true // Set the parent of this configuration to inherit from parent runs.example // Sets the children of this configuration children runs.child // Merges this configuration and specifies whether to overwrite existing properties merge runs.server, true // If not false, will merge the arguments of the parent with this configuration inheritArgs false // If not false, will merge the JVM arguments of the parent with this configuration inheritJvmArgs false // Adds a sourceset to the classpath // If none is specified, adds sourceSet.main source sourceSets.api // Sets an environment property for the run // Value will be interpreted as a file or a string environment 'envKey', 'value' // Sets a system property // Value will be interpreted as a file or a string property 'propKey', 'value' // Sets an argument to be passed into the application // Can specify multiple with 'args' arg 'hello' // Sets a JVM argument // Can specify multiple with 'jvmArgs' jvmArg '-Xmx2G' // Sets a token // Currently, the following tokens are being used: // - runtime_classpath // - minecraft_classpath token 'tokenKey', 'value' // Sets a token that's lazily initialized // Should usually be used instead of 'token', for example when the token resolves Gradle configurations lazyToken('lazyTokenKey') { 'value' } // If not false, Gradle will stop once the process has finished forceExit true // If true, compile all projects instead of for the current task // This is only used by IntelliJ IDEA buildAllProjects false } Tip You can see a list of all configured userdev properties within the MinecraftForge buildscript .","title":"Run Configurations"},{"location":"configuration/runs/#mod-configurations","text":"A mod in the current environment can be added using the mods block within a Run configuration. Mod blocks are also NamedDomainObjectContainer s. // Inside the runs block client { // ... mods { // Configures the 'example' mod example { // Add a source set to a mod's sources // This is recommended over manually adding classes and resources source sourceSets.main // Sets the location of the mod's classes classes sourceSets.api.output // Sets the location of the mod's resources resources files('./my_resources') } } }","title":"Mod Configurations"},{"location":"dependencies/","text":"Dependencies Dependencies are not only used to develop interoperability between mods or add additional libraries to the game, but it also determines what version of Minecraft to develop for. This will provide a quick overview on how to modify the repositories and dependencies block to add dependencies to your development environment. This will not explain Gradle concepts in depth. It is highly recommended to read the Gradle Dependency Management guide before continuing. minecraft The minecraft dependency specifies the version of Minecraft to use and must be included in the dependencies block. Any artifact, except artifacts which have the group net.minecraft , will apply any patches provided with the dependency. This typically only specifies the net.minecraftforge:forge artifact. dependencies { // Version of Forge artifact is in the form '<mc_version>-<forge_version>' // 'mc_version' is the version of Minecraft to load (e.g., 1.19.4) // 'forge_version' is the version of Forge wanted for that Minecraft version (e.g., 45.0.23) // Vanilla can be compiled against using 'net.minecraft:joined:<mc_version>' instead minecraft 'net.minecraftforge:forge:1.19.4-45.0.23' } Mod Dependencies In a typical development environment, Minecraft is deobfuscated to intermediate mappings, used in production, and then transformed into whatever human-readable mappings the modder specified. Mod artifacts, when built, are obfuscated to production mappings (SRG), and as such, are unable to be used directly as a Gradle dependency. As such, all mod dependencies need to be wrapped with fg.deobf before being added to the intended configuration. dependencies { // Assume we have already specified the 'minecraft' dependency // Assume we have some artifact 'examplemod' that can be obtained from a specified repository implementation fg.deobf('com.example:examplemod:1.0') } Local Mod Dependencies If the mod you are trying to depend on is not available on a maven repository (e.g., Maven Central , CurseMaven , Modrinth ), you can add a mod dependency using a [flat directory] instead: repositories { // Adds the 'libs' folder in the project directory as a flat directory flatDir { dir 'libs' } } dependencies { // ... // Given some <group>:<name>:<version>:<classifier (default None)> // with an extension <ext (default jar)> // Artifacts in flat directories will be resolved in the following order: // - <name>-<version>.<ext> // - <name>-<version>-<classifier>.<ext> // - <name>.<ext> // - <name>-<classifier>.<ext> // If a classifier is explicitly specified // artifacts with the classifier will take priority: // - examplemod-1.0-api.jar // - examplemod-api.jar // - examplemod-1.0.jar // - examplemod.jar implementation fg.deobf('com.example:examplemod:1.0:api') } Note The group name can be anything but must not be empty for flat directory entries as they are not checked when resolving the artifact file. Non-Minecraft Dependencies Non-Minecraft dependencies are not loaded by Forge by default in the development environment. To get Forge to recognize the non-Minecraft dependency, they must be added to the minecraftLibrary configuration. minecraftLibrary works similarly to the implementation configuration within Gradle, being applied during compile time and runtime. dependencies { // ... // Assume there is some non-Minecraft library 'dummy-lib' minecraftLibrary 'com.dummy:dummy-lib:1.0' } Non-Minecraft dependencies added to the development environment will not be included in built artifact by default! You must use Jar-In-Jar to include the dependencies within the artifact on build.","title":"Introduction"},{"location":"dependencies/#dependencies","text":"Dependencies are not only used to develop interoperability between mods or add additional libraries to the game, but it also determines what version of Minecraft to develop for. This will provide a quick overview on how to modify the repositories and dependencies block to add dependencies to your development environment. This will not explain Gradle concepts in depth. It is highly recommended to read the Gradle Dependency Management guide before continuing.","title":"Dependencies"},{"location":"dependencies/#minecraft","text":"The minecraft dependency specifies the version of Minecraft to use and must be included in the dependencies block. Any artifact, except artifacts which have the group net.minecraft , will apply any patches provided with the dependency. This typically only specifies the net.minecraftforge:forge artifact. dependencies { // Version of Forge artifact is in the form '<mc_version>-<forge_version>' // 'mc_version' is the version of Minecraft to load (e.g., 1.19.4) // 'forge_version' is the version of Forge wanted for that Minecraft version (e.g., 45.0.23) // Vanilla can be compiled against using 'net.minecraft:joined:<mc_version>' instead minecraft 'net.minecraftforge:forge:1.19.4-45.0.23' }","title":"minecraft"},{"location":"dependencies/#mod-dependencies","text":"In a typical development environment, Minecraft is deobfuscated to intermediate mappings, used in production, and then transformed into whatever human-readable mappings the modder specified. Mod artifacts, when built, are obfuscated to production mappings (SRG), and as such, are unable to be used directly as a Gradle dependency. As such, all mod dependencies need to be wrapped with fg.deobf before being added to the intended configuration. dependencies { // Assume we have already specified the 'minecraft' dependency // Assume we have some artifact 'examplemod' that can be obtained from a specified repository implementation fg.deobf('com.example:examplemod:1.0') }","title":"Mod Dependencies"},{"location":"dependencies/#local-mod-dependencies","text":"If the mod you are trying to depend on is not available on a maven repository (e.g., Maven Central , CurseMaven , Modrinth ), you can add a mod dependency using a [flat directory] instead: repositories { // Adds the 'libs' folder in the project directory as a flat directory flatDir { dir 'libs' } } dependencies { // ... // Given some <group>:<name>:<version>:<classifier (default None)> // with an extension <ext (default jar)> // Artifacts in flat directories will be resolved in the following order: // - <name>-<version>.<ext> // - <name>-<version>-<classifier>.<ext> // - <name>.<ext> // - <name>-<classifier>.<ext> // If a classifier is explicitly specified // artifacts with the classifier will take priority: // - examplemod-1.0-api.jar // - examplemod-api.jar // - examplemod-1.0.jar // - examplemod.jar implementation fg.deobf('com.example:examplemod:1.0:api') } Note The group name can be anything but must not be empty for flat directory entries as they are not checked when resolving the artifact file.","title":"Local Mod Dependencies"},{"location":"dependencies/#non-minecraft-dependencies","text":"Non-Minecraft dependencies are not loaded by Forge by default in the development environment. To get Forge to recognize the non-Minecraft dependency, they must be added to the minecraftLibrary configuration. minecraftLibrary works similarly to the implementation configuration within Gradle, being applied during compile time and runtime. dependencies { // ... // Assume there is some non-Minecraft library 'dummy-lib' minecraftLibrary 'com.dummy:dummy-lib:1.0' } Non-Minecraft dependencies added to the development environment will not be included in built artifact by default! You must use Jar-In-Jar to include the dependencies within the artifact on build.","title":"Non-Minecraft Dependencies"},{"location":"dependencies/jarinjar/","text":"Jar-in-Jar Jar-in-Jar is a way to load dependencies for mods from within the jars of the mods. To accomplish this, Jar-in-Jar generates a metadata json within META-INF/jarjar/metadata.json on build containing the artifacts to load from within the jar. Jar-in-Jar is a completely optional system which can be enabled using jarJar#enable before the minecraft block. This will include all dependencies from the jarJar configuration into the jarJar task. You can configure the task similarly to other jar tasks: // In build.gradle // Enable the Jar-in-Jar system for your mod jarJar.enable() // Configure the 'jarJar' task // 'all' is the default classifier tasks.named('jarJar') { // ... } Adding Dependencies You can add dependencies to be included inside your jar using the jarJar configuration. As Jar-in-Jar is a negotiation system, all versions should supply a supported range. // In build.gradle dependencies { // Compiles against and includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') } If you need to specify an exact version to include rather than the highest supported version in the range, you can use jarJar#pin within the dependency closure. In these instances, the artifact version will be used during compile time while the pinned version will be bundled inside the mod jar. // In build.gradle dependencies { // Compiles against the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') { // Includes examplelib 2.8.0 jarJar.pin(it, '2.8.0') } } You can additionally pin a version range while compiling against a specific version instead: // In build.gradle dependencies { // Compiles against examplelib 2.8.0 jarJar(group: 'com.example', name: 'examplelib', version: '2.8.0') { // Includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar.pin(it, '[2.0,3.0)') } } Using Runtime Dependencies If you would like to include the runtime dependencies of your mod inside your jar, you can invoke jarJar#fromRuntimeConfiguration within your buildscript. If you decide to use this option, it is highly suggested to include dependency filters; otherwise, every single dependency \u2013 including Minecraft and Forge \u2013 will be bundled in the jar as well. To support more flexible statements, the dependency configuration has been added to the jarJar extension and task. Using this, you can specify patterns to include or exclude from the configuration: // In build.gradle // Add runtime dependencies to jar jarJar.fromRuntimeConfiguration() // ... jarJar { // Include or exclude dependencies here from runtime configuration dependencies { // Exclude any dependency which begins with 'com.google.gson.' exclude(dependency('com.google.gson.*')) } } Tip It is generally recommended to set at least one include filter when using #fromRuntimeConfiguration . Publishing a Jar-in-Jar to Maven For archival reasons, ForgeGradle supports publishing Jar-in-Jar artifacts to a maven of choice, similar to how the Shadow plugin handles it. In practices, this is not useful or recommended. // In build.gradle (has 'maven-publish' plugin) publications { mavenJava(MavenPublication) { // Add standard java components and Jar-in-Jar artifact from components.java jarJar.component(it) // ... } }","title":"Jar-in-Jar"},{"location":"dependencies/jarinjar/#jar-in-jar","text":"Jar-in-Jar is a way to load dependencies for mods from within the jars of the mods. To accomplish this, Jar-in-Jar generates a metadata json within META-INF/jarjar/metadata.json on build containing the artifacts to load from within the jar. Jar-in-Jar is a completely optional system which can be enabled using jarJar#enable before the minecraft block. This will include all dependencies from the jarJar configuration into the jarJar task. You can configure the task similarly to other jar tasks: // In build.gradle // Enable the Jar-in-Jar system for your mod jarJar.enable() // Configure the 'jarJar' task // 'all' is the default classifier tasks.named('jarJar') { // ... }","title":"Jar-in-Jar"},{"location":"dependencies/jarinjar/#adding-dependencies","text":"You can add dependencies to be included inside your jar using the jarJar configuration. As Jar-in-Jar is a negotiation system, all versions should supply a supported range. // In build.gradle dependencies { // Compiles against and includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') } If you need to specify an exact version to include rather than the highest supported version in the range, you can use jarJar#pin within the dependency closure. In these instances, the artifact version will be used during compile time while the pinned version will be bundled inside the mod jar. // In build.gradle dependencies { // Compiles against the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') { // Includes examplelib 2.8.0 jarJar.pin(it, '2.8.0') } } You can additionally pin a version range while compiling against a specific version instead: // In build.gradle dependencies { // Compiles against examplelib 2.8.0 jarJar(group: 'com.example', name: 'examplelib', version: '2.8.0') { // Includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar.pin(it, '[2.0,3.0)') } }","title":"Adding Dependencies"},{"location":"dependencies/jarinjar/#using-runtime-dependencies","text":"If you would like to include the runtime dependencies of your mod inside your jar, you can invoke jarJar#fromRuntimeConfiguration within your buildscript. If you decide to use this option, it is highly suggested to include dependency filters; otherwise, every single dependency \u2013 including Minecraft and Forge \u2013 will be bundled in the jar as well. To support more flexible statements, the dependency configuration has been added to the jarJar extension and task. Using this, you can specify patterns to include or exclude from the configuration: // In build.gradle // Add runtime dependencies to jar jarJar.fromRuntimeConfiguration() // ... jarJar { // Include or exclude dependencies here from runtime configuration dependencies { // Exclude any dependency which begins with 'com.google.gson.' exclude(dependency('com.google.gson.*')) } } Tip It is generally recommended to set at least one include filter when using #fromRuntimeConfiguration .","title":"Using Runtime Dependencies"},{"location":"dependencies/jarinjar/#publishing-a-jar-in-jar-to-maven","text":"For archival reasons, ForgeGradle supports publishing Jar-in-Jar artifacts to a maven of choice, similar to how the Shadow plugin handles it. In practices, this is not useful or recommended. // In build.gradle (has 'maven-publish' plugin) publications { mavenJava(MavenPublication) { // Add standard java components and Jar-in-Jar artifact from components.java jarJar.component(it) // ... } }","title":"Publishing a Jar-in-Jar to Maven"},{"location":"gettingstarted/","text":"Getting Started with ForgeGradle If you have never used ForgeGradle before, here is the minimum amount of information needed to get a development environment setup. Prerequisites An installation of the Java Development Kit (JDK) Minecraft Versions Java Development Kit Version 1.12 - 1.16 JDK 8 1.17 JDK 16 1.18 - 1.19 JDK 17 Familiarity with an Integrated Development Environment (IDE) It is preferable to use one with some form of Gradle integration Setting Up ForgeGradle First download a copy of the Modder Development Kit (MDK) from MinecraftForge and extract the zip to an empty directory. Open the directory you extracted the MDK to within your IDE of choice. If your IDE integrates with Gradle, import it as a Gradle project. Customize your Gradle buildscript for your mod: Set archivesBaseName to the desired mod id. Additionally, replace all occurrences of examplemod with the mod id as well. Change the group to your desired package name. Make sure to follow existing naming conventions . Change the version number to reflect the current version of your mod. It is highly recommended to use Forge\u2019s extension on semantic versioning . Important Make sure that any changes to the mod id are reflected in the mods.toml and main mod class. See Structuring Your Mod on the Forge docs for more information. Reload or refresh your Gradle project using your IDE. If your IDE does not have Gradle integration, run the following from a shell in your project\u2019s directory: ./gradlew build --refresh-dependencies If your IDE is either Eclipse, IntelliJ IDEA, or Visual Studio Code, you can generate run configurations using one of the following commands, respectively: Eclipse ./gradlew genEclipseRuns IntelliJ IDEA ./gradlew genIntellijRuns Visual Studio Code ./gradlew genVSCodeRuns You can the run the client, server, etc. using one of the generated run configurations. Tip If your IDE is not listed, you can still run the configurations using ./gradlew run* (e.g., runClient , runServer , runData ). You can use these commands with the supported IDEs as well. Congratulations, now you have a development environment set up!","title":"Introduction"},{"location":"gettingstarted/#getting-started-with-forgegradle","text":"If you have never used ForgeGradle before, here is the minimum amount of information needed to get a development environment setup.","title":"Getting Started with ForgeGradle"},{"location":"gettingstarted/#prerequisites","text":"An installation of the Java Development Kit (JDK) Minecraft Versions Java Development Kit Version 1.12 - 1.16 JDK 8 1.17 JDK 16 1.18 - 1.19 JDK 17 Familiarity with an Integrated Development Environment (IDE) It is preferable to use one with some form of Gradle integration","title":"Prerequisites"},{"location":"gettingstarted/#setting-up-forgegradle","text":"First download a copy of the Modder Development Kit (MDK) from MinecraftForge and extract the zip to an empty directory. Open the directory you extracted the MDK to within your IDE of choice. If your IDE integrates with Gradle, import it as a Gradle project. Customize your Gradle buildscript for your mod: Set archivesBaseName to the desired mod id. Additionally, replace all occurrences of examplemod with the mod id as well. Change the group to your desired package name. Make sure to follow existing naming conventions . Change the version number to reflect the current version of your mod. It is highly recommended to use Forge\u2019s extension on semantic versioning . Important Make sure that any changes to the mod id are reflected in the mods.toml and main mod class. See Structuring Your Mod on the Forge docs for more information. Reload or refresh your Gradle project using your IDE. If your IDE does not have Gradle integration, run the following from a shell in your project\u2019s directory: ./gradlew build --refresh-dependencies If your IDE is either Eclipse, IntelliJ IDEA, or Visual Studio Code, you can generate run configurations using one of the following commands, respectively:","title":"Setting Up ForgeGradle"},{"location":"gettingstarted/#eclipse","text":"./gradlew genEclipseRuns","title":"Eclipse"},{"location":"gettingstarted/#intellij-idea","text":"./gradlew genIntellijRuns","title":"IntelliJ IDEA"},{"location":"gettingstarted/#visual-studio-code","text":"./gradlew genVSCodeRuns You can the run the client, server, etc. using one of the generated run configurations. Tip If your IDE is not listed, you can still run the configurations using ./gradlew run* (e.g., runClient , runServer , runData ). You can use these commands with the supported IDEs as well. Congratulations, now you have a development environment set up!","title":"Visual Studio Code"}]}