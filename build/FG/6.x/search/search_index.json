{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ForgeGradle Documentation This is the official documentation for ForgeGradle , a Gradle plugin for developing MinecraftForge and mods using MinecraftForge. This documentation is only for ForgeGradle, this is not a Java, Groovy, or Gradle tutorial . If you would like to contribute to the docs, read Contributing to the Docs . Adding the Plugin ForgeGradle uses Gradle 8; it can be added using the plugins block in the build.gradle by adding the following information to the settings.gradle : // In settings.gradle pluginManagement { repositories { // ... // Add the MinecraftForge maven maven { url = 'https://maven.minecraftforge.net/' } } } plugins { // Add toolchain resolver id 'org.gradle.toolchains.foojay-resolver-convention' version '0.5.0' } // In build.gradle plugins { // Add the ForgeGradle plugin id 'net.minecraftforge.gradle' version '[6.0,6.2)' // ... }","title":"Home"},{"location":"#forgegradle-documentation","text":"This is the official documentation for ForgeGradle , a Gradle plugin for developing MinecraftForge and mods using MinecraftForge. This documentation is only for ForgeGradle, this is not a Java, Groovy, or Gradle tutorial . If you would like to contribute to the docs, read Contributing to the Docs .","title":"ForgeGradle Documentation"},{"location":"#adding-the-plugin","text":"ForgeGradle uses Gradle 8; it can be added using the plugins block in the build.gradle by adding the following information to the settings.gradle : // In settings.gradle pluginManagement { repositories { // ... // Add the MinecraftForge maven maven { url = 'https://maven.minecraftforge.net/' } } } plugins { // Add toolchain resolver id 'org.gradle.toolchains.foojay-resolver-convention' version '0.5.0' } // In build.gradle plugins { // Add the ForgeGradle plugin id 'net.minecraftforge.gradle' version '[6.0,6.2)' // ... }","title":"Adding the Plugin"},{"location":"contributing/","text":"Contributing to This Documentation You can make a contribution via a PR on Github . This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to use ForgeGradle. Please don\u2019t try to turn this documentation into a tutorial on Java or Groovy Development - it is intended for people who understand how a class and other fundamental structures work. ForgeGradle configuration code examples should be written in Groovy . Style Guide Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). JSON code block snippets should use js syntax highlighting. All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path. Admonitions (represented by !!! <type> ) must be formatted as documented ; otherwise they may end up rendering incorrectly.","title":"Contributing to the Docs"},{"location":"contributing/#contributing-to-this-documentation","text":"You can make a contribution via a PR on Github . This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to use ForgeGradle. Please don\u2019t try to turn this documentation into a tutorial on Java or Groovy Development - it is intended for people who understand how a class and other fundamental structures work. ForgeGradle configuration code examples should be written in Groovy .","title":"Contributing to This Documentation"},{"location":"contributing/#style-guide","text":"Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). JSON code block snippets should use js syntax highlighting. All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path. Admonitions (represented by !!! <type> ) must be formatted as documented ; otherwise they may end up rendering incorrectly.","title":"Style Guide"},{"location":"configuration/","text":"ForgeGradle Configurations ForgeGradle has numerous configurations that can change how the development environment is configured. Most configurations are set using the minecraft block; however, some others can be specified within the dependencies block or modify the built jar , such as reobfJar . Enabling Access Transformers Access Transformers can widen the visibility or modify the final flag of Minecraft classes, methods, and fields. To enable access transformers in the production environment, you can set accessTransformer to configuration file in question: minecraft { // ... // Add an access transformer file relative to the project's directory accessTransformer = project.file('src/main/resources/META-INF/accesstransformer.cfg') } Important While the access transformer in the development environment can be read from anywhere the user specifies, in production, the file will only be read from META-INF/accesstransformer.cfg . Human-Readable Mappings Minecraft\u2019s source code is obfuscated. As such, all classes, methods, and fields have machine-generated names with no package structures. Function-local variable names, meanwhile, are turned into a snowman ( \u2603 ) due to how the Local Variable Table is stored. It is difficult to create mods using obfuscated names as reverse engineering them is tedious, may change between versions, and may be invalid in the language itself but not in the bytecode. To address the last two issues, Forge fuzzily maps each class, method, field, and parameter to a unique identifier, known as the SRG name, via the ForgeAutoRenamingTool . SRG mappings are used in production when the game is being run by the user client. To allow easier development, ForgeGradle allows the user to choose a mapping set to apply on top of SRG mappings, which we will refer to as human-readable mappings. ForgeGradle knows how to convert the mod jar to SRG mappings for use in production via the reobf* task. The mapping set used can be specified by setting the mappings field in the minecraft block. The mappings field takes in two arguments: channel which is the type of the mapping set, and version which is the version of the mapping set to apply. Currently, there are three default mapping sets built into ForgeGradle: official - This uses the mapping set provided by Mojang. These mappings do not have parameter names and only exist from 1.14 onward. stable - This uses a mapping set generated by MCP. These are typically incomplete and no longer exist as of 1.17. snapshot - This also is a mapping set generated by MCP, similar to a nightly build of a program. These are also typically incomplete and no longer exist as of 1.17. Note The class names used in production are from stable prior to 1.17 and from official from 1.17 onwards. mappings { // Sets the mappings to use those from Mojang for Minecraft 1.19.4. mappings channel: 'official', version: '1.19.4' // ... } Parchment Parchment is an official project maintained by ParchmentMC which provides open, community-sourced parameter names and javadocs on top of the official mapping set. You can learn how setup and use the parchment mapping set on their website . Preparing Run Tasks Run tasks ( run* ) have two separate pipelines depending on whether they are executed through gradlew or a run configuration. By default, there are two tasks that prepare the workspace for execution: First, there are prepare* tasks which are executed before run* tasks and ensure that mapping files are prepared for the game. The prepare*Compile task is typically only executed as a dependency of run* tasks to make sure that the game is compiled before it is run. If your IDE is either Eclipse or IntelliJ IDEA, the run configuration can be configured to execute the prepare* tasks before starting the game by setting enableEclipsePrepareRuns or enableIdeaPrepareRuns , respectively, to true . This will allow you to invoke custom Gradle tasks before your IDE launches the game. minecraft { // ... // Enable the 'prepare*' task for run configurations enableEclipsePrepareRuns true enableIdeaPrepareRuns true } Copy IDE Resources The copyIdeResources property can be used to copy resources configured by the processResources task to the IDE\u2019s resource output directories. This allows IDE run configurations that do not invoke Gradle (IntelliJ configured to use the IDEA runner or Eclipse) to use buildscript configurable resources. Usually, you need to enable this property when you are replacing values in files like the mods.toml . This only applies to Eclipse and IntelliJ IDEA via the copyEclipseResources and copyIntellijResources tasks, respectively. minecraft { // ... // Copies the files from 'processResources' to the IDE's resource output directories copyIdeResources true } Run Configuration Folders Run configurations can be sorted into folders if the generateRunFolders is set to true . This reads the folderName property set in the specific run configuration to determine the organizational structure. minecraft { // ... // When true, run configurations will be grouped into folders by their 'folderName' generateRunFolders true }","title":"Introduction"},{"location":"configuration/#forgegradle-configurations","text":"ForgeGradle has numerous configurations that can change how the development environment is configured. Most configurations are set using the minecraft block; however, some others can be specified within the dependencies block or modify the built jar , such as reobfJar .","title":"ForgeGradle Configurations"},{"location":"configuration/#enabling-access-transformers","text":"Access Transformers can widen the visibility or modify the final flag of Minecraft classes, methods, and fields. To enable access transformers in the production environment, you can set accessTransformer to configuration file in question: minecraft { // ... // Add an access transformer file relative to the project's directory accessTransformer = project.file('src/main/resources/META-INF/accesstransformer.cfg') } Important While the access transformer in the development environment can be read from anywhere the user specifies, in production, the file will only be read from META-INF/accesstransformer.cfg .","title":"Enabling Access Transformers"},{"location":"configuration/#human-readable-mappings","text":"Minecraft\u2019s source code is obfuscated. As such, all classes, methods, and fields have machine-generated names with no package structures. Function-local variable names, meanwhile, are turned into a snowman ( \u2603 ) due to how the Local Variable Table is stored. It is difficult to create mods using obfuscated names as reverse engineering them is tedious, may change between versions, and may be invalid in the language itself but not in the bytecode. To address the last two issues, Forge fuzzily maps each class, method, field, and parameter to a unique identifier, known as the SRG name, via the ForgeAutoRenamingTool . SRG mappings are used in production when the game is being run by the user client. To allow easier development, ForgeGradle allows the user to choose a mapping set to apply on top of SRG mappings, which we will refer to as human-readable mappings. ForgeGradle knows how to convert the mod jar to SRG mappings for use in production via the reobf* task. The mapping set used can be specified by setting the mappings field in the minecraft block. The mappings field takes in two arguments: channel which is the type of the mapping set, and version which is the version of the mapping set to apply. Currently, there are three default mapping sets built into ForgeGradle: official - This uses the mapping set provided by Mojang. These mappings do not have parameter names and only exist from 1.14 onward. stable - This uses a mapping set generated by MCP. These are typically incomplete and no longer exist as of 1.17. snapshot - This also is a mapping set generated by MCP, similar to a nightly build of a program. These are also typically incomplete and no longer exist as of 1.17. Note The class names used in production are from stable prior to 1.17 and from official from 1.17 onwards. mappings { // Sets the mappings to use those from Mojang for Minecraft 1.19.4. mappings channel: 'official', version: '1.19.4' // ... }","title":"Human-Readable Mappings"},{"location":"configuration/#parchment","text":"Parchment is an official project maintained by ParchmentMC which provides open, community-sourced parameter names and javadocs on top of the official mapping set. You can learn how setup and use the parchment mapping set on their website .","title":"Parchment"},{"location":"configuration/#preparing-run-tasks","text":"Run tasks ( run* ) have two separate pipelines depending on whether they are executed through gradlew or a run configuration. By default, there are two tasks that prepare the workspace for execution: First, there are prepare* tasks which are executed before run* tasks and ensure that mapping files are prepared for the game. The prepare*Compile task is typically only executed as a dependency of run* tasks to make sure that the game is compiled before it is run. If your IDE is either Eclipse or IntelliJ IDEA, the run configuration can be configured to execute the prepare* tasks before starting the game by setting enableEclipsePrepareRuns or enableIdeaPrepareRuns , respectively, to true . This will allow you to invoke custom Gradle tasks before your IDE launches the game. minecraft { // ... // Enable the 'prepare*' task for run configurations enableEclipsePrepareRuns true enableIdeaPrepareRuns true }","title":"Preparing Run Tasks"},{"location":"configuration/#copy-ide-resources","text":"The copyIdeResources property can be used to copy resources configured by the processResources task to the IDE\u2019s resource output directories. This allows IDE run configurations that do not invoke Gradle (IntelliJ configured to use the IDEA runner or Eclipse) to use buildscript configurable resources. Usually, you need to enable this property when you are replacing values in files like the mods.toml . This only applies to Eclipse and IntelliJ IDEA via the copyEclipseResources and copyIntellijResources tasks, respectively. minecraft { // ... // Copies the files from 'processResources' to the IDE's resource output directories copyIdeResources true }","title":"Copy IDE Resources"},{"location":"configuration/#run-configuration-folders","text":"Run configurations can be sorted into folders if the generateRunFolders is set to true . This reads the folderName property set in the specific run configuration to determine the organizational structure. minecraft { // ... // When true, run configurations will be grouped into folders by their 'folderName' generateRunFolders true }","title":"Run Configuration Folders"},{"location":"configuration/advanced/","text":"Advanced Configurations ForgeGradle contains a few specific or nuanced configuration techniques depending on the complexity of your build project. Reobfuscating Source Sets By default, the reobf* abd rename* tasks only contain files on the main source set\u2019s classpath. To reobfuscate files on a different classpath, they need to be added to the libraries property within the task. // Adds another source set's classpath to 'reobf' task. tasks.withType('reobfJar') { libraries.from sourceSets.api.classpath }","title":"Advanced Topics"},{"location":"configuration/advanced/#advanced-configurations","text":"ForgeGradle contains a few specific or nuanced configuration techniques depending on the complexity of your build project.","title":"Advanced Configurations"},{"location":"configuration/advanced/#reobfuscating-source-sets","text":"By default, the reobf* abd rename* tasks only contain files on the main source set\u2019s classpath. To reobfuscate files on a different classpath, they need to be added to the libraries property within the task. // Adds another source set's classpath to 'reobf' task. tasks.withType('reobfJar') { libraries.from sourceSets.api.classpath }","title":"Reobfuscating Source Sets"},{"location":"configuration/runs/","text":"Run Configurations Run configurations define how an instance of the game is going to run. This includes arguments, working directories, task names, etc. Run configurations are defined within the minecraft.runs block. While no runs are configured by default, Forge does provide the configurations client , server , data , or gameTestServer . minecraft { // ... runs { // Configure runs here } } Run configurations can be added similar to any NamedDomainObjectContainer using closures. // Inside the minecraft block runs { // Creates or configures the run configuration named 'client' client { // Configure run } } The following configurations properties are available: // Inside the runs block client { // The name of the Gradle run tasks, // Defaults to 'runX' where X is the container name taskName 'runThing' // Sets the entrypoint of the program to launch // Forge sets userdev main to be 'cpw.mods.bootstraplauncher.BootstrapLauncher' main 'com.example.Main' // Sets the working directory of the config // Defaults to './run' workingDirectory 'run' // Sets the name of the module for IntelliJ IDEA to configure for its runs // Defaults to '<project_name>.main' ideaModule 'example.main' // Sets the name of the folder that the run configuration should be added to // Defaults to the name of the project folderName 'example' // Sets whether this should run a Minecraft client // If not specified, checks the following // - Is there an environment property 'thing' that contains 'client' // - Does the configuration name contain 'client' // - Is main set to 'mcp.client.Start' // - Is main set to 'net.minecraft.client.main.Main' client true // Set the parent of this configuration to inherit from parent runs.example // Sets the children of this configuration children runs.child // Merges this configuration and specifies whether to overwrite existing properties merge runs.server, true // If not false, will merge the arguments of the parent with this configuration inheritArgs false // If not false, will merge the JVM arguments of the parent with this configuration inheritJvmArgs false // Adds a sourceset to the classpath // If none is specified, adds sourceSet.main source sourceSets.api // Sets an environment property for the run // Value will be interpreted as a file or a string environment 'envKey', 'value' // Sets a system property // Value will be interpreted as a file or a string property 'propKey', 'value' // Sets an argument to be passed into the application // Can specify multiple with 'args' arg 'hello' // Sets a JVM argument // Can specify multiple with 'jvmArgs' jvmArg '-Xmx2G' // Sets a token // Currently, the following tokens are being used: // - runtime_classpath // - minecraft_classpath token 'tokenKey', 'value' // Sets a token that's lazily initialized // Should usually be used instead of 'token', for example when the token resolves Gradle configurations lazyToken('lazyTokenKey') { 'value' } // If true, compile all projects instead of for the current task // This is only used by IntelliJ IDEA buildAllProjects false } Tip You can see a list of all configured userdev properties within the MinecraftForge buildscript . Mod Configurations A mod in the current environment can be added using the mods block within a Run configuration. Mod blocks are also NamedDomainObjectContainer s. // Inside the runs block client { // ... mods { other_mod { // ... } // Configures the 'example' mod example { // Add a source set to a mod's sources source sourceSets.main // Merges this configuration and specifies whether to overwrite existing properties merge mods.other_mod, true } } }","title":"Run Configs"},{"location":"configuration/runs/#run-configurations","text":"Run configurations define how an instance of the game is going to run. This includes arguments, working directories, task names, etc. Run configurations are defined within the minecraft.runs block. While no runs are configured by default, Forge does provide the configurations client , server , data , or gameTestServer . minecraft { // ... runs { // Configure runs here } } Run configurations can be added similar to any NamedDomainObjectContainer using closures. // Inside the minecraft block runs { // Creates or configures the run configuration named 'client' client { // Configure run } } The following configurations properties are available: // Inside the runs block client { // The name of the Gradle run tasks, // Defaults to 'runX' where X is the container name taskName 'runThing' // Sets the entrypoint of the program to launch // Forge sets userdev main to be 'cpw.mods.bootstraplauncher.BootstrapLauncher' main 'com.example.Main' // Sets the working directory of the config // Defaults to './run' workingDirectory 'run' // Sets the name of the module for IntelliJ IDEA to configure for its runs // Defaults to '<project_name>.main' ideaModule 'example.main' // Sets the name of the folder that the run configuration should be added to // Defaults to the name of the project folderName 'example' // Sets whether this should run a Minecraft client // If not specified, checks the following // - Is there an environment property 'thing' that contains 'client' // - Does the configuration name contain 'client' // - Is main set to 'mcp.client.Start' // - Is main set to 'net.minecraft.client.main.Main' client true // Set the parent of this configuration to inherit from parent runs.example // Sets the children of this configuration children runs.child // Merges this configuration and specifies whether to overwrite existing properties merge runs.server, true // If not false, will merge the arguments of the parent with this configuration inheritArgs false // If not false, will merge the JVM arguments of the parent with this configuration inheritJvmArgs false // Adds a sourceset to the classpath // If none is specified, adds sourceSet.main source sourceSets.api // Sets an environment property for the run // Value will be interpreted as a file or a string environment 'envKey', 'value' // Sets a system property // Value will be interpreted as a file or a string property 'propKey', 'value' // Sets an argument to be passed into the application // Can specify multiple with 'args' arg 'hello' // Sets a JVM argument // Can specify multiple with 'jvmArgs' jvmArg '-Xmx2G' // Sets a token // Currently, the following tokens are being used: // - runtime_classpath // - minecraft_classpath token 'tokenKey', 'value' // Sets a token that's lazily initialized // Should usually be used instead of 'token', for example when the token resolves Gradle configurations lazyToken('lazyTokenKey') { 'value' } // If true, compile all projects instead of for the current task // This is only used by IntelliJ IDEA buildAllProjects false } Tip You can see a list of all configured userdev properties within the MinecraftForge buildscript .","title":"Run Configurations"},{"location":"configuration/runs/#mod-configurations","text":"A mod in the current environment can be added using the mods block within a Run configuration. Mod blocks are also NamedDomainObjectContainer s. // Inside the runs block client { // ... mods { other_mod { // ... } // Configures the 'example' mod example { // Add a source set to a mod's sources source sourceSets.main // Merges this configuration and specifies whether to overwrite existing properties merge mods.other_mod, true } } }","title":"Mod Configurations"},{"location":"dependencies/","text":"Dependencies Dependencies are not only used to develop interoperability between mods or add additional libraries to the game, but it also determines what version of Minecraft to develop for. This will provide a quick overview on how to modify the repositories and dependencies block to add dependencies to your development environment. This will not explain Gradle concepts in depth. It is highly recommended to read the Gradle Dependency Management guide before continuing. minecraft The minecraft dependency specifies the version of Minecraft to use and must be included in the dependencies block. Any artifact, except artifacts which have the group net.minecraft , will apply any patches provided with the dependency. This typically only specifies the net.minecraftforge:forge artifact. dependencies { // Version of Forge artifact is in the form '<mc_version>-<forge_version>' // 'mc_version' is the version of Minecraft to load (e.g., 1.19.4) // 'forge_version' is the version of Forge wanted for that Minecraft version (e.g., 45.0.23) // Vanilla can be compiled against using 'net.minecraft:joined:<mc_version>' instead minecraft 'net.minecraftforge:forge:1.19.4-45.0.23' } Mod Dependencies In a typical development environment, Minecraft is deobfuscated to intermediate mappings, used in production, and then transformed into whatever human-readable mappings the modder specified. Mod artifacts, when built, are obfuscated to production mappings (SRG), and as such, are unable to be used directly as a Gradle dependency. As such, all mod dependencies need to be wrapped with fg.deobf before being added to the intended configuration. dependencies { // Assume we have already specified the 'minecraft' dependency // Assume we have some artifact 'examplemod' that can be obtained from a specified repository implementation fg.deobf('com.example:examplemod:1.0') } Local Mod Dependencies If the mod you are trying to depend on is not available on a maven repository (e.g., Maven Central , CurseMaven , Modrinth ), you can add a mod dependency using a [flat directory] instead: repositories { // Adds the 'libs' folder in the project directory as a flat directory flatDir { dir 'libs' } } dependencies { // ... // Given some <group>:<name>:<version>:<classifier (default None)> // with an extension <ext (default jar)> // Artifacts in flat directories will be resolved in the following order: // - <name>-<version>.<ext> // - <name>-<version>-<classifier>.<ext> // - <name>.<ext> // - <name>-<classifier>.<ext> // If a classifier is explicitly specified // artifacts with the classifier will take priority: // - examplemod-1.0-api.jar // - examplemod-api.jar // - examplemod-1.0.jar // - examplemod.jar implementation fg.deobf('com.example:examplemod:1.0:api') } Note The group name can be anything but must not be empty for flat directory entries as they are not checked when resolving the artifact file. Non-Minecraft Dependencies Non-Minecraft dependencies are not loaded by Forge by default in the development environment. To get Forge to recognize the non-Minecraft dependency, they must be added to the minecraftLibrary configuration. minecraftLibrary works similarly to the implementation configuration within Gradle, being applied during compile time and runtime. dependencies { // ... // Assume there is some non-Minecraft library 'dummy-lib' minecraftLibrary 'com.dummy:dummy-lib:1.0' } Non-Minecraft dependencies added to the development environment will not be included in built artifact by default! You must use Jar-In-Jar to include the dependencies within the artifact on build.","title":"Introduction"},{"location":"dependencies/#dependencies","text":"Dependencies are not only used to develop interoperability between mods or add additional libraries to the game, but it also determines what version of Minecraft to develop for. This will provide a quick overview on how to modify the repositories and dependencies block to add dependencies to your development environment. This will not explain Gradle concepts in depth. It is highly recommended to read the Gradle Dependency Management guide before continuing.","title":"Dependencies"},{"location":"dependencies/#minecraft","text":"The minecraft dependency specifies the version of Minecraft to use and must be included in the dependencies block. Any artifact, except artifacts which have the group net.minecraft , will apply any patches provided with the dependency. This typically only specifies the net.minecraftforge:forge artifact. dependencies { // Version of Forge artifact is in the form '<mc_version>-<forge_version>' // 'mc_version' is the version of Minecraft to load (e.g., 1.19.4) // 'forge_version' is the version of Forge wanted for that Minecraft version (e.g., 45.0.23) // Vanilla can be compiled against using 'net.minecraft:joined:<mc_version>' instead minecraft 'net.minecraftforge:forge:1.19.4-45.0.23' }","title":"minecraft"},{"location":"dependencies/#mod-dependencies","text":"In a typical development environment, Minecraft is deobfuscated to intermediate mappings, used in production, and then transformed into whatever human-readable mappings the modder specified. Mod artifacts, when built, are obfuscated to production mappings (SRG), and as such, are unable to be used directly as a Gradle dependency. As such, all mod dependencies need to be wrapped with fg.deobf before being added to the intended configuration. dependencies { // Assume we have already specified the 'minecraft' dependency // Assume we have some artifact 'examplemod' that can be obtained from a specified repository implementation fg.deobf('com.example:examplemod:1.0') }","title":"Mod Dependencies"},{"location":"dependencies/#local-mod-dependencies","text":"If the mod you are trying to depend on is not available on a maven repository (e.g., Maven Central , CurseMaven , Modrinth ), you can add a mod dependency using a [flat directory] instead: repositories { // Adds the 'libs' folder in the project directory as a flat directory flatDir { dir 'libs' } } dependencies { // ... // Given some <group>:<name>:<version>:<classifier (default None)> // with an extension <ext (default jar)> // Artifacts in flat directories will be resolved in the following order: // - <name>-<version>.<ext> // - <name>-<version>-<classifier>.<ext> // - <name>.<ext> // - <name>-<classifier>.<ext> // If a classifier is explicitly specified // artifacts with the classifier will take priority: // - examplemod-1.0-api.jar // - examplemod-api.jar // - examplemod-1.0.jar // - examplemod.jar implementation fg.deobf('com.example:examplemod:1.0:api') } Note The group name can be anything but must not be empty for flat directory entries as they are not checked when resolving the artifact file.","title":"Local Mod Dependencies"},{"location":"dependencies/#non-minecraft-dependencies","text":"Non-Minecraft dependencies are not loaded by Forge by default in the development environment. To get Forge to recognize the non-Minecraft dependency, they must be added to the minecraftLibrary configuration. minecraftLibrary works similarly to the implementation configuration within Gradle, being applied during compile time and runtime. dependencies { // ... // Assume there is some non-Minecraft library 'dummy-lib' minecraftLibrary 'com.dummy:dummy-lib:1.0' } Non-Minecraft dependencies added to the development environment will not be included in built artifact by default! You must use Jar-In-Jar to include the dependencies within the artifact on build.","title":"Non-Minecraft Dependencies"},{"location":"dependencies/jarinjar/","text":"Jar-in-Jar Jar-in-Jar is a way to load dependencies for mods from within the jars of the mods. To accomplish this, Jar-in-Jar generates a metadata json within META-INF/jarjar/metadata.json on build containing the artifacts to load from within the jar. Jar-in-Jar is a completely optional system which can be enabled using jarJar#enable before the minecraft block. This will include all dependencies from the jarJar configuration into the jarJar task. You can configure the task similarly to other jar tasks: // In build.gradle // Enable the Jar-in-Jar system for your mod jarJar.enable() // Configure the 'jarJar' task // 'all' is the default classifier tasks.named('jarJar') { // ... } Adding Dependencies You can add dependencies to be included inside your jar using the jarJar configuration. As Jar-in-Jar is a negotiation system, all versions should supply a supported range. // In build.gradle dependencies { // Compiles against and includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') } If you need to specify an exact version to include rather than the highest supported version in the range, you can use jarJar#pin within the dependency closure. In these instances, the artifact version will be used during compile time while the pinned version will be bundled inside the mod jar. // In build.gradle dependencies { // Compiles against the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') { // Includes examplelib 2.8.0 jarJar.pin(it, '2.8.0') } } You can additionally pin a version range while compiling against a specific version instead: // In build.gradle dependencies { // Compiles against examplelib 2.8.0 jarJar(group: 'com.example', name: 'examplelib', version: '2.8.0') { // Includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar.pin(it, '[2.0,3.0)') } } Using Runtime Dependencies If you would like to include the runtime dependencies of your mod inside your jar, you can invoke jarJar#fromRuntimeConfiguration within your buildscript. If you decide to use this option, it is highly suggested to include dependency filters; otherwise, every single dependency \u2013 including Minecraft and Forge \u2013 will be bundled in the jar as well. To support more flexible statements, the dependency configuration has been added to the jarJar extension and task. Using this, you can specify patterns to include or exclude from the configuration: // In build.gradle // Add runtime dependencies to jar jarJar.fromRuntimeConfiguration() // ... jarJar { // Include or exclude dependencies here from runtime configuration dependencies { // Exclude any dependency which begins with 'com.google.gson.' exclude(dependency('com.google.gson.*')) } } Tip It is generally recommended to set at least one include filter when using #fromRuntimeConfiguration . Publishing a Jar-in-Jar to Maven For archival reasons, ForgeGradle supports publishing Jar-in-Jar artifacts to a maven of choice, similar to how the Shadow plugin handles it. In practices, this is not useful or recommended. // In build.gradle (has 'maven-publish' plugin) publications { mavenJava(MavenPublication) { // Add standard java components and Jar-in-Jar artifact from components.java jarJar.component(it) // ... } }","title":"Jar-in-Jar"},{"location":"dependencies/jarinjar/#jar-in-jar","text":"Jar-in-Jar is a way to load dependencies for mods from within the jars of the mods. To accomplish this, Jar-in-Jar generates a metadata json within META-INF/jarjar/metadata.json on build containing the artifacts to load from within the jar. Jar-in-Jar is a completely optional system which can be enabled using jarJar#enable before the minecraft block. This will include all dependencies from the jarJar configuration into the jarJar task. You can configure the task similarly to other jar tasks: // In build.gradle // Enable the Jar-in-Jar system for your mod jarJar.enable() // Configure the 'jarJar' task // 'all' is the default classifier tasks.named('jarJar') { // ... }","title":"Jar-in-Jar"},{"location":"dependencies/jarinjar/#adding-dependencies","text":"You can add dependencies to be included inside your jar using the jarJar configuration. As Jar-in-Jar is a negotiation system, all versions should supply a supported range. // In build.gradle dependencies { // Compiles against and includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') } If you need to specify an exact version to include rather than the highest supported version in the range, you can use jarJar#pin within the dependency closure. In these instances, the artifact version will be used during compile time while the pinned version will be bundled inside the mod jar. // In build.gradle dependencies { // Compiles against the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar(group: 'com.example', name: 'examplelib', version: '[2.0,3.0)') { // Includes examplelib 2.8.0 jarJar.pin(it, '2.8.0') } } You can additionally pin a version range while compiling against a specific version instead: // In build.gradle dependencies { // Compiles against examplelib 2.8.0 jarJar(group: 'com.example', name: 'examplelib', version: '2.8.0') { // Includes the highest supported version of examplelib // between 2.0 (inclusive) and 3.0 (exclusive) jarJar.pin(it, '[2.0,3.0)') } }","title":"Adding Dependencies"},{"location":"dependencies/jarinjar/#using-runtime-dependencies","text":"If you would like to include the runtime dependencies of your mod inside your jar, you can invoke jarJar#fromRuntimeConfiguration within your buildscript. If you decide to use this option, it is highly suggested to include dependency filters; otherwise, every single dependency \u2013 including Minecraft and Forge \u2013 will be bundled in the jar as well. To support more flexible statements, the dependency configuration has been added to the jarJar extension and task. Using this, you can specify patterns to include or exclude from the configuration: // In build.gradle // Add runtime dependencies to jar jarJar.fromRuntimeConfiguration() // ... jarJar { // Include or exclude dependencies here from runtime configuration dependencies { // Exclude any dependency which begins with 'com.google.gson.' exclude(dependency('com.google.gson.*')) } } Tip It is generally recommended to set at least one include filter when using #fromRuntimeConfiguration .","title":"Using Runtime Dependencies"},{"location":"dependencies/jarinjar/#publishing-a-jar-in-jar-to-maven","text":"For archival reasons, ForgeGradle supports publishing Jar-in-Jar artifacts to a maven of choice, similar to how the Shadow plugin handles it. In practices, this is not useful or recommended. // In build.gradle (has 'maven-publish' plugin) publications { mavenJava(MavenPublication) { // Add standard java components and Jar-in-Jar artifact from components.java jarJar.component(it) // ... } }","title":"Publishing a Jar-in-Jar to Maven"},{"location":"gettingstarted/","text":"Getting Started with ForgeGradle If you have never used ForgeGradle before, here is the minimum amount of information needed to get a development environment setup. Prerequisites An installation of the Java Development Kit (JDK) Minecraft Versions Java Development Kit Version 1.12 - 1.16 JDK 8 1.17 JDK 16 1.18 - 1.19 JDK 17 Familiarity with an Integrated Development Environment (IDE) It is preferable to use one with some form of Gradle integration Setting Up ForgeGradle First download a copy of the Modder Development Kit (MDK) from MinecraftForge and extract the zip to an empty directory. Open the directory you extracted the MDK to within your IDE of choice. If your IDE integrates with Gradle, import it as a Gradle project. Customize your Gradle buildscript for your mod: Set archivesBaseName to the desired mod id. Additionally, replace all occurrences of examplemod with the mod id as well. Change the group to your desired package name. Make sure to follow existing naming conventions . Change the version number to reflect the current version of your mod. It is highly recommended to use Forge\u2019s extension on semantic versioning . Important Make sure that any changes to the mod id are reflected in the mods.toml and main mod class. See Structuring Your Mod on the Forge docs for more information. Reload or refresh your Gradle project using your IDE. If your IDE does not have Gradle integration, run the following from a shell in your project\u2019s directory: ./gradlew build --refresh-dependencies If your IDE is either Eclipse, IntelliJ IDEA, or Visual Studio Code, you can generate run configurations using one of the following commands, respectively: Eclipse ./gradlew genEclipseRuns IntelliJ IDEA ./gradlew genIntellijRuns Visual Studio Code ./gradlew genVSCodeRuns You can the run the client, server, etc. using one of the generated run configurations. Tip If your IDE is not listed, you can still run the configurations using ./gradlew run* (e.g., runClient , runServer , runData ). You can use these commands with the supported IDEs as well. Congratulations, now you have a development environment set up!","title":"Introduction"},{"location":"gettingstarted/#getting-started-with-forgegradle","text":"If you have never used ForgeGradle before, here is the minimum amount of information needed to get a development environment setup.","title":"Getting Started with ForgeGradle"},{"location":"gettingstarted/#prerequisites","text":"An installation of the Java Development Kit (JDK) Minecraft Versions Java Development Kit Version 1.12 - 1.16 JDK 8 1.17 JDK 16 1.18 - 1.19 JDK 17 Familiarity with an Integrated Development Environment (IDE) It is preferable to use one with some form of Gradle integration","title":"Prerequisites"},{"location":"gettingstarted/#setting-up-forgegradle","text":"First download a copy of the Modder Development Kit (MDK) from MinecraftForge and extract the zip to an empty directory. Open the directory you extracted the MDK to within your IDE of choice. If your IDE integrates with Gradle, import it as a Gradle project. Customize your Gradle buildscript for your mod: Set archivesBaseName to the desired mod id. Additionally, replace all occurrences of examplemod with the mod id as well. Change the group to your desired package name. Make sure to follow existing naming conventions . Change the version number to reflect the current version of your mod. It is highly recommended to use Forge\u2019s extension on semantic versioning . Important Make sure that any changes to the mod id are reflected in the mods.toml and main mod class. See Structuring Your Mod on the Forge docs for more information. Reload or refresh your Gradle project using your IDE. If your IDE does not have Gradle integration, run the following from a shell in your project\u2019s directory: ./gradlew build --refresh-dependencies If your IDE is either Eclipse, IntelliJ IDEA, or Visual Studio Code, you can generate run configurations using one of the following commands, respectively:","title":"Setting Up ForgeGradle"},{"location":"gettingstarted/#eclipse","text":"./gradlew genEclipseRuns","title":"Eclipse"},{"location":"gettingstarted/#intellij-idea","text":"./gradlew genIntellijRuns","title":"IntelliJ IDEA"},{"location":"gettingstarted/#visual-studio-code","text":"./gradlew genVSCodeRuns You can the run the client, server, etc. using one of the generated run configurations. Tip If your IDE is not listed, you can still run the configurations using ./gradlew run* (e.g., runClient , runServer , runData ). You can use these commands with the supported IDEs as well. Congratulations, now you have a development environment set up!","title":"Visual Studio Code"},{"location":"porting/5.x_to_6.0/","text":"ForgeGradle 5 -> 6 Migration Primer This is a high level, non-exhaustive overview on how to migrate your buildscript from ForgeGradle 5 to 6. If there\u2019s any incorrect or missing information, please leave a comment below. Thanks! Add Foojay Toolchains Plugin Gradle now uses the Foojay Toolchains Plugin to manage the Java toolchain. The plugin must be added to the settings.gradle[.kts] : With Gradle DSL: // In settings.gradle plugins { id 'org.gradle.toolchains.foojay-resolver-convention' version '0.5.0' } With Kotlin DSL: // In settings.gradle.kts plugins { id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"0.5.0\" } Update Gradle to 8.1.1 First, you need to update your Gradle Wrapper to use 8.1.1. You can find additional information regarding the migration process from 7 to 8 on Gradle\u2019s migration guide . This can be done in one of two ways: gradle wrapper The preferred option is to use the gradle wrapper command with the --gradle-version option. # Inside root directory of the gradle project ./gradlew wrapper --gradle-version=8.1.1 gradle-wrapper.properties This method is not recommended, and it should only be used if the gradlew wrapper command above fails. Update the version in the distributionUrl property within gradle/wrapper/gradle-wrapper.properties . Afterwards run ./gradlew wrapper . distributionUrl=https\\://services.gradle.org/distributions/gradle-8.1.1-bin.zip Update ForgeGradle Plugin Version After updating Gradle, update the ForgeGradle version in your build.gradle[.kts] to [6.0,6.2) : With Gradle DSL: // In build.gradle plugins { id 'net.minecraftforge.gradle' version '[6.0,6.2)' } With Kotlin DSL: // In build.gradle.kts plugins { id(\"net.minecraftforge.gradle\") version \"[6.0,6.2)\" } Remove forceExit from Run Configurations ForgeGradle has now removed the forceExit property in run configurations. Changes to run tasks only apply to the current project and not any subprojects. Minor Additions, Changes, Removals Reobfuscated Classpath Inheritance If you were using classpath.from within a reobf* task configuration to declare extra libraries, the reobf* task needed to take into account; it should be migrated to the libraries.from property instead. Eclipse Launcher Groups If ForgeGradle is setup such that Eclipse should run the Gradle tasks before starting the game, you must execute the run configuration from the Launch Group folder. This is only true if new properties are enabled within the minecraft block. Removal of resources and classes in ModConfig The properties resources and classes within the mods block of a run configuration have been removed from ForgeGradle 6.","title":"Porting to this Version"},{"location":"porting/5.x_to_6.0/#forgegradle-5-6-migration-primer","text":"This is a high level, non-exhaustive overview on how to migrate your buildscript from ForgeGradle 5 to 6. If there\u2019s any incorrect or missing information, please leave a comment below. Thanks!","title":"ForgeGradle 5 -&gt; 6 Migration Primer"},{"location":"porting/5.x_to_6.0/#add-foojay-toolchains-plugin","text":"Gradle now uses the Foojay Toolchains Plugin to manage the Java toolchain. The plugin must be added to the settings.gradle[.kts] : With Gradle DSL: // In settings.gradle plugins { id 'org.gradle.toolchains.foojay-resolver-convention' version '0.5.0' } With Kotlin DSL: // In settings.gradle.kts plugins { id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"0.5.0\" }","title":"Add Foojay Toolchains Plugin"},{"location":"porting/5.x_to_6.0/#update-gradle-to-811","text":"First, you need to update your Gradle Wrapper to use 8.1.1. You can find additional information regarding the migration process from 7 to 8 on Gradle\u2019s migration guide . This can be done in one of two ways:","title":"Update Gradle to 8.1.1"},{"location":"porting/5.x_to_6.0/#gradle-wrapper","text":"The preferred option is to use the gradle wrapper command with the --gradle-version option. # Inside root directory of the gradle project ./gradlew wrapper --gradle-version=8.1.1","title":"gradle wrapper"},{"location":"porting/5.x_to_6.0/#gradle-wrapperproperties","text":"This method is not recommended, and it should only be used if the gradlew wrapper command above fails. Update the version in the distributionUrl property within gradle/wrapper/gradle-wrapper.properties . Afterwards run ./gradlew wrapper . distributionUrl=https\\://services.gradle.org/distributions/gradle-8.1.1-bin.zip","title":"gradle-wrapper.properties"},{"location":"porting/5.x_to_6.0/#update-forgegradle-plugin-version","text":"After updating Gradle, update the ForgeGradle version in your build.gradle[.kts] to [6.0,6.2) : With Gradle DSL: // In build.gradle plugins { id 'net.minecraftforge.gradle' version '[6.0,6.2)' } With Kotlin DSL: // In build.gradle.kts plugins { id(\"net.minecraftforge.gradle\") version \"[6.0,6.2)\" }","title":"Update ForgeGradle Plugin Version"},{"location":"porting/5.x_to_6.0/#remove-forceexit-from-run-configurations","text":"ForgeGradle has now removed the forceExit property in run configurations. Changes to run tasks only apply to the current project and not any subprojects.","title":"Remove forceExit from Run Configurations"},{"location":"porting/5.x_to_6.0/#minor-additions-changes-removals","text":"","title":"Minor Additions, Changes, Removals"},{"location":"porting/5.x_to_6.0/#reobfuscated-classpath-inheritance","text":"If you were using classpath.from within a reobf* task configuration to declare extra libraries, the reobf* task needed to take into account; it should be migrated to the libraries.from property instead.","title":"Reobfuscated Classpath Inheritance"},{"location":"porting/5.x_to_6.0/#eclipse-launcher-groups","text":"If ForgeGradle is setup such that Eclipse should run the Gradle tasks before starting the game, you must execute the run configuration from the Launch Group folder. This is only true if new properties are enabled within the minecraft block.","title":"Eclipse Launcher Groups"},{"location":"porting/5.x_to_6.0/#removal-of-resources-and-classes-in-modconfig","text":"The properties resources and classes within the mods block of a run configuration have been removed from ForgeGradle 6.","title":"Removal of resources and classes in ModConfig"}]}