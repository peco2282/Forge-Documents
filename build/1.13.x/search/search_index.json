{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MinecraftForge Documentation This is the official documentation for MinecraftForge , the Minecraft modding API. This documentation is only for Forge, this is not a Java tutorial . Contribute to the docs at GitHub .","title":"Home"},{"location":"#minecraftforge-documentation","text":"This is the official documentation for MinecraftForge , the Minecraft modding API. This documentation is only for Forge, this is not a Java tutorial . Contribute to the docs at GitHub .","title":"MinecraftForge Documentation"},{"location":"styleguide/","text":"Style Guide Guide For Contributing to This Documentation This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to build a mod using Forge. Please don\u2019t try to turn this documentation into a tutorial on Java Development - it is intended for people who understand how a Java class works, and other fundamental structures of Java. Formatting Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text.","title":"Style Guide"},{"location":"styleguide/#style-guide","text":"","title":"Style Guide"},{"location":"styleguide/#guide-for-contributing-to-this-documentation","text":"This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to build a mod using Forge. Please don\u2019t try to turn this documentation into a tutorial on Java Development - it is intended for people who understand how a Java class works, and other fundamental structures of Java.","title":"Guide For Contributing to This Documentation"},{"location":"styleguide/#formatting","text":"Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text.","title":"Formatting"},{"location":"animation/armature/","text":"Armature Files Armature Files define joints and clips for animating a model. File Structure An example armature file, taken from the forge debug mod { \"joints\": { \"stick\": {\"2\": [1.0]}, \"cube\": {\"3\": [1.0]} }, \"clips\": { \"default\": { \"loop\": true, \"joint_clips\": { \"stick\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] } ], \"cube\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] }, { \"variable\": \"axis_z\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 1 ] }, { \"variable\": \"origin_x\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.15625 ] }, { \"variable\": \"origin_y\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.40625 ] }, { \"variable\": \"angle\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 120, 240, 0, 120, 240] } ] }, \"events\": {} } } } The file is organized in two sections, joints and clips. Joints Each joint defines an object that animates together as a single unit in the animation. With Vanilla JSON models, this means that multiple elements can belong to the same joint. The format is like this: { \"joints\": { <joint>, ... } } --- <joint> ::= { <string>: { // joint name <joint_definition>, ... } } <joint_definition> ::= { \"<index_model>\": [ <float> ] // index_model, joint_weight (only one value expected in array) } joint_name is the name of the joint index_model is a 0-indexed number (where 0 is the first element defined in the model) denoting a model element this joint controls. Must be a string (see example) joint_weight is a weight (0-1) of how much this joint will contribute to the element\u2019s final transformation if the element is used in multiple joints. Note For simpler animations, the weight can usually just be set to 1.0, but if you want multiple joints in a clip to animate differently, this is one way to accomplish that. Not all elements need to have a joint, only the ones you are animating. If an element occurs in multiple joint, the final transform is a weighted average of the transforms for each joint. Clips Clips are essentially instructions on how to use a value to animate some collection of joints. They also include events to fire at certain points. They are formatted like this: { \"clips\": { \"clip_name\": { \"loop\": <true/false>, \"joint_clips\": { <joint_clip_list>, ... }, \"events\": { <event> ... } } } } ------- <joint_clip_list> ::= { \"joint_name\": [ <joint_clip>, ... ] } <joint_clip> ::= { \"variable\": <variable>, \"type\": \"uniform\", \"interpolation\": <interpolation>, \"samples\": [ float, ... ] } loop: if true, the animation will wrap around when the parameter value goes above 1, if not it\u2019ll just clamp at the final state. Joint Clips Each joint_clip is a set of variables to change for a joint. The type attribute is currently ignored, but must be \"uniform\" . samples defines what value the animation will take on (think of keyframes in traditional animation), and its interpretation depends on the value of interpolation . interpolation , which is how to convert the list of samples into a (possibly) continuous animation can be one of the following: nearest - if value < 0.5 use the first sample, else the second sample. Useful for static variables if only given one value. linear - linearly interpolate between samples. Time between samples is 1 / number of samples. variable can be one of the following: offset_x , offset_y , offset_z - translation scale - uniform scaling scale_x , scale_y , scale_x - scaling on certain axes axis_x , axis_y , axis_z - rotation axes angle - rotation angle origin_x , origin_y , origin_z - rotation origin Events Each clip can fire events, formatted like this: <event> :: { <event_time>: \"event_text\" } For more information about events and what event_text means, see the page on ASMs . event_time is a value (usually between 0 and 1 inclusive) denoting when to fire the event. When the parameter controlling this clip reaches a point equal to or greater than the event_time , the event is fired.","title":"Armatures"},{"location":"animation/armature/#armature-files","text":"Armature Files define joints and clips for animating a model.","title":"Armature Files"},{"location":"animation/armature/#file-structure","text":"An example armature file, taken from the forge debug mod { \"joints\": { \"stick\": {\"2\": [1.0]}, \"cube\": {\"3\": [1.0]} }, \"clips\": { \"default\": { \"loop\": true, \"joint_clips\": { \"stick\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] } ], \"cube\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] }, { \"variable\": \"axis_z\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 1 ] }, { \"variable\": \"origin_x\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.15625 ] }, { \"variable\": \"origin_y\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.40625 ] }, { \"variable\": \"angle\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 120, 240, 0, 120, 240] } ] }, \"events\": {} } } } The file is organized in two sections, joints and clips.","title":"File Structure"},{"location":"animation/armature/#joints","text":"Each joint defines an object that animates together as a single unit in the animation. With Vanilla JSON models, this means that multiple elements can belong to the same joint. The format is like this: { \"joints\": { <joint>, ... } } --- <joint> ::= { <string>: { // joint name <joint_definition>, ... } } <joint_definition> ::= { \"<index_model>\": [ <float> ] // index_model, joint_weight (only one value expected in array) } joint_name is the name of the joint index_model is a 0-indexed number (where 0 is the first element defined in the model) denoting a model element this joint controls. Must be a string (see example) joint_weight is a weight (0-1) of how much this joint will contribute to the element\u2019s final transformation if the element is used in multiple joints. Note For simpler animations, the weight can usually just be set to 1.0, but if you want multiple joints in a clip to animate differently, this is one way to accomplish that. Not all elements need to have a joint, only the ones you are animating. If an element occurs in multiple joint, the final transform is a weighted average of the transforms for each joint.","title":"Joints"},{"location":"animation/armature/#clips","text":"Clips are essentially instructions on how to use a value to animate some collection of joints. They also include events to fire at certain points. They are formatted like this: { \"clips\": { \"clip_name\": { \"loop\": <true/false>, \"joint_clips\": { <joint_clip_list>, ... }, \"events\": { <event> ... } } } } ------- <joint_clip_list> ::= { \"joint_name\": [ <joint_clip>, ... ] } <joint_clip> ::= { \"variable\": <variable>, \"type\": \"uniform\", \"interpolation\": <interpolation>, \"samples\": [ float, ... ] } loop: if true, the animation will wrap around when the parameter value goes above 1, if not it\u2019ll just clamp at the final state.","title":"Clips"},{"location":"animation/armature/#joint-clips","text":"Each joint_clip is a set of variables to change for a joint. The type attribute is currently ignored, but must be \"uniform\" . samples defines what value the animation will take on (think of keyframes in traditional animation), and its interpretation depends on the value of interpolation . interpolation , which is how to convert the list of samples into a (possibly) continuous animation can be one of the following: nearest - if value < 0.5 use the first sample, else the second sample. Useful for static variables if only given one value. linear - linearly interpolate between samples. Time between samples is 1 / number of samples. variable can be one of the following: offset_x , offset_y , offset_z - translation scale - uniform scaling scale_x , scale_y , scale_x - scaling on certain axes axis_x , axis_y , axis_z - rotation axes angle - rotation angle origin_x , origin_y , origin_z - rotation origin","title":"Joint Clips"},{"location":"animation/armature/#events","text":"Each clip can fire events, formatted like this: <event> :: { <event_time>: \"event_text\" } For more information about events and what event_text means, see the page on ASMs . event_time is a value (usually between 0 and 1 inclusive) denoting when to fire the event. When the parameter controlling this clip reaches a point equal to or greater than the event_time , the event is fired.","title":"Events"},{"location":"animation/asm/","text":"Animation State Machine Files Animation State Machine (ASM) Files are the meat of the animation API. These define how the animation is carried out and how to use the clips defined in the armature file. Concepts The ASM contains parameters , clips , states , and transitions . States The Animation State Machine can be in many different states . You define which states there are in the states section. Transitions Transistions define which states are allowed to go to other states, for example allowing a closed state to go to an open state. Note Transitions do not define animations that are played between states, however. If you want to do that you must create an additional state that plays an animation then uses an event to go to the next state. Parameters Note Parameters are called TimeValues in the code, hence the naming convention of SomethingValue. All parameters take an input, usually the current game time in seconds as a float (factoring in partial ticks) and outputs another time. This output is then used as the input to a clip, telling it the current progress of the animation. Each parameter can either be defined in the ASM or when you load the ASM in the code. Load-time parameters are usually of the type VariableValue , which returns a value changeable in-code, ignoring its input. Other types allow you to do math on the input ( SimpleExprValue ), return a constant ( ConstValue ), refer to other parameters ( ParameterValue ), return the input unmodified ( IdentityValue ) and perform composition of two parameters ( CompositionValue ). Clips Note Clips can either be ASM-clips, ones that are defined in the ASM, or armature-clips, ones that are defined in the armature file. For the rest of this page, \u201cclips\u201d will refer to ASM-clips unless otherwise stated. A clip takes in an input, usually the time, and does something to the model with it. Different types of clips do different things, the simplest being animating an armature-clip ( ModelClip ). You can also override the input to another ASM-clip ( TimeClip ), trigger an event while animating another clip if the input is positive ( TriggerClip ), smoothly blend between two clips ( SlerpClip ), refer to another clip in the ASM ( ClipReference ) or do nothing ( IdentityClip ). Events Various things can trigger events in the ASM. Events in the ASM are represented using only text. Some events are special, with text that is formatted like this: !event_type:event_value . Right now there is only one kind of event_type , namely transition . This tries to transition to whatever state is defined in the event_value . Anything else is a normal event and can be used from the pastEvents callback, but more information about that is on the implementing page. Code API Warning The ASM code API can only be used client side . When storing ASMs in code, use the side-agnostic IAnimationStateMachine interface. ASMs can be loaded by calling ModelLoaderRegistry.loadASM . It takes two parameters, the first being a ResourceLocation denoting where the ASM is stored, and second an ImmutableMap of load-time defined parameters. An example: @Nullable private final IAnimationStateMachine asm; private final VariableValue cycle = new VariableValue(4); public Spin() { asm = proxy.loadASM(new ResourceLocation(MODID, \"asms/block/rotatest.json\"), ImmutableMap.of(\"cycle_length\", cycle)); } Here, an ASM is loaded (from a sidedproxy to avoid crashing on server) with one extra parameter, named cycle_length . This parameter is of the type VariableValue , so we can set it from within our code. Using an ASM instance, you can get the current state with .currentState() and transition to another state with .transition(nextState) VariableValue parameters can have their value set by calling .setValue , but you can not read this value back. There is no need to inform the ASM of this change, it happens automatically. File Format The ASMs are stored in json files. The location does not matter, but they are usually placed in an asms folder. First, a simple example: { \"parameters\": { \"anim_cycle\": [\"/\", \"#cycle_length\"] }, \"clips\": { \"default\": [\"apply\", \"forgedebugmodelanimation:block/rotatest@default\", \"#anim_cycle\" ] }, \"states\": [ \"default\" ], \"transitions\": {}, \"start_state\": \"default\" } As stated above, the files have parameters, clips, states and transitions, as well as the starting state of the ASM. All of these tags are required, even if they are empty. Parameters { \"name\": <parameter_definition> } Different types of parameters have different formats for <parameter_definition> , and the simple ones are: IdentityValue : the string #identity , ParameterValue : the parameter to reference, prefixed with # , e.g. #my_awesome_parameter ConstValue : a number to use as the constant to return Mathematical expression ( SimpleExprValue ) Format: [ regex(\"[+\\\\-*/mMrRfF]+\"), <parameter_definition>, ... ] Examples: [ \"+\", 4 ] [ \"/+\", 5, 1] [ \"++\", 2, \"#other\" ] [ \"++\", \"#other\", [ \"compose\", \"#cycle\", 3] ] Explanation The SimpleExprValue takes its input and applies operations to it. The first parameter is the sequence of operations to apply, and the rest represent the operands to those operations. The input to each operation is either the input to this entire parameter (for the first operation) or the result of the previous operation. Operations (case-sensitive): Operator Meaning + output = input + arg - output = input - arg * output = input * arg / output = input / arg m output = min(input, arg) M output = max(input, arg) r output = floor(input / arg) * arg R output = ceil(input / arg) * arg f output = input - floor(input / arg) * arg F output = ceil(input / arg) * arg - input Example explanations: input + 4 (input / 5) + 1 input + 2 + value of parameter other input + value of parameter other + value of parameter cycle given input 3 Function composition ( CompositionValue ) Format: [ \"compose\", <parameter_definition>, <parameter_definition> ] Examples: [ \"compose\", \"#cycle\", 3] [ \"compose\", \"#test\", \"#other\"] [ \"compose\", [ \"+\", 3], \"#other\"] [ \"compose\", [ \"compose\", \"#other2\", \"#other3\"], \"#other\"] Explanation CompositionValue takes two parameter definitions as inputs, and does value1(value2(input)) . In other words, it chains the two inputs, calling the second one with the given input, and the first one with the output of the second one. Example explanations: value of parameter cycle when given input 3 value of parameter test when given the output of parameter other when called with the current input 3 + the output of other with the current input other2(other3(other(input))) because value1 = other2(other3(input)) and value2 = other(input) Clips { \"name\": <clip_definition> } As with parameters, different kinds of clips have different formats for <clip_definition> , but the simple ones are: IdentityClip : the string #identity ClipReference : the clip name prefixed with # , e.g. #my_amazing_clip ModelClip : a model resource location + @ + the name of the armature-clip, e.g. mymod:block/test@default or mymod:block/test#facing=east@moving Overriding input ( TimeClip ) Format: [ \"apply\", <clip_definition>, <parameter_definition> ] Examples: [\"apply\", \"mymod:block/animated_thing@moving\", \"#cycle_time\"] [\"apply\", [ \"apply\", \"mymod:block/animated_thing@moving\", [ \"+\", 3 ] ], \"#cycle\"] Explanation The TimeClip takes another clip and applies it using a custom parameter instead of the current time. Usually used to apply a ModelClip with a parameter instead of the current time. Example explanations: apply the armature-clip for model mymod:block/animated_thing named moving with the output of the parameter cycle_time apply the armature-clip for model mymod:block/animated_thing named moving with 3 + the output of the parameter cycle Triggering an event ( TriggerClip ) Format: [ \"trigger_positive\", <clip_definition>, <parameter_definition>, \"<event_text>\"] Examples [ \"trigger_positive\", \"#default\", \"#end_cycle\", \"!transition:moving\" ] [ \"trigger_positive\", \"mymod:block/animated_thing@moving\", \"#end_cycle\", \"boop\" ] Explanation The TriggerClip visually acts as a TimeClip , but also fires the event in event_text when the parameter_description goes positive. At the same time, it applies the clip in clip_definition with the same parameter_description . Example explanations apply the clip with name default given the input of parameter end_cycle , and when end_cycle is positive transition to the moving state apply the armature-clip mymod:block/animated_thing@moving with parameter end_cycle , and when end_cycle is positive fire event \"boop\" Blend between two clips ( SlerpClip ) Format: [ \"slerp\", <clip_definition>, <clip_definition>, <parameter_definition>, <parameter_definition> ] Examples [ \"slerp\", \"#closed\", \"#open\", \"#identity\", \"#progress\" ] [ \"slerp\", [ \"apply\", \"#move\", \"#mover\"], \"#end\", \"#identity\", \"#progress\" ] Explanation The SlerpClip performs a spherical linear blend between two separate clips. In other words, it will morph one clip into another smoothly. The two clip_definition s are the clips to blend from and to respectively. The first parameter_definition is the \u201cinput\u201d. Both the from and to clips are passed the output of this parameter with the current animation time. The second parameter_definition is the \u201cprogress\u201d, a value between 0 and 1 to denote how far into the blend we are. Combining this clip with trigger_positive and transition special events can allow for simple transitions between two solid states. Example explanations blend the closed clip to the open clip, giving both clips the unaltered time as input and blend progress #progress . blend the result of the move clip when given the input parameter mover to the end clip with the unaltered time as the input with blend progress #progress . States The states section of the file is simply a list of all possible states. For example \"states\": [ \"open\", \"closed\", \"opening\", \"closing\", \"dancing\" ] defines 5 states: open, closed, opening, closing and dancing. Transitions The transitions section defines which states can go to what other states. A state can go to 0, 1, or many other states. To define a state as going to no other states, omit it from the section. To define a state as going to only one other state, create a key with the value of the state it can go to, for example \"open\": \"opening\" . To define a state as going to many other states, do the same as if it were going to only one other state but make the value a list of all possible recieving states instead, for example: \"open\": [\"closed\", \"opening\"] . A more full example: \"transitions\": { \"open\": \"closing\", \"closed\": [ \"dancing\", \"opening\" ], \"closing\": \"closed\", \"opening\": \"open\", \"dancing\": \"closed\" } This example means that: the open state can go to the closing state the closed state can go to either the dancing or opening state the closing state can go to the closed state the opening state can go to the open state the dancing state can go to the closed state","title":"Animation State Machines"},{"location":"animation/asm/#animation-state-machine-files","text":"Animation State Machine (ASM) Files are the meat of the animation API. These define how the animation is carried out and how to use the clips defined in the armature file.","title":"Animation State Machine Files"},{"location":"animation/asm/#concepts","text":"The ASM contains parameters , clips , states , and transitions .","title":"Concepts"},{"location":"animation/asm/#states","text":"The Animation State Machine can be in many different states . You define which states there are in the states section.","title":"States"},{"location":"animation/asm/#transitions","text":"Transistions define which states are allowed to go to other states, for example allowing a closed state to go to an open state. Note Transitions do not define animations that are played between states, however. If you want to do that you must create an additional state that plays an animation then uses an event to go to the next state.","title":"Transitions"},{"location":"animation/asm/#parameters","text":"Note Parameters are called TimeValues in the code, hence the naming convention of SomethingValue. All parameters take an input, usually the current game time in seconds as a float (factoring in partial ticks) and outputs another time. This output is then used as the input to a clip, telling it the current progress of the animation. Each parameter can either be defined in the ASM or when you load the ASM in the code. Load-time parameters are usually of the type VariableValue , which returns a value changeable in-code, ignoring its input. Other types allow you to do math on the input ( SimpleExprValue ), return a constant ( ConstValue ), refer to other parameters ( ParameterValue ), return the input unmodified ( IdentityValue ) and perform composition of two parameters ( CompositionValue ).","title":"Parameters"},{"location":"animation/asm/#clips","text":"Note Clips can either be ASM-clips, ones that are defined in the ASM, or armature-clips, ones that are defined in the armature file. For the rest of this page, \u201cclips\u201d will refer to ASM-clips unless otherwise stated. A clip takes in an input, usually the time, and does something to the model with it. Different types of clips do different things, the simplest being animating an armature-clip ( ModelClip ). You can also override the input to another ASM-clip ( TimeClip ), trigger an event while animating another clip if the input is positive ( TriggerClip ), smoothly blend between two clips ( SlerpClip ), refer to another clip in the ASM ( ClipReference ) or do nothing ( IdentityClip ).","title":"Clips"},{"location":"animation/asm/#events","text":"Various things can trigger events in the ASM. Events in the ASM are represented using only text. Some events are special, with text that is formatted like this: !event_type:event_value . Right now there is only one kind of event_type , namely transition . This tries to transition to whatever state is defined in the event_value . Anything else is a normal event and can be used from the pastEvents callback, but more information about that is on the implementing page.","title":"Events"},{"location":"animation/asm/#code-api","text":"Warning The ASM code API can only be used client side . When storing ASMs in code, use the side-agnostic IAnimationStateMachine interface. ASMs can be loaded by calling ModelLoaderRegistry.loadASM . It takes two parameters, the first being a ResourceLocation denoting where the ASM is stored, and second an ImmutableMap of load-time defined parameters. An example: @Nullable private final IAnimationStateMachine asm; private final VariableValue cycle = new VariableValue(4); public Spin() { asm = proxy.loadASM(new ResourceLocation(MODID, \"asms/block/rotatest.json\"), ImmutableMap.of(\"cycle_length\", cycle)); } Here, an ASM is loaded (from a sidedproxy to avoid crashing on server) with one extra parameter, named cycle_length . This parameter is of the type VariableValue , so we can set it from within our code. Using an ASM instance, you can get the current state with .currentState() and transition to another state with .transition(nextState) VariableValue parameters can have their value set by calling .setValue , but you can not read this value back. There is no need to inform the ASM of this change, it happens automatically.","title":"Code API"},{"location":"animation/asm/#file-format","text":"The ASMs are stored in json files. The location does not matter, but they are usually placed in an asms folder. First, a simple example: { \"parameters\": { \"anim_cycle\": [\"/\", \"#cycle_length\"] }, \"clips\": { \"default\": [\"apply\", \"forgedebugmodelanimation:block/rotatest@default\", \"#anim_cycle\" ] }, \"states\": [ \"default\" ], \"transitions\": {}, \"start_state\": \"default\" } As stated above, the files have parameters, clips, states and transitions, as well as the starting state of the ASM. All of these tags are required, even if they are empty.","title":"File Format"},{"location":"animation/asm/#parameters_1","text":"{ \"name\": <parameter_definition> } Different types of parameters have different formats for <parameter_definition> , and the simple ones are: IdentityValue : the string #identity , ParameterValue : the parameter to reference, prefixed with # , e.g. #my_awesome_parameter ConstValue : a number to use as the constant to return","title":"Parameters"},{"location":"animation/asm/#mathematical-expression-simpleexprvalue","text":"Format: [ regex(\"[+\\\\-*/mMrRfF]+\"), <parameter_definition>, ... ]","title":"Mathematical expression (SimpleExprValue)"},{"location":"animation/asm/#examples","text":"[ \"+\", 4 ] [ \"/+\", 5, 1] [ \"++\", 2, \"#other\" ] [ \"++\", \"#other\", [ \"compose\", \"#cycle\", 3] ]","title":"Examples:"},{"location":"animation/asm/#explanation","text":"The SimpleExprValue takes its input and applies operations to it. The first parameter is the sequence of operations to apply, and the rest represent the operands to those operations. The input to each operation is either the input to this entire parameter (for the first operation) or the result of the previous operation.","title":"Explanation"},{"location":"animation/asm/#operations-case-sensitive","text":"Operator Meaning + output = input + arg - output = input - arg * output = input * arg / output = input / arg m output = min(input, arg) M output = max(input, arg) r output = floor(input / arg) * arg R output = ceil(input / arg) * arg f output = input - floor(input / arg) * arg F output = ceil(input / arg) * arg - input","title":"Operations (case-sensitive):"},{"location":"animation/asm/#example-explanations","text":"input + 4 (input / 5) + 1 input + 2 + value of parameter other input + value of parameter other + value of parameter cycle given input 3","title":"Example explanations:"},{"location":"animation/asm/#function-composition-compositionvalue","text":"Format: [ \"compose\", <parameter_definition>, <parameter_definition> ]","title":"Function composition (CompositionValue)"},{"location":"animation/asm/#examples_1","text":"[ \"compose\", \"#cycle\", 3] [ \"compose\", \"#test\", \"#other\"] [ \"compose\", [ \"+\", 3], \"#other\"] [ \"compose\", [ \"compose\", \"#other2\", \"#other3\"], \"#other\"]","title":"Examples:"},{"location":"animation/asm/#explanation_1","text":"CompositionValue takes two parameter definitions as inputs, and does value1(value2(input)) . In other words, it chains the two inputs, calling the second one with the given input, and the first one with the output of the second one.","title":"Explanation"},{"location":"animation/asm/#example-explanations_1","text":"value of parameter cycle when given input 3 value of parameter test when given the output of parameter other when called with the current input 3 + the output of other with the current input other2(other3(other(input))) because value1 = other2(other3(input)) and value2 = other(input)","title":"Example explanations:"},{"location":"animation/asm/#clips_1","text":"{ \"name\": <clip_definition> } As with parameters, different kinds of clips have different formats for <clip_definition> , but the simple ones are: IdentityClip : the string #identity ClipReference : the clip name prefixed with # , e.g. #my_amazing_clip ModelClip : a model resource location + @ + the name of the armature-clip, e.g. mymod:block/test@default or mymod:block/test#facing=east@moving","title":"Clips"},{"location":"animation/asm/#overriding-input-timeclip","text":"Format: [ \"apply\", <clip_definition>, <parameter_definition> ]","title":"Overriding input (TimeClip)"},{"location":"animation/asm/#examples_2","text":"[\"apply\", \"mymod:block/animated_thing@moving\", \"#cycle_time\"] [\"apply\", [ \"apply\", \"mymod:block/animated_thing@moving\", [ \"+\", 3 ] ], \"#cycle\"]","title":"Examples:"},{"location":"animation/asm/#explanation_2","text":"The TimeClip takes another clip and applies it using a custom parameter instead of the current time. Usually used to apply a ModelClip with a parameter instead of the current time.","title":"Explanation"},{"location":"animation/asm/#example-explanations_2","text":"apply the armature-clip for model mymod:block/animated_thing named moving with the output of the parameter cycle_time apply the armature-clip for model mymod:block/animated_thing named moving with 3 + the output of the parameter cycle","title":"Example explanations:"},{"location":"animation/asm/#triggering-an-event-triggerclip","text":"Format: [ \"trigger_positive\", <clip_definition>, <parameter_definition>, \"<event_text>\"]","title":"Triggering an event (TriggerClip)"},{"location":"animation/asm/#examples_3","text":"[ \"trigger_positive\", \"#default\", \"#end_cycle\", \"!transition:moving\" ] [ \"trigger_positive\", \"mymod:block/animated_thing@moving\", \"#end_cycle\", \"boop\" ]","title":"Examples"},{"location":"animation/asm/#explanation_3","text":"The TriggerClip visually acts as a TimeClip , but also fires the event in event_text when the parameter_description goes positive. At the same time, it applies the clip in clip_definition with the same parameter_description .","title":"Explanation"},{"location":"animation/asm/#example-explanations_3","text":"apply the clip with name default given the input of parameter end_cycle , and when end_cycle is positive transition to the moving state apply the armature-clip mymod:block/animated_thing@moving with parameter end_cycle , and when end_cycle is positive fire event \"boop\"","title":"Example explanations"},{"location":"animation/asm/#blend-between-two-clips-slerpclip","text":"Format: [ \"slerp\", <clip_definition>, <clip_definition>, <parameter_definition>, <parameter_definition> ]","title":"Blend between two clips (SlerpClip)"},{"location":"animation/asm/#examples_4","text":"[ \"slerp\", \"#closed\", \"#open\", \"#identity\", \"#progress\" ] [ \"slerp\", [ \"apply\", \"#move\", \"#mover\"], \"#end\", \"#identity\", \"#progress\" ]","title":"Examples"},{"location":"animation/asm/#explanation_4","text":"The SlerpClip performs a spherical linear blend between two separate clips. In other words, it will morph one clip into another smoothly. The two clip_definition s are the clips to blend from and to respectively. The first parameter_definition is the \u201cinput\u201d. Both the from and to clips are passed the output of this parameter with the current animation time. The second parameter_definition is the \u201cprogress\u201d, a value between 0 and 1 to denote how far into the blend we are. Combining this clip with trigger_positive and transition special events can allow for simple transitions between two solid states.","title":"Explanation"},{"location":"animation/asm/#example-explanations_4","text":"blend the closed clip to the open clip, giving both clips the unaltered time as input and blend progress #progress . blend the result of the move clip when given the input parameter mover to the end clip with the unaltered time as the input with blend progress #progress .","title":"Example explanations"},{"location":"animation/asm/#states_1","text":"The states section of the file is simply a list of all possible states. For example \"states\": [ \"open\", \"closed\", \"opening\", \"closing\", \"dancing\" ] defines 5 states: open, closed, opening, closing and dancing.","title":"States"},{"location":"animation/asm/#transitions_1","text":"The transitions section defines which states can go to what other states. A state can go to 0, 1, or many other states. To define a state as going to no other states, omit it from the section. To define a state as going to only one other state, create a key with the value of the state it can go to, for example \"open\": \"opening\" . To define a state as going to many other states, do the same as if it were going to only one other state but make the value a list of all possible recieving states instead, for example: \"open\": [\"closed\", \"opening\"] . A more full example: \"transitions\": { \"open\": \"closing\", \"closed\": [ \"dancing\", \"opening\" ], \"closing\": \"closed\", \"opening\": \"open\", \"dancing\": \"closed\" } This example means that: the open state can go to the closing state the closed state can go to either the dancing or opening state the closing state can go to the closed state the opening state can go to the open state the dancing state can go to the closed state","title":"Transitions"},{"location":"animation/implementing/","text":"Using the API Depending on what you want to animate with the API, code-side implementation is a bit different. Documentation on the ASM API itself (for controlling the animation) is found on the ASM page because it is independent of what you are animating. Blocks Animations for blocks are done with the AnimationTESR , which is a FastTESR . Because of this, having a TileEntity for your block is necessary. Your TileEntity must provide the ANIMATION_CAPABILITY , which is received by calling its .cast method with your ASM. Your block must also render in the ENTITYBLOCK_ANIMATED render layer if you do not provide a StaticProperty in the block\u2019s blockstate. The StaticProperty is a property you can add to your block\u2019s blockstate by adding Properties.StaticProperty to the list of your block\u2019s properties inside of createBlockState() . When rendering the block, the AnimationTESR checks if the property\u2019s value is true; if so, block rendering continues as normal. Otherwise the AnimationTESR animates the block model assigned to the static=false variant in the blockstate json. All parts of the model that can be static should probably be rendered in the static state, as that is its purpose. The handleEvents() callback is located in the AnimationTESR , so you have to either subclass or overload it inline when you register the tileentity. Here\u2019s an example of registering the TESR: ClientRegistry.bindTileEntitySpecialRenderer(Chest.class, new AnimationTESR<Chest>() { @Override public void handleEvents(Chest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }); In this example, we\u2019ve overridden the handleEvents() callback when we registered the TESR because the implementation is simple, but you could easily subclass AnimationTESR to achieve the same effect. The handleEvents() callback for blocks takes two arguments: the tile entity being rendered, and an iterable of the events. The call to chest.handleEvents() calls a method located in the fictional Chest TileEntity, as the ASM is not accessible inside of the handleEvents() method. Items Animations for items are done entirely using the capability system. Your item must provide the ANIMATION_CAPABILITY through an ICapabilityProvider . You can create an instance of this capability using its .cast method with your ASM, which is usually stored on the ICapabilityProvider object itself. An example of this is below: private static class ItemAnimationHolder implements ICapabilityProvider { private final VariableValue cycleLength = new VariableValue(4); private final IAnimationStateMachine asm = proxy.load(new ResourceLocation(MODID.toLowerCase(), \"asms/block/engine.json\"), ImmutableMap.<String, ITimeValue>of( \"cycle_length\", cycleLength )); @Override public boolean hasCapability(@Nonnull Capability<?> capability, @Nullable EnumFacing facing) { return capability == CapabilityAnimation.ANIMATION_CAPABILITY; } @Override @Nullable public <T> T getCapability(@Nonnull Capability<T> capability, @Nullable EnumFacing facing) { if(capability == CapabilityAnimation.ANIMATION_CAPABILITY) { return CapabilityAnimation.ANIMATION_CAPABILITY.cast(asm); } return null; } } There is no way to receive events on an item in the current implementation. Entities In order to animate an entity with the animation API, your entity\u2019s renderer must take an AnimationModelBase as its model. This model\u2019s constructor takes two parameters, the location of the actual model to animate (as in the path to the JSON or B3D file, not a blockstate reference) and a VertexLighter . The VertexLighter object can be created with new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors()) . The entity must also provide the ANIMATION_CAPABILITY , which can be created with its .cast method by passing the ASM. The handleEvents() callback is located inside the AnimationModelBase class, if you want to use the events you must subclass AnimationModelBase . The callback takes three parameters: the entity being rendered, the current time in partial ticks, and an iterable of the events that have occurred. An example of creating the renderer is shown below: ResourceLocation location = new ModelResourceLocation(new ResourceLocation(MODID, blockName), \"entity\"); return new RenderLiving<EntityChest>(manager, new net.minecraftforge.client.model.animation.AnimationModelBase<EntityChest>(location, new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors())) { @Override public void handleEvents(EntityChest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }, 0.5f) { // ... getEntityTexture() ... };","title":"Using the API"},{"location":"animation/implementing/#using-the-api","text":"Depending on what you want to animate with the API, code-side implementation is a bit different. Documentation on the ASM API itself (for controlling the animation) is found on the ASM page because it is independent of what you are animating.","title":"Using the API"},{"location":"animation/implementing/#blocks","text":"Animations for blocks are done with the AnimationTESR , which is a FastTESR . Because of this, having a TileEntity for your block is necessary. Your TileEntity must provide the ANIMATION_CAPABILITY , which is received by calling its .cast method with your ASM. Your block must also render in the ENTITYBLOCK_ANIMATED render layer if you do not provide a StaticProperty in the block\u2019s blockstate. The StaticProperty is a property you can add to your block\u2019s blockstate by adding Properties.StaticProperty to the list of your block\u2019s properties inside of createBlockState() . When rendering the block, the AnimationTESR checks if the property\u2019s value is true; if so, block rendering continues as normal. Otherwise the AnimationTESR animates the block model assigned to the static=false variant in the blockstate json. All parts of the model that can be static should probably be rendered in the static state, as that is its purpose. The handleEvents() callback is located in the AnimationTESR , so you have to either subclass or overload it inline when you register the tileentity. Here\u2019s an example of registering the TESR: ClientRegistry.bindTileEntitySpecialRenderer(Chest.class, new AnimationTESR<Chest>() { @Override public void handleEvents(Chest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }); In this example, we\u2019ve overridden the handleEvents() callback when we registered the TESR because the implementation is simple, but you could easily subclass AnimationTESR to achieve the same effect. The handleEvents() callback for blocks takes two arguments: the tile entity being rendered, and an iterable of the events. The call to chest.handleEvents() calls a method located in the fictional Chest TileEntity, as the ASM is not accessible inside of the handleEvents() method.","title":"Blocks"},{"location":"animation/implementing/#items","text":"Animations for items are done entirely using the capability system. Your item must provide the ANIMATION_CAPABILITY through an ICapabilityProvider . You can create an instance of this capability using its .cast method with your ASM, which is usually stored on the ICapabilityProvider object itself. An example of this is below: private static class ItemAnimationHolder implements ICapabilityProvider { private final VariableValue cycleLength = new VariableValue(4); private final IAnimationStateMachine asm = proxy.load(new ResourceLocation(MODID.toLowerCase(), \"asms/block/engine.json\"), ImmutableMap.<String, ITimeValue>of( \"cycle_length\", cycleLength )); @Override public boolean hasCapability(@Nonnull Capability<?> capability, @Nullable EnumFacing facing) { return capability == CapabilityAnimation.ANIMATION_CAPABILITY; } @Override @Nullable public <T> T getCapability(@Nonnull Capability<T> capability, @Nullable EnumFacing facing) { if(capability == CapabilityAnimation.ANIMATION_CAPABILITY) { return CapabilityAnimation.ANIMATION_CAPABILITY.cast(asm); } return null; } } There is no way to receive events on an item in the current implementation.","title":"Items"},{"location":"animation/implementing/#entities","text":"In order to animate an entity with the animation API, your entity\u2019s renderer must take an AnimationModelBase as its model. This model\u2019s constructor takes two parameters, the location of the actual model to animate (as in the path to the JSON or B3D file, not a blockstate reference) and a VertexLighter . The VertexLighter object can be created with new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors()) . The entity must also provide the ANIMATION_CAPABILITY , which can be created with its .cast method by passing the ASM. The handleEvents() callback is located inside the AnimationModelBase class, if you want to use the events you must subclass AnimationModelBase . The callback takes three parameters: the entity being rendered, the current time in partial ticks, and an iterable of the events that have occurred. An example of creating the renderer is shown below: ResourceLocation location = new ModelResourceLocation(new ResourceLocation(MODID, blockName), \"entity\"); return new RenderLiving<EntityChest>(manager, new net.minecraftforge.client.model.animation.AnimationModelBase<EntityChest>(location, new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors())) { @Override public void handleEvents(EntityChest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }, 0.5f) { // ... getEntityTexture() ... };","title":"Entities"},{"location":"animation/intro/","text":"Intro to the Animation API The Forge Animation API lets you animate JSON (and B3D) models. Before you start reading this, you should know how vanilla JSON models are created, and should have read the documentation on blockstates. Note Although you can use B3D models with the Animation API, most of this documentation will assume you are using JSON files. (TODO) See the page on using B3D models for more information The Animation API is made up of two main components: armature files and animation state machine (ASM) files. Armature files define joints and clips for JSON files. Joints are names for cubes in the model file with weights (see the page on armatures for more info), while clips are a set of transformations to apply to joints over time (think of a clip from a movie for example). ASM files define the various states an animation can be in, as well as what transitions exist between those states. They also define the parameters for an animation (functions which return a floating point number), which are generally used as inputs to clips, but can also trigger events. Events are essentially a way to receive in-code notifications when the animation reaches a certain point or to trigger transitions. Filesystem Structure Conventions ASM Files are normally stored in the asms/block for blocks or asms/item for items and so on. You specify where to load them from, so their location is really up to you. Armature files must be stored in the armatures folder. They are looked up by taking the path to your model file, removing models/ and taking whats left and prepending armatures/ , so a model in models/block/test.json becomes armatures/block/test.json .","title":"Intro to the Animation API"},{"location":"animation/intro/#intro-to-the-animation-api","text":"The Forge Animation API lets you animate JSON (and B3D) models. Before you start reading this, you should know how vanilla JSON models are created, and should have read the documentation on blockstates. Note Although you can use B3D models with the Animation API, most of this documentation will assume you are using JSON files. (TODO) See the page on using B3D models for more information The Animation API is made up of two main components: armature files and animation state machine (ASM) files. Armature files define joints and clips for JSON files. Joints are names for cubes in the model file with weights (see the page on armatures for more info), while clips are a set of transformations to apply to joints over time (think of a clip from a movie for example). ASM files define the various states an animation can be in, as well as what transitions exist between those states. They also define the parameters for an animation (functions which return a floating point number), which are generally used as inputs to clips, but can also trigger events. Events are essentially a way to receive in-code notifications when the animation reaches a certain point or to trigger transitions.","title":"Intro to the Animation API"},{"location":"animation/intro/#filesystem-structure-conventions","text":"ASM Files are normally stored in the asms/block for blocks or asms/item for items and so on. You specify where to load them from, so their location is really up to you. Armature files must be stored in the armatures folder. They are looked up by taking the path to your model file, removing models/ and taking whats left and prepending armatures/ , so a model in models/block/test.json becomes armatures/block/test.json .","title":"Filesystem Structure Conventions"},{"location":"blocks/blocks/","text":"Blocks Blocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them. Creating a Block Basic Blocks For simple blocks, which need no special functionality (think cobblestone, wood planks, etc.), a custom class is not necessary. By simply instantiating the Block class and calling some of the many setters, one can create many different types of blocks. For instance: setHardness - Controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable, a convenience method setBlockUnbreakable is provided. setResistance - Controls the explosion resistance of the block. This is separate from hardness, but setHardness will also set the resistance to 5 times the hardness value, if the resistance is any lower than this value. setSoundType - Controls the sound the block makes when it is punched, broken, or placed. Requires a SoundType argument, see the sounds page for more details. setLightLevel - Controls the light emission of the block. Note: This method takes a value from zero to one, not zero to fifteen. To calculate this value, take the light level you wish your block to emit and divide by 16. For instance a block which emits level 5 light should pass 5 / 16f to this method. setLightOpacity - Controls the amount light passing through this block will be dimmed. Unlike setLightLevel this value is on a scale from zero to 15. For example, setting this to 3 will lower light by 3 levels every time it passes through this type of block. setUnlocalizedName - Mostly self explanatory, sets the unlocalized name of the block. This name will be prepended with \u201ctile.\u201d and appended with \u201c.name\u201d for localization purposes. For instance setUnlocalizedName(\"foo\") will cause the block\u2019s actual localization key to be \u201ctile.foo.name\u201d. For more advanced localization control, a custom Item will be needed. We\u2019ll get into this more later. setCreativeTab - Controls which creative tab this block will fall under. This must be called if the block should be shown in the creative menu. Tab options can be found in the CreativeTabs class. All these methods are chainable which means you can call them in series. See Block#registerBlocks for examples of this. Advanced Blocks Of course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the Block class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks. Registering a Block Blocks must be registered to function. Important A block in the world and a \u201cblock\u201d in an inventory are very different things. A block in the world is represented by an IBlockState , and its behavior defined by an instance of Block . Meanwhile, an item in an inventory is an ItemStack , controlled by an Item . As a bridge between the different worlds of Block and Item , there exists the class ItemBlock . ItemBlock is a subclass of Item that has a field block that holds a reference to the Block it represents. ItemBlock defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a Block without an ItemBlock . (E.g. minecraft:water exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.) When a block is registered, only a block is registered. The block does not automatically have an ItemBlock . To create a basic ItemBlock for a block, one should use new ItemBlock(block).setRegistryName(block.getRegistryName()) . The unlocalized name is the same as the block\u2019s. Custom subclasses of ItemBlock may be used as well. Once an ItemBlock has been registered for a block, Item.getItemFromBlock can be used to retrieve it. Item.getItemFromBlock will return null if there is no ItemBlock for the Block , so if you are not certain that there is an ItemBlock for the Block you are using, check for null . Further Reading For information about block properties, such as those used for vanilla blocks like wood types, fences, walls, and many more, see the section on blockstates .","title":"Home"},{"location":"blocks/blocks/#blocks","text":"Blocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them.","title":"Blocks"},{"location":"blocks/blocks/#creating-a-block","text":"","title":"Creating a Block"},{"location":"blocks/blocks/#basic-blocks","text":"For simple blocks, which need no special functionality (think cobblestone, wood planks, etc.), a custom class is not necessary. By simply instantiating the Block class and calling some of the many setters, one can create many different types of blocks. For instance: setHardness - Controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable, a convenience method setBlockUnbreakable is provided. setResistance - Controls the explosion resistance of the block. This is separate from hardness, but setHardness will also set the resistance to 5 times the hardness value, if the resistance is any lower than this value. setSoundType - Controls the sound the block makes when it is punched, broken, or placed. Requires a SoundType argument, see the sounds page for more details. setLightLevel - Controls the light emission of the block. Note: This method takes a value from zero to one, not zero to fifteen. To calculate this value, take the light level you wish your block to emit and divide by 16. For instance a block which emits level 5 light should pass 5 / 16f to this method. setLightOpacity - Controls the amount light passing through this block will be dimmed. Unlike setLightLevel this value is on a scale from zero to 15. For example, setting this to 3 will lower light by 3 levels every time it passes through this type of block. setUnlocalizedName - Mostly self explanatory, sets the unlocalized name of the block. This name will be prepended with \u201ctile.\u201d and appended with \u201c.name\u201d for localization purposes. For instance setUnlocalizedName(\"foo\") will cause the block\u2019s actual localization key to be \u201ctile.foo.name\u201d. For more advanced localization control, a custom Item will be needed. We\u2019ll get into this more later. setCreativeTab - Controls which creative tab this block will fall under. This must be called if the block should be shown in the creative menu. Tab options can be found in the CreativeTabs class. All these methods are chainable which means you can call them in series. See Block#registerBlocks for examples of this.","title":"Basic Blocks"},{"location":"blocks/blocks/#advanced-blocks","text":"Of course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the Block class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks.","title":"Advanced Blocks"},{"location":"blocks/blocks/#registering-a-block","text":"Blocks must be registered to function. Important A block in the world and a \u201cblock\u201d in an inventory are very different things. A block in the world is represented by an IBlockState , and its behavior defined by an instance of Block . Meanwhile, an item in an inventory is an ItemStack , controlled by an Item . As a bridge between the different worlds of Block and Item , there exists the class ItemBlock . ItemBlock is a subclass of Item that has a field block that holds a reference to the Block it represents. ItemBlock defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a Block without an ItemBlock . (E.g. minecraft:water exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.) When a block is registered, only a block is registered. The block does not automatically have an ItemBlock . To create a basic ItemBlock for a block, one should use new ItemBlock(block).setRegistryName(block.getRegistryName()) . The unlocalized name is the same as the block\u2019s. Custom subclasses of ItemBlock may be used as well. Once an ItemBlock has been registered for a block, Item.getItemFromBlock can be used to retrieve it. Item.getItemFromBlock will return null if there is no ItemBlock for the Block , so if you are not certain that there is an ItemBlock for the Block you are using, check for null .","title":"Registering a Block"},{"location":"blocks/blocks/#further-reading","text":"For information about block properties, such as those used for vanilla blocks like wood types, fences, walls, and many more, see the section on blockstates .","title":"Further Reading"},{"location":"blocks/interaction/","text":"Block Interaction There are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining. This page will cover the basics of the most common types of interaction with blocks. Player Right Click Since left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is the most common method of interaction. And thankfully, it is also one of the simplest to handle. onBlockActivated This is the method that controls right click behavior, and it is a rather complicated one. Here is its full signature: public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, @Nullable ItemStack heldItem, EnumFacing side, float hitX, float hitY, float hitZ) There\u2019s quite a bit to discuss here. Parameters The first few parameters are obvious, they are the current world, position, and state of the block. Next is the player that is activating the block, and the hand with which they are activating. The next parameter, heldItem , is the ItemStack which the player activated the block with. Note that this parameter is @Nullable meaning it can be passed as null (i.e. no item was in the hand). Important The ItemStack passed to this method is the one you should use for checking what was in the player\u2019s hand. Grabbing the currently held stack from the player is unreliable as it may have changed since activation. The last four parameters are all related. side is obviously the side which was activated, however hitX , hitY , and hitZ are a bit less obvious. These are the coordinates of the activation on the block\u2019s bounds. They are on the range 0 to 1, and represent where exactly \u201con\u201d the block the player clicked. Return Value What is this magic boolean which must be returned? Simply put this, is whether or not the method \u201cdid\u201d something. Return true if some action was performed, this will prevent further things from happening, such as item activation. Important Returning false from this method on the client will prevent it being called on the server. It is common practice to just check worldIn.isRemote and return true , and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest. Uses The uses for activation are literally endless. However, there are some common ones which deserve their own section. GUIs One of the most common things to do on block activation is opening a GUI. Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more. More about GUIs can be found on their page . Activation Another common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers. Important onBlockActivated is called on both the client and the server, so be sure to keep the sidedness of your code in mind. Many things, like opening GUIs and modifying the world, should only be done on the server-side. Player Break/Destroy Coming Soon Player Highlighting Coming Soon Entity Collision Coming Soon onBlockClicked public void onBlockClicked(World worldIn, BlockPos pos, EntityPlayer playerIn) Called on a block when it is clicked by a player. Note This method is for when the player left-clicks on a block. Don\u2019t get this confused with onBlockActivated , which is called when the player right-clicks . Parameters: Type Name Description World worldIn The world that the block was clicked in BlockPos pos The position of the block that was clicked EntityPlayer playerIn The player who did the clicking Usage example This method is perfect for adding custom events when a player clicks on a block. By default this method does nothing. Two blocks that override this method are the Note Block and the RedstoneOre Block . The Note block overrides this method so that when left-clicked, it plays a sound. The RedstoneOre block overrides method so that when left-clicked, it gives off emits faint light for a few seconds. onBlockDestroyedByPlayer public void onBlockDestroyedByPlayer(World worldIn, BlockPos pos, IBlockState state) Called on a block after it\u2019s destroyed by a player Parameters: Type Name Description World worldIn The world that the block was destroyed BlockPos pos The position of the block that was destroyed IBlockState state The state of the block that was destroyed Warning The pos parameter may not hold the state indicated Usage example This method is perfect for adding custom events as a result of a player destroying a block By default this method does nothing. The TNT Block overrides this method to cause it\u2019s explosion when a player destroys it. This method is used by extended pistons; since an extended piston is made up of two blocks (the extended head and the base), the PistonMoving Block makes use of this method to destroy the base block when the PistonMoving block is destroyed.","title":"Interaction"},{"location":"blocks/interaction/#block-interaction","text":"There are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining. This page will cover the basics of the most common types of interaction with blocks.","title":"Block Interaction"},{"location":"blocks/interaction/#player-right-click","text":"Since left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is the most common method of interaction. And thankfully, it is also one of the simplest to handle.","title":"Player Right Click"},{"location":"blocks/interaction/#onblockactivated","text":"This is the method that controls right click behavior, and it is a rather complicated one. Here is its full signature: public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, @Nullable ItemStack heldItem, EnumFacing side, float hitX, float hitY, float hitZ) There\u2019s quite a bit to discuss here.","title":"onBlockActivated"},{"location":"blocks/interaction/#parameters","text":"The first few parameters are obvious, they are the current world, position, and state of the block. Next is the player that is activating the block, and the hand with which they are activating. The next parameter, heldItem , is the ItemStack which the player activated the block with. Note that this parameter is @Nullable meaning it can be passed as null (i.e. no item was in the hand). Important The ItemStack passed to this method is the one you should use for checking what was in the player\u2019s hand. Grabbing the currently held stack from the player is unreliable as it may have changed since activation. The last four parameters are all related. side is obviously the side which was activated, however hitX , hitY , and hitZ are a bit less obvious. These are the coordinates of the activation on the block\u2019s bounds. They are on the range 0 to 1, and represent where exactly \u201con\u201d the block the player clicked.","title":"Parameters"},{"location":"blocks/interaction/#return-value","text":"What is this magic boolean which must be returned? Simply put this, is whether or not the method \u201cdid\u201d something. Return true if some action was performed, this will prevent further things from happening, such as item activation. Important Returning false from this method on the client will prevent it being called on the server. It is common practice to just check worldIn.isRemote and return true , and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest.","title":"Return Value"},{"location":"blocks/interaction/#uses","text":"The uses for activation are literally endless. However, there are some common ones which deserve their own section.","title":"Uses"},{"location":"blocks/interaction/#guis","text":"One of the most common things to do on block activation is opening a GUI. Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more. More about GUIs can be found on their page .","title":"GUIs"},{"location":"blocks/interaction/#activation","text":"Another common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers. Important onBlockActivated is called on both the client and the server, so be sure to keep the sidedness of your code in mind. Many things, like opening GUIs and modifying the world, should only be done on the server-side.","title":"Activation"},{"location":"blocks/interaction/#player-breakdestroy","text":"Coming Soon","title":"Player Break/Destroy"},{"location":"blocks/interaction/#player-highlighting","text":"Coming Soon","title":"Player Highlighting"},{"location":"blocks/interaction/#entity-collision","text":"Coming Soon","title":"Entity Collision"},{"location":"blocks/interaction/#onblockclicked","text":"public void onBlockClicked(World worldIn, BlockPos pos, EntityPlayer playerIn) Called on a block when it is clicked by a player. Note This method is for when the player left-clicks on a block. Don\u2019t get this confused with onBlockActivated , which is called when the player right-clicks .","title":"onBlockClicked"},{"location":"blocks/interaction/#parameters_1","text":"Type Name Description World worldIn The world that the block was clicked in BlockPos pos The position of the block that was clicked EntityPlayer playerIn The player who did the clicking","title":"Parameters:"},{"location":"blocks/interaction/#usage-example","text":"This method is perfect for adding custom events when a player clicks on a block. By default this method does nothing. Two blocks that override this method are the Note Block and the RedstoneOre Block . The Note block overrides this method so that when left-clicked, it plays a sound. The RedstoneOre block overrides method so that when left-clicked, it gives off emits faint light for a few seconds.","title":"Usage example"},{"location":"blocks/interaction/#onblockdestroyedbyplayer","text":"public void onBlockDestroyedByPlayer(World worldIn, BlockPos pos, IBlockState state) Called on a block after it\u2019s destroyed by a player","title":"onBlockDestroyedByPlayer"},{"location":"blocks/interaction/#parameters_2","text":"Type Name Description World worldIn The world that the block was destroyed BlockPos pos The position of the block that was destroyed IBlockState state The state of the block that was destroyed Warning The pos parameter may not hold the state indicated","title":"Parameters:"},{"location":"blocks/interaction/#usage-example_1","text":"This method is perfect for adding custom events as a result of a player destroying a block By default this method does nothing. The TNT Block overrides this method to cause it\u2019s explosion when a player destroys it. This method is used by extended pistons; since an extended piston is made up of two blocks (the extended head and the base), the PistonMoving Block makes use of this method to destroy the base block when the PistonMoving block is destroyed.","title":"Usage example"},{"location":"blocks/states/","text":"Block States Please read all of this guide before starting to code. Your understanding will be more comprehensive and correct than if you just picked parts out. This guide is designed for an entry level introduction to Block States. If you know what Extended States are, you\u2019ll notice some simplifying assumptions I\u2019ve made below. They are intentional and are meant to avoid overloading beginners with information they may not immediately need. If you don\u2019t know what they are, no need to fear, there will be another document for them eventually. Motivation In Minecraft 1.8 and above, direct manipulation of blocks and metadata values have been abstracted away into what is known as blockstates. The premise of the system is to remove the usage and manipulation of raw metadata numbers, which are nondescript and carry no meaning. For example, consider this switch statement for some arbitrary block that can face a direction and be on either half of the block space: switch(meta) { case 0: // it's south and on the lower half of the block case 1: // it's south on the upper side of the block case 2: // it's north and on the lower half of the block case 3: // it's north and on the upper half of the block ... etc. } The numbers themselves carry no meaning whatsoever! If the comments weren\u2019t there we would have no idea what the meaning of each number is. A New Way of Thinking How about, instead of having to munge around with numbers everywhere, we instead use some system that abstracts out the details of saving from the semantics of the block itself? This is where IProperty<?> comes in. Each Block has a set of zero or more of these objects, that describe, unsurprisingly, properties that the block have. Examples of this include color ( IProperty<EnumDyeColor> ), facing ( IProperty<EnumFacing> ), integer and boolean values, etc. Each property can have a value of the type parametrized by IProperty . For example, for the respective example properties, we can have values EnumDyeColor.WHITE , EnumFacing.EAST , 1 , or false . Then, following from this, we see that every unique triple (Block, set of properties, set of values for those properties) is a suitable abstracted replacement for Block and metadata. Now, instead of \u201cminecraft:stone_button meta 9\u201d we have \u201cminecraft:stone_button[facing=east,powered=true]\u201d. Guess which is more meaningful? We have a very special name for these triples - they\u2019re called IBlockState \u2018s. Imbuing your Blocks with these Magical Properties Now that I\u2019ve successfully convinced you that properties and values are superior to arbitrary numbers, let\u2019s move on to the actual how-to-do part. In your Block class, create static final IProperty<> objects for every property that your Block has. Vanilla provides us several convenience implementations: PropertyInteger : Implements IProperty<Integer> . Created by calling PropertyInteger.create(\u201c \u201c, , ); PropertyBool : Implements IProperty<Boolean> . Created by calling PropertyBool.create(\u201c \u201c); PropertyEnum<E extends Enum<E>> : Implements IProperty<E> , Defines a property that can take on the values of an Enum class. Created by calling PropertyEnum.create(\u201cname\u201d, ); You can also use only a subset of the Enum values (for example, you can use only 4 of the 16 EnumDyeColor \u2018s. Take a look at the other overloads of PropertyEnum.create ) PropertyDirection : This is a convenience implementation of PropertyEnum<EnumFacing> Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, you would call PropertyDirection.create(\"<name>\", EnumFacing.Plane.HORIZONTAL) . Or to get the X directions, PropertyDirection.create(\"<name>\", EnumFacing.Axis.X) Note that you are free to make your own IProperty<> implementations, but the means to do that are not covered in this article. In addition, note that you can share the same IProperty object between different blocks if you wish. Vanilla generally has separate ones for every single block, but it is merely personal preference. Note If your mod has an API or is meant to be interacted with from other mods, it is very highly recommended that you instead place your IProperty \u2018s (and any classes used as values) in your API. That way, people can use properties and values to set your blocks in the world instead of having to suffer with arbitrary numbers like you used to. After you\u2019ve created your IProperty<> objects, override createBlockState in your Block class. In that method, simply write return new BlockState() . Pass the BlockState constructor first your Block, this , then follow it with every IProperty you want to declare. Note that in 1.9 and above, the BlockState class has been renamed to BlockStateContainer , more in line with what this class actually does. The object you just created is a pretty magical one - it manages the generation of all the triples above. That is, it generates all possible combinations of every value for each property (for math-oriented people, it takes the set of possible values of each property and computes the cartesian product of those sets). Thus, it generates every unique (Block, properties, values) possible - every IBlockState possible for the given properties. If you do not set one of these IBlockState \u2018s to act as the \u201cdefault\u201d state for your Block, then one is chosen for you. You probably don\u2019t want this (it will cause weird things to happen most of the time), so at the end of your Block\u2019s constructor call setDefaultState() , passing in the IBlockState you want to be the default. Get the one that was chosen for you using this.blockState.getBaseState() then set a value for every property using withProperty Because IBlockState \u2018s are immutable and pregenerated, calling IBlockState.withProperty(<PROPERTY>, <NEW_VALUE>) will simply go to the BlockState / BlockStateContainer and request the IBlockState with the set of values you want, instead of constructing a new IBlockState . It follows very easily from this that since basic IBlockState \u2018s are generated into a fixed set at startup, you are able and encouraged to use reference comparison (==) to check if they are equal! Using IBlockState \u2018s IBlockState , as we know now, is a powerful object. You can get the value of a property by calling getValue(<PROPERTY>) , passing it the IProperty<> you want to test. If you want to get an IBlockState with a different set of values, simply call withProperty(<PROPERTY>, <NEW_VALUE>) as mentioned above. This will return another of the pregenerated IBlockState \u2018s with the values you requested. You can get and put IBlockState \u2018s in the world using setBlockState() and getBlockState() . Illusion Breaker Sadly, abstractions are lies at their core. We still have the responsibility of translating every IBlockState back into a number between 0 and 15 inclusive that will be stored in the world and vice versa for loading. If you declare any IProperty \u2018s, you must override getMetaFromState and getStateFromMeta Here you will read the values of your properties and return an appropriate integer between 0 and 15, or the other way around; the reader is left to check examples from vanilla blocks by themselves. Warning Your getMetaFromState and getStateFromMeta methods must be one to one! In other words, the same set of properties and values must map to the same meta value and back. Failing to do this, unfortunately, won\u2019t cause a crash. It\u2019ll just cause everything to behave extremely weirdly. \u201cActual\u201d States Some sharper minds might know that fences don\u2019t save any of their connections to meta, yet they still have properties and values in the F3 menu! What is this blasphemy?! Blocks can declare properties that are not saved to metadata. These are usually used for rendering purposes, but could possibly have other useful applications. You still declare them in createBlockState and set their value in setDefaultState . However, these properties you do not touch at all in getMetaFromState and getStateFromMeta . Instead, override getActualState in your Block class. Here you will receive the IBlockState corresponding with the metadata in the world, and you return another IBlockState with missing information such as fence connections, redstone connections , etc. filled in using withProperty . You can also use this to read Tile Entity data for a value (with appropriate safety checks of course!). Warning When you read tile entity data in getActualState you must perform additional safety checks. By default, getTileEntity attempts to create the tile entity if it is not already present. However, getActualState and getExtendedState can and will be called from different threads, which can cause the world\u2019s tile entity list to throw a ConcurrentModificationException if it tries to create a missing tile entity. Therefore, you must check if the IBlockAccess argument is a ChunkCache (the object passed to alternate threads), and if so, cast and use the non-writing variant of getTileEntity . An example of this safety check can be found in BlockFlowerPot.getActualState() . Note Querying world.getBlockState() will give you the IBlockState representing only the metadata. Thus the returned IBlockState will not have data from getActualState filled in. If that matters to your code, make sure you call getActualState ! Extended Blockstates Extended blockstates are a way to pass arbitrary data into IBakedModel s during the rendering of a block. They are mainly used in the context of rendering, and therefore are documented in the Models section.","title":"Intro to Blockstates"},{"location":"blocks/states/#block-states","text":"Please read all of this guide before starting to code. Your understanding will be more comprehensive and correct than if you just picked parts out. This guide is designed for an entry level introduction to Block States. If you know what Extended States are, you\u2019ll notice some simplifying assumptions I\u2019ve made below. They are intentional and are meant to avoid overloading beginners with information they may not immediately need. If you don\u2019t know what they are, no need to fear, there will be another document for them eventually.","title":"Block States"},{"location":"blocks/states/#motivation","text":"In Minecraft 1.8 and above, direct manipulation of blocks and metadata values have been abstracted away into what is known as blockstates. The premise of the system is to remove the usage and manipulation of raw metadata numbers, which are nondescript and carry no meaning. For example, consider this switch statement for some arbitrary block that can face a direction and be on either half of the block space: switch(meta) { case 0: // it's south and on the lower half of the block case 1: // it's south on the upper side of the block case 2: // it's north and on the lower half of the block case 3: // it's north and on the upper half of the block ... etc. } The numbers themselves carry no meaning whatsoever! If the comments weren\u2019t there we would have no idea what the meaning of each number is.","title":"Motivation"},{"location":"blocks/states/#a-new-way-of-thinking","text":"How about, instead of having to munge around with numbers everywhere, we instead use some system that abstracts out the details of saving from the semantics of the block itself? This is where IProperty<?> comes in. Each Block has a set of zero or more of these objects, that describe, unsurprisingly, properties that the block have. Examples of this include color ( IProperty<EnumDyeColor> ), facing ( IProperty<EnumFacing> ), integer and boolean values, etc. Each property can have a value of the type parametrized by IProperty . For example, for the respective example properties, we can have values EnumDyeColor.WHITE , EnumFacing.EAST , 1 , or false . Then, following from this, we see that every unique triple (Block, set of properties, set of values for those properties) is a suitable abstracted replacement for Block and metadata. Now, instead of \u201cminecraft:stone_button meta 9\u201d we have \u201cminecraft:stone_button[facing=east,powered=true]\u201d. Guess which is more meaningful? We have a very special name for these triples - they\u2019re called IBlockState \u2018s.","title":"A New Way of Thinking"},{"location":"blocks/states/#imbuing-your-blocks-with-these-magical-properties","text":"Now that I\u2019ve successfully convinced you that properties and values are superior to arbitrary numbers, let\u2019s move on to the actual how-to-do part. In your Block class, create static final IProperty<> objects for every property that your Block has. Vanilla provides us several convenience implementations: PropertyInteger : Implements IProperty<Integer> . Created by calling PropertyInteger.create(\u201c \u201c, , ); PropertyBool : Implements IProperty<Boolean> . Created by calling PropertyBool.create(\u201c \u201c); PropertyEnum<E extends Enum<E>> : Implements IProperty<E> , Defines a property that can take on the values of an Enum class. Created by calling PropertyEnum.create(\u201cname\u201d, ); You can also use only a subset of the Enum values (for example, you can use only 4 of the 16 EnumDyeColor \u2018s. Take a look at the other overloads of PropertyEnum.create ) PropertyDirection : This is a convenience implementation of PropertyEnum<EnumFacing> Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, you would call PropertyDirection.create(\"<name>\", EnumFacing.Plane.HORIZONTAL) . Or to get the X directions, PropertyDirection.create(\"<name>\", EnumFacing.Axis.X) Note that you are free to make your own IProperty<> implementations, but the means to do that are not covered in this article. In addition, note that you can share the same IProperty object between different blocks if you wish. Vanilla generally has separate ones for every single block, but it is merely personal preference. Note If your mod has an API or is meant to be interacted with from other mods, it is very highly recommended that you instead place your IProperty \u2018s (and any classes used as values) in your API. That way, people can use properties and values to set your blocks in the world instead of having to suffer with arbitrary numbers like you used to. After you\u2019ve created your IProperty<> objects, override createBlockState in your Block class. In that method, simply write return new BlockState() . Pass the BlockState constructor first your Block, this , then follow it with every IProperty you want to declare. Note that in 1.9 and above, the BlockState class has been renamed to BlockStateContainer , more in line with what this class actually does. The object you just created is a pretty magical one - it manages the generation of all the triples above. That is, it generates all possible combinations of every value for each property (for math-oriented people, it takes the set of possible values of each property and computes the cartesian product of those sets). Thus, it generates every unique (Block, properties, values) possible - every IBlockState possible for the given properties. If you do not set one of these IBlockState \u2018s to act as the \u201cdefault\u201d state for your Block, then one is chosen for you. You probably don\u2019t want this (it will cause weird things to happen most of the time), so at the end of your Block\u2019s constructor call setDefaultState() , passing in the IBlockState you want to be the default. Get the one that was chosen for you using this.blockState.getBaseState() then set a value for every property using withProperty Because IBlockState \u2018s are immutable and pregenerated, calling IBlockState.withProperty(<PROPERTY>, <NEW_VALUE>) will simply go to the BlockState / BlockStateContainer and request the IBlockState with the set of values you want, instead of constructing a new IBlockState . It follows very easily from this that since basic IBlockState \u2018s are generated into a fixed set at startup, you are able and encouraged to use reference comparison (==) to check if they are equal!","title":"Imbuing your Blocks with these Magical Properties"},{"location":"blocks/states/#using-iblockstates","text":"IBlockState , as we know now, is a powerful object. You can get the value of a property by calling getValue(<PROPERTY>) , passing it the IProperty<> you want to test. If you want to get an IBlockState with a different set of values, simply call withProperty(<PROPERTY>, <NEW_VALUE>) as mentioned above. This will return another of the pregenerated IBlockState \u2018s with the values you requested. You can get and put IBlockState \u2018s in the world using setBlockState() and getBlockState() .","title":"Using IBlockState's"},{"location":"blocks/states/#illusion-breaker","text":"Sadly, abstractions are lies at their core. We still have the responsibility of translating every IBlockState back into a number between 0 and 15 inclusive that will be stored in the world and vice versa for loading. If you declare any IProperty \u2018s, you must override getMetaFromState and getStateFromMeta Here you will read the values of your properties and return an appropriate integer between 0 and 15, or the other way around; the reader is left to check examples from vanilla blocks by themselves. Warning Your getMetaFromState and getStateFromMeta methods must be one to one! In other words, the same set of properties and values must map to the same meta value and back. Failing to do this, unfortunately, won\u2019t cause a crash. It\u2019ll just cause everything to behave extremely weirdly.","title":"Illusion Breaker"},{"location":"blocks/states/#actual-states","text":"Some sharper minds might know that fences don\u2019t save any of their connections to meta, yet they still have properties and values in the F3 menu! What is this blasphemy?! Blocks can declare properties that are not saved to metadata. These are usually used for rendering purposes, but could possibly have other useful applications. You still declare them in createBlockState and set their value in setDefaultState . However, these properties you do not touch at all in getMetaFromState and getStateFromMeta . Instead, override getActualState in your Block class. Here you will receive the IBlockState corresponding with the metadata in the world, and you return another IBlockState with missing information such as fence connections, redstone connections , etc. filled in using withProperty . You can also use this to read Tile Entity data for a value (with appropriate safety checks of course!). Warning When you read tile entity data in getActualState you must perform additional safety checks. By default, getTileEntity attempts to create the tile entity if it is not already present. However, getActualState and getExtendedState can and will be called from different threads, which can cause the world\u2019s tile entity list to throw a ConcurrentModificationException if it tries to create a missing tile entity. Therefore, you must check if the IBlockAccess argument is a ChunkCache (the object passed to alternate threads), and if so, cast and use the non-writing variant of getTileEntity . An example of this safety check can be found in BlockFlowerPot.getActualState() . Note Querying world.getBlockState() will give you the IBlockState representing only the metadata. Thus the returned IBlockState will not have data from getActualState filled in. If that matters to your code, make sure you call getActualState !","title":"\"Actual\" States"},{"location":"blocks/states/#extended-blockstates","text":"Extended blockstates are a way to pass arbitrary data into IBakedModel s during the rendering of a block. They are mainly used in the context of rendering, and therefore are documented in the Models section.","title":"Extended Blockstates"},{"location":"concepts/internationalization/","text":"Internationalization and localization Internationalization, i18n for short, is a way of designing code so that it requires no changes to be adapted for various languages. Localization is the process of adapting displayed text to the user\u2019s language. I18n is implemented using translation keys . A translation key is a string that identifies a piece of displayable text in no specific language. For example, block.minecraft.dirt is the translation key referring to the name of the Dirt block. This way, displayable text may be referenced with no concern for a specific language. The code requires no changes to be adapted in a new language. Localization will happen in the game\u2019s locale. In a Minecraft client the locale is specified by the language settings. On a dedicated server, the only supported locale is en_US. A list of available locales can be found on the Minecraft Wiki . Language files Language files are located by assets/[namespace]/lang/[locale].json (e.g. the US English translation for examplemod would be assets/examplemod/lang/en_us.json ). The file format is simply a json map from translation keys to values. The file must be encoded in UTF-8. Old .lang files can be converted to json using a converter . { \"item.examplemod.example_item\": \"Example Item Name\", \"block.examplemod.example_block\": \"Example Block Name\", \"commands.examplemod.examplecommand.error\": \"examplecommand errored!\" } Usage with Blocks and Items Block, Item and a few other Minecraft classes have built-in translation keys used to display their names. These translation keys are specified by overriding getTranslationKey() . Item also has getTranslationKey(ItemStack) which can be overridden to provide different translation keys depending on ItemStack NBT. By default, getTranslationKey() will return block. or item. prepended to the registry name of the block or item, with the colon replaced by a dot. ItemBlock s will take their corresponding Block \u2018s translation key by default. For example, an item with ID examplemode:example_item effectively requires the following line in a language file: { \"item.examplemod.example_item\": \"Example Item Name\" } Note The only purpose of a translation key is internationalization. Do not use them for logic. Use registry names instead. Localization methods Warning A common issue is having the server localize for clients. The server can only localize in its own locale, which does not necessarily match the locale of connected clients. To respect the language settings of clients, the server should have clients localize text in their own locale using TextComponentTranslation or other methods preserving the language neutral translation keys. net.minecraft.client.resources.I18n (client only) This I18n class can only be found on a Minecraft client! It is intended to be used by code that only runs on the client. Attempts to use this on a server will throw exceptions and crash. format(String, Object...) localizes in the client\u2019s locale with formatting. The first parameter is a translation key, and the rest are formatting arguments for String.format(String, Object...) . TextComponentTranslation TextComponentTranslation is an ITextComponent that is localized and formatted lazily. It is very useful when sending messages to players because it will be automatically localized in their own locale. The first parameter of the TextComponentTranslation(String, Object...) constructor is a translation key, and the rest are used for formatting. The only supported format specifiers are %s and %1$s , %2$s , %3$s etc. Formatting arguments may be other ITextComponent s that will be inserted into the resulting formatted text with all their attributes preserved. TextComponentHelper createComponentTranslation(ICommandSender, String, Object...) creates a localized and formatted ITextComponent depending on a receiver. The localization and formatting is done eagerly if the receiver is a vanilla client. If not, the localization and formatting is done lazily with a TextComponentTranslation . This is only useful if the server should allow vanilla clients to connect.","title":"Internationalization and localization"},{"location":"concepts/internationalization/#internationalization-and-localization","text":"Internationalization, i18n for short, is a way of designing code so that it requires no changes to be adapted for various languages. Localization is the process of adapting displayed text to the user\u2019s language. I18n is implemented using translation keys . A translation key is a string that identifies a piece of displayable text in no specific language. For example, block.minecraft.dirt is the translation key referring to the name of the Dirt block. This way, displayable text may be referenced with no concern for a specific language. The code requires no changes to be adapted in a new language. Localization will happen in the game\u2019s locale. In a Minecraft client the locale is specified by the language settings. On a dedicated server, the only supported locale is en_US. A list of available locales can be found on the Minecraft Wiki .","title":"Internationalization and localization"},{"location":"concepts/internationalization/#language-files","text":"Language files are located by assets/[namespace]/lang/[locale].json (e.g. the US English translation for examplemod would be assets/examplemod/lang/en_us.json ). The file format is simply a json map from translation keys to values. The file must be encoded in UTF-8. Old .lang files can be converted to json using a converter . { \"item.examplemod.example_item\": \"Example Item Name\", \"block.examplemod.example_block\": \"Example Block Name\", \"commands.examplemod.examplecommand.error\": \"examplecommand errored!\" }","title":"Language files"},{"location":"concepts/internationalization/#usage-with-blocks-and-items","text":"Block, Item and a few other Minecraft classes have built-in translation keys used to display their names. These translation keys are specified by overriding getTranslationKey() . Item also has getTranslationKey(ItemStack) which can be overridden to provide different translation keys depending on ItemStack NBT. By default, getTranslationKey() will return block. or item. prepended to the registry name of the block or item, with the colon replaced by a dot. ItemBlock s will take their corresponding Block \u2018s translation key by default. For example, an item with ID examplemode:example_item effectively requires the following line in a language file: { \"item.examplemod.example_item\": \"Example Item Name\" } Note The only purpose of a translation key is internationalization. Do not use them for logic. Use registry names instead.","title":"Usage with Blocks and Items"},{"location":"concepts/internationalization/#localization-methods","text":"Warning A common issue is having the server localize for clients. The server can only localize in its own locale, which does not necessarily match the locale of connected clients. To respect the language settings of clients, the server should have clients localize text in their own locale using TextComponentTranslation or other methods preserving the language neutral translation keys.","title":"Localization methods"},{"location":"concepts/internationalization/#netminecraftclientresourcesi18n-client-only","text":"This I18n class can only be found on a Minecraft client! It is intended to be used by code that only runs on the client. Attempts to use this on a server will throw exceptions and crash. format(String, Object...) localizes in the client\u2019s locale with formatting. The first parameter is a translation key, and the rest are formatting arguments for String.format(String, Object...) .","title":"net.minecraft.client.resources.I18n (client only)"},{"location":"concepts/internationalization/#textcomponenttranslation","text":"TextComponentTranslation is an ITextComponent that is localized and formatted lazily. It is very useful when sending messages to players because it will be automatically localized in their own locale. The first parameter of the TextComponentTranslation(String, Object...) constructor is a translation key, and the rest are used for formatting. The only supported format specifiers are %s and %1$s , %2$s , %3$s etc. Formatting arguments may be other ITextComponent s that will be inserted into the resulting formatted text with all their attributes preserved.","title":"TextComponentTranslation"},{"location":"concepts/internationalization/#textcomponenthelper","text":"createComponentTranslation(ICommandSender, String, Object...) creates a localized and formatted ITextComponent depending on a receiver. The localization and formatting is done eagerly if the receiver is a vanilla client. If not, the localization and formatting is done lazily with a TextComponentTranslation . This is only useful if the server should allow vanilla clients to connect.","title":"TextComponentHelper"},{"location":"concepts/jarsigning/","text":"Signing a JAR Java allows developers to sign their jar files with a signature. However, these signatures are not designed to be used as security and shouldn\u2019t be used this way. Signatures are used as sanity checks, so that developers are able to check if they are running their own un-edited code. Note Once again keep in mind that this system is not intended to be a security measure. With enough malicious intend it can be circumvented. Creating a keystore A keystore is a private database file which holds the required information to successfully sign the jar. To sign a jar, you need both a public and a private key. The public key will be later used to check if the jar is correctly signed. To generate a key, execute the following command and follow the instructions given by the keytool. The key should be SHA-1 encoded . keytool -genkey -alias signFiles -keystore examplestore.jks * The keytool is part of the Java Development Kit and can be found in the underlying bin directory. * The alias signFiles indicates that the alias should be used in future to refer to the keystore entry * -keystore examplestore.jks means that the keystore will be saved to the file examplestore.jks . Get the public key To gather the public key required by Forge, execute the following command: keytool -list -alias signFiles -keystore examplestore.jks Now copy the public key and remove all colons and change all uppercase letters to lowercase to ensure that FML can work with the key. Checking at runtime To allow FML to compare the keys, add the public key to the certificateFingerprint argument in the @Mod annotation. When FML detects that the keys don\u2019t match it will fire the mod-lifecycle event FMLFingerprintViolationEvent How to handle this key mismatch is up to the developer. event.isDirectory() - Returns true when the mod runs in development environment. event.getSource() - Returns the file with the key mismatch. event.getExpectedFingerprint() - Returns the public key. event.getFingerprints() - Returns all public keys found. Buildscript setup Finally, to let Gradle sign the jar file with the generated key pair, a new task in the buildscript build.gradle is required. task signJar(type: SignJar, dependsOn: reobfJar) { inputFile = jar.archivePath outputFile = jar.archivePath } build.dependsOn signJar dependsOn: reobfJar - This snippet of the line is important because Gradle has to sign the jar after ForgeGradle has reobfuscated the jar. jar.archivePath - The path where the archive (jar) is constructed. build.dependsOn signJar - This line tells Gradle that this task is part of the build task started by gradlew build . The following values for the signJar task must be defined to ensure that Gradle can find the keystore and actually sign the jar. This has to be done in the gradle.properties file. keyStore - This value tells Gradle where to search for the generated keystore. alias - The alias which was defined in the above is required in order for Gradle to sign the jar. storePass - The password which was defined by creating the keystore is required in order for Gradle to access the file. keyPass - The password of the key which was defined by creating the keystore is required in order for Gradle to gain access to it. This password may be the same as storePass, but can be different.","title":"The Fingerprint Violation Event"},{"location":"concepts/jarsigning/#signing-a-jar","text":"Java allows developers to sign their jar files with a signature. However, these signatures are not designed to be used as security and shouldn\u2019t be used this way. Signatures are used as sanity checks, so that developers are able to check if they are running their own un-edited code. Note Once again keep in mind that this system is not intended to be a security measure. With enough malicious intend it can be circumvented.","title":"Signing a JAR"},{"location":"concepts/jarsigning/#creating-a-keystore","text":"A keystore is a private database file which holds the required information to successfully sign the jar. To sign a jar, you need both a public and a private key. The public key will be later used to check if the jar is correctly signed. To generate a key, execute the following command and follow the instructions given by the keytool. The key should be SHA-1 encoded . keytool -genkey -alias signFiles -keystore examplestore.jks * The keytool is part of the Java Development Kit and can be found in the underlying bin directory. * The alias signFiles indicates that the alias should be used in future to refer to the keystore entry * -keystore examplestore.jks means that the keystore will be saved to the file examplestore.jks .","title":"Creating a keystore"},{"location":"concepts/jarsigning/#get-the-public-key","text":"To gather the public key required by Forge, execute the following command: keytool -list -alias signFiles -keystore examplestore.jks Now copy the public key and remove all colons and change all uppercase letters to lowercase to ensure that FML can work with the key.","title":"Get the public key"},{"location":"concepts/jarsigning/#checking-at-runtime","text":"To allow FML to compare the keys, add the public key to the certificateFingerprint argument in the @Mod annotation. When FML detects that the keys don\u2019t match it will fire the mod-lifecycle event FMLFingerprintViolationEvent How to handle this key mismatch is up to the developer. event.isDirectory() - Returns true when the mod runs in development environment. event.getSource() - Returns the file with the key mismatch. event.getExpectedFingerprint() - Returns the public key. event.getFingerprints() - Returns all public keys found.","title":"Checking at runtime"},{"location":"concepts/jarsigning/#buildscript-setup","text":"Finally, to let Gradle sign the jar file with the generated key pair, a new task in the buildscript build.gradle is required. task signJar(type: SignJar, dependsOn: reobfJar) { inputFile = jar.archivePath outputFile = jar.archivePath } build.dependsOn signJar dependsOn: reobfJar - This snippet of the line is important because Gradle has to sign the jar after ForgeGradle has reobfuscated the jar. jar.archivePath - The path where the archive (jar) is constructed. build.dependsOn signJar - This line tells Gradle that this task is part of the build task started by gradlew build . The following values for the signJar task must be defined to ensure that Gradle can find the keystore and actually sign the jar. This has to be done in the gradle.properties file. keyStore - This value tells Gradle where to search for the generated keystore. alias - The alias which was defined in the above is required in order for Gradle to sign the jar. storePass - The password which was defined by creating the keystore is required in order for Gradle to access the file. keyPass - The password of the key which was defined by creating the keystore is required in order for Gradle to gain access to it. This password may be the same as storePass, but can be different.","title":"Buildscript setup"},{"location":"concepts/registries/","text":"Registries Registration is the process of taking the objects of a mod (items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash). Some examples of things that need to be registered are Block s, Item s, Biome s. Most things that require registration in the game are handled by the Forge registries. A registry is a simple object similar to a map that assigns values to keys. Additionally, they automatically assign integer IDs to values. Forge uses registries with ResourceLocation keys to register objects. This allows the ResourceLocation to act like a \u201cregistry name\u201d for the object. The registry name for an object may be accessed with get / setRegistryName . The setter can only ever be called once, and calling it twice results in an exception. Every type of registrable object has its own registry, and names in two different registries will not collide. (E.g. there\u2019s a registry for Block s, and a registry for Item s, and a Block and an Item may be registered with the same name mod:example without colliding. However, if two blocks were registered with that name, an exception would be thrown.) Registering Things The recommended way to register things is through the RegistryEvent s. These events are fired right after preinitialization, In RegistryEvent.NewRegistry , registries should be created. Later, RegistryEvent.Register is fired once for each registered registry. Because Register is a generic event, the event handler should set the type parameter to the type of the object being registered. The event will contain the registry to register things to ( getRegistry ), and things may be registered with register (or registerAll ) on the registry. Here\u2019s an example of an event handler that registers blocks: @SubscribeEvent public void registerBlocks(RegistryEvent.Register<Block> event) { event.getRegistry().registerAll(block1, block2, ...); } The order in which RegistryEvent.Register events fire is alphabetically, with the exception that Block will always fire first, and Item will always fire second, right after Block . After the Register<Block> event has fired, all ObjectHolder annotations are refreshed, and after Register<Item> has fired they are refreshed again. They are refreshed for a third time after all of the other Register events have fired. RegistryEvent s are currently supported for the following types: Block , Item , Potion , Biome , SoundEvent , PotionType , Enchantment , IRecipe , VillagerProfession , EntityEntry There is another, older way of registering objects into registries, using GameRegistry.register . Anytime something suggests using this method, it should be replaced with an event handler for the appropriate registry event. This method simply finds the registry corresponding to an IForgeRegistryEntry with IForgeRegistryEntry::getRegistryType , and then registers the object to the registry. There is also a convenience overload that takes an IForgeRegistryEntry and a ResourceLocation , which is equivalent to calling IForgeRegistryEntry::setRegistryName , followed by a GameRegistry.register call. Information Registering an Entity might be a little bit confusing at first as it doesn\u2019t use the Entity class, but an EntityEntry . These are created by making use of EntityEntryBuilder . EntityEntryBuilder#id() is equivalent to the setRegistryName() method from IForgeRegistryEntry , with the difference that it also takes a mod internal int ID. A simple counter during registration is enough as this ID is only used for networking. Creating Registries There\u2019s a global registry where all the other registries are stored. By taking a Class that a registry is supposed to store or its ResourceLocation name, one can retrieve a registry from this registry. For example, one can use GameRegistry.findRegistry(Block.class) to get the registry for blocks. Any mod can create their own registries, and any mod can register things to registries from any other mod. Registries are created by using RegistryBuilder inside a RegistryEvent.NewRegistry event handler. This class takes certain parameters for the registry it will generate, such as the name, the Class of it\u2019s values, and various callbacks for when the registry is changed. Upon calling RegistryBuilder::create , the registry is built, registered to the metaregistry, and returned to the caller. In order for a class to have a registry, it needs to implement IForgeRegistryEntry . This interface defines getRegistryName(ResourceLocation) , setRegistryName(ResourceLocation) , and getRegistryType() . getRegistryType is the base Class of the registry the object is to be registered to. It is recommended to extend the default IForgeRegistryEntry.Impl class instead of implementing IForgeRegistryEntry directly. This class also provides two convenience implementations of setRegistryName : one where the parameter is a single string, and one where there are two string parameters. The overload that takes a single string checks whether the input contains a : (i.e. it checks whether the passed in stringified ResourceLocation has a namespace), and if it doesn\u2019t, it uses the current modid as the resource namespace. The two argument overload simply constructs the registry name using the modID as the namespace and name as the path. Injecting Registry Values Into Fields It is possible to have Forge inject values from registries into public static final fields of classes. This is done by annotating classes and fields with @ObjectHolder . If a class has this annotation, all the public static final fields within are taken to be object holders too, and the value of the annotation is the namespace of the holder (i.e. every field uses it as the default namespace for the registry name of the object to inject). If a field has this annotation, and the value does not contain a namespace, the namespace is chosen from the surrounding class\u2019s @ObjectHolder annotation. If the class is not annotated in this situation, the field is ignored with a warning. If it does contain a namespace, then the object to inject into the field is the object with that name. If the class has the annotation and one of the public static final fields does not, then the resource path of the object\u2019s name is taken to be the field\u2019s name. The type of the registry is taken from the type of the field. Note If an object is not found, either because the object itself hasn\u2019t been registered or because the registry does not exist, a debug message is logged and the field is left unchanged. As these rules are rather complicated, here are some examples: @ObjectHolder(\"minecraft\") // Resource namespace \"minecraft\" class AnnotatedHolder { public static final Block diamond_block = null; // public static final is required. // Type Block means that the Block registry will be queried. // diamond_block is the field name, and as the field is not annotated it is taken to be the resource path. // As there is no explicit namespace, \"minecraft\" is inherited from the class. // Object to be injected: \"minecraft:diamond_block\" from the Block registry. @ObjectHolder(\"ender_eye\") public static final Item eye_of_ender = null; // Type Item means that the Item registry will be queried. // As the annotation has the value \"ender_eye\", that overrides the field's name. // As the namespace is not explicit, \"minecraft\" is inherited from the class. // Object to be injected: \"minecraft:ender_eye\" from the Item registry. @ObjectHolder(\"neomagicae:coffeinum\") public static final ManaType coffeinum = null; // Type ManaType means that the ManaType registry will be queried. This is obviously a registry made by a mod. // As the annotation has the value \"neomagicae:coffeinum\", that overrides the field's name. // The namespace is explicit, and is \"neomagicae\", overriding the class's \"minecraft\" default. // Object to be injected: \"neomagicae:coffeinum\" from the ManaType registry. public static final Item ENDER_PEARL = null; // Note that the actual name is \"minecraft:ender_pearl\", not \"minecraft:ENDER_PEARL\". // However, since constructing a ResourceLocation lowercases the value, this will work. } class UnannotatedHolder { // Note lack of annotation on this class. @ObjectHolder(\"minecraft:flame\") public static final Enchantment flame = null; // No annotation on the class means that there is no preset namespace to inherit. // Field annotation supplies all the information for the object. // Object to be injected: \"minecraft:flame\" from the Enchantment registry. public static final Biome ice_flat = null; // No annotation on the class or the field. // Therefore this just gets ignored. @ObjectHolder(\"levitation\") public static final Potion levitation = null; // No resource namespace in annotation, and no default specified by class annotation. // Therefore, THIS WILL FAIL. The field annotation needs a namespace, or the class needs an annotation. }","title":"Registries"},{"location":"concepts/registries/#registries","text":"Registration is the process of taking the objects of a mod (items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects in a mod and will exhibit great amounts of unexplainable behavior (and probably crash). Some examples of things that need to be registered are Block s, Item s, Biome s. Most things that require registration in the game are handled by the Forge registries. A registry is a simple object similar to a map that assigns values to keys. Additionally, they automatically assign integer IDs to values. Forge uses registries with ResourceLocation keys to register objects. This allows the ResourceLocation to act like a \u201cregistry name\u201d for the object. The registry name for an object may be accessed with get / setRegistryName . The setter can only ever be called once, and calling it twice results in an exception. Every type of registrable object has its own registry, and names in two different registries will not collide. (E.g. there\u2019s a registry for Block s, and a registry for Item s, and a Block and an Item may be registered with the same name mod:example without colliding. However, if two blocks were registered with that name, an exception would be thrown.)","title":"Registries"},{"location":"concepts/registries/#registering-things","text":"The recommended way to register things is through the RegistryEvent s. These events are fired right after preinitialization, In RegistryEvent.NewRegistry , registries should be created. Later, RegistryEvent.Register is fired once for each registered registry. Because Register is a generic event, the event handler should set the type parameter to the type of the object being registered. The event will contain the registry to register things to ( getRegistry ), and things may be registered with register (or registerAll ) on the registry. Here\u2019s an example of an event handler that registers blocks: @SubscribeEvent public void registerBlocks(RegistryEvent.Register<Block> event) { event.getRegistry().registerAll(block1, block2, ...); } The order in which RegistryEvent.Register events fire is alphabetically, with the exception that Block will always fire first, and Item will always fire second, right after Block . After the Register<Block> event has fired, all ObjectHolder annotations are refreshed, and after Register<Item> has fired they are refreshed again. They are refreshed for a third time after all of the other Register events have fired. RegistryEvent s are currently supported for the following types: Block , Item , Potion , Biome , SoundEvent , PotionType , Enchantment , IRecipe , VillagerProfession , EntityEntry There is another, older way of registering objects into registries, using GameRegistry.register . Anytime something suggests using this method, it should be replaced with an event handler for the appropriate registry event. This method simply finds the registry corresponding to an IForgeRegistryEntry with IForgeRegistryEntry::getRegistryType , and then registers the object to the registry. There is also a convenience overload that takes an IForgeRegistryEntry and a ResourceLocation , which is equivalent to calling IForgeRegistryEntry::setRegistryName , followed by a GameRegistry.register call. Information Registering an Entity might be a little bit confusing at first as it doesn\u2019t use the Entity class, but an EntityEntry . These are created by making use of EntityEntryBuilder . EntityEntryBuilder#id() is equivalent to the setRegistryName() method from IForgeRegistryEntry , with the difference that it also takes a mod internal int ID. A simple counter during registration is enough as this ID is only used for networking.","title":"Registering Things"},{"location":"concepts/registries/#creating-registries","text":"There\u2019s a global registry where all the other registries are stored. By taking a Class that a registry is supposed to store or its ResourceLocation name, one can retrieve a registry from this registry. For example, one can use GameRegistry.findRegistry(Block.class) to get the registry for blocks. Any mod can create their own registries, and any mod can register things to registries from any other mod. Registries are created by using RegistryBuilder inside a RegistryEvent.NewRegistry event handler. This class takes certain parameters for the registry it will generate, such as the name, the Class of it\u2019s values, and various callbacks for when the registry is changed. Upon calling RegistryBuilder::create , the registry is built, registered to the metaregistry, and returned to the caller. In order for a class to have a registry, it needs to implement IForgeRegistryEntry . This interface defines getRegistryName(ResourceLocation) , setRegistryName(ResourceLocation) , and getRegistryType() . getRegistryType is the base Class of the registry the object is to be registered to. It is recommended to extend the default IForgeRegistryEntry.Impl class instead of implementing IForgeRegistryEntry directly. This class also provides two convenience implementations of setRegistryName : one where the parameter is a single string, and one where there are two string parameters. The overload that takes a single string checks whether the input contains a : (i.e. it checks whether the passed in stringified ResourceLocation has a namespace), and if it doesn\u2019t, it uses the current modid as the resource namespace. The two argument overload simply constructs the registry name using the modID as the namespace and name as the path.","title":"Creating Registries"},{"location":"concepts/registries/#injecting-registry-values-into-fields","text":"It is possible to have Forge inject values from registries into public static final fields of classes. This is done by annotating classes and fields with @ObjectHolder . If a class has this annotation, all the public static final fields within are taken to be object holders too, and the value of the annotation is the namespace of the holder (i.e. every field uses it as the default namespace for the registry name of the object to inject). If a field has this annotation, and the value does not contain a namespace, the namespace is chosen from the surrounding class\u2019s @ObjectHolder annotation. If the class is not annotated in this situation, the field is ignored with a warning. If it does contain a namespace, then the object to inject into the field is the object with that name. If the class has the annotation and one of the public static final fields does not, then the resource path of the object\u2019s name is taken to be the field\u2019s name. The type of the registry is taken from the type of the field. Note If an object is not found, either because the object itself hasn\u2019t been registered or because the registry does not exist, a debug message is logged and the field is left unchanged. As these rules are rather complicated, here are some examples: @ObjectHolder(\"minecraft\") // Resource namespace \"minecraft\" class AnnotatedHolder { public static final Block diamond_block = null; // public static final is required. // Type Block means that the Block registry will be queried. // diamond_block is the field name, and as the field is not annotated it is taken to be the resource path. // As there is no explicit namespace, \"minecraft\" is inherited from the class. // Object to be injected: \"minecraft:diamond_block\" from the Block registry. @ObjectHolder(\"ender_eye\") public static final Item eye_of_ender = null; // Type Item means that the Item registry will be queried. // As the annotation has the value \"ender_eye\", that overrides the field's name. // As the namespace is not explicit, \"minecraft\" is inherited from the class. // Object to be injected: \"minecraft:ender_eye\" from the Item registry. @ObjectHolder(\"neomagicae:coffeinum\") public static final ManaType coffeinum = null; // Type ManaType means that the ManaType registry will be queried. This is obviously a registry made by a mod. // As the annotation has the value \"neomagicae:coffeinum\", that overrides the field's name. // The namespace is explicit, and is \"neomagicae\", overriding the class's \"minecraft\" default. // Object to be injected: \"neomagicae:coffeinum\" from the ManaType registry. public static final Item ENDER_PEARL = null; // Note that the actual name is \"minecraft:ender_pearl\", not \"minecraft:ENDER_PEARL\". // However, since constructing a ResourceLocation lowercases the value, this will work. } class UnannotatedHolder { // Note lack of annotation on this class. @ObjectHolder(\"minecraft:flame\") public static final Enchantment flame = null; // No annotation on the class means that there is no preset namespace to inherit. // Field annotation supplies all the information for the object. // Object to be injected: \"minecraft:flame\" from the Enchantment registry. public static final Biome ice_flat = null; // No annotation on the class or the field. // Therefore this just gets ignored. @ObjectHolder(\"levitation\") public static final Potion levitation = null; // No resource namespace in annotation, and no default specified by class annotation. // Therefore, THIS WILL FAIL. The field annotation needs a namespace, or the class needs an annotation. }","title":"Injecting Registry Values Into Fields"},{"location":"concepts/resources/","text":"Resources A resource is extra data used by the game, and is stored in a data file, instead of being in the code. Minecraft has two primary resource systems active: one on the client used for visuals such as models, textures, and localization called assets , the other used for gameplay such as recipes and loot tables called data . Resource packs control the former, while data packs control the latter. In the default mod development kit, assets and data directories are located under the src/main/resources directory of the project. When multiple resource packs or data packs are enabled, they are merged. Generally, files from packs at the top of the stack override those below; however, for certain files, such as localization files and tags, data is actually merged contentwise. Mods actually define resource and data packs too, in their resources directories, but they are seen as subsets of the \u201cDefault\u201d pack. Mod resource packs cannot be disabled, but they can be overriden by other resource packs. Mod datapacks can be disabled with the vanilla /datapack command. All resources should have snake case paths and filenames (lowercase, using \u201c_\u201d for word boundaries), which is enforced in 1.11 and above. ResourceLocation Minecraft identifies resources using ResourceLocation s. A ResourceLocation contains two parts: a namespace and a path. It generally points to the resource at assets/<namespace>/<ctx>/<path> , where ctx is a context-specific path fragment that depends on how the ResourceLocation is being used. When a ResourceLocation is written/read as/from a string, it is seen as <namespace>:<path> . If the namespace and the colon are left out, then when the string is read into an ResourceLocation the namespace will almost always default to \"minecraft\" . A mod should put its resources into a namespace with the same name as its modid (E.g. a mod with id examplemod should place its resources in assets/examplemod , and ResourceLocation s pointing to those files would look like examplemod:<path> .). This is not a requirement, and in some cases it can be desirable to use a different (or even more than one) namespace. ResourceLocation s are used outside the resource system, too, as they happen to be a great way to uniquely identify objects (e.g. registries ).","title":"Resources"},{"location":"concepts/resources/#resources","text":"A resource is extra data used by the game, and is stored in a data file, instead of being in the code. Minecraft has two primary resource systems active: one on the client used for visuals such as models, textures, and localization called assets , the other used for gameplay such as recipes and loot tables called data . Resource packs control the former, while data packs control the latter. In the default mod development kit, assets and data directories are located under the src/main/resources directory of the project. When multiple resource packs or data packs are enabled, they are merged. Generally, files from packs at the top of the stack override those below; however, for certain files, such as localization files and tags, data is actually merged contentwise. Mods actually define resource and data packs too, in their resources directories, but they are seen as subsets of the \u201cDefault\u201d pack. Mod resource packs cannot be disabled, but they can be overriden by other resource packs. Mod datapacks can be disabled with the vanilla /datapack command. All resources should have snake case paths and filenames (lowercase, using \u201c_\u201d for word boundaries), which is enforced in 1.11 and above.","title":"Resources"},{"location":"concepts/resources/#resourcelocation","text":"Minecraft identifies resources using ResourceLocation s. A ResourceLocation contains two parts: a namespace and a path. It generally points to the resource at assets/<namespace>/<ctx>/<path> , where ctx is a context-specific path fragment that depends on how the ResourceLocation is being used. When a ResourceLocation is written/read as/from a string, it is seen as <namespace>:<path> . If the namespace and the colon are left out, then when the string is read into an ResourceLocation the namespace will almost always default to \"minecraft\" . A mod should put its resources into a namespace with the same name as its modid (E.g. a mod with id examplemod should place its resources in assets/examplemod , and ResourceLocation s pointing to those files would look like examplemod:<path> .). This is not a requirement, and in some cases it can be desirable to use a different (or even more than one) namespace. ResourceLocation s are used outside the resource system, too, as they happen to be a great way to uniquely identify objects (e.g. registries ).","title":"ResourceLocation"},{"location":"concepts/sides/","text":"Sides in Minecraft A very important concept to understand when modding Minecraft are the two sides: client and server . There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects. Different Kinds of Sides When we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we\u2019re talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right? As it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d: Physical client - The physical client is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client. Physical server - Often known as the dedicated server, the physical server is the entire program that runs whenever you launch any sort of minecraft_server.jar that does not bring up a playable GUI. Logical server - The logical server is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within the physical server, but is also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the Server Thread . Logical client - The logical client is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the Client Thread , though often several other threads are spawned to handle things like audio and chunk render batching. In the Minecraft codebase, the physical side is represented by an enum called Dist , while the logical side is represented by an enum called LogicalSide . Performing Side-Specific Operations world.isRemote This boolean check will be your most used way to check sides. Querying this field on a World object establishes the logical side the world belongs to. That is, if this field is true , the world is currently running on the logical client. If the field is false , the world is running on the logical server. It follows that the physical server will always contain false in this field, but we cannot assume that false implies a physical server, since this field can also be false for the logical server inside a physical client (in other words, a single player world). Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring world.isRemote is false . Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the lightest case, and crashes in the worst case. This check should be used as your go-to default. Aside from DistExecutor , rarely will you need the other ways of determining side and adjusting behavior. DistExecutor Considering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in net.minecraft.client is only present on the physical client, and all code in net.minecraft.server.dedicated is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call Minecraft.getMinecraft().<doStuff>() in block or tile entity classes, which will crash any physical server as soon as the class is loaded. How do we resolve this? Luckily, FML has DistExecutor , which provides various methods to run different methods on different physical sides, or a single method only on one side. Note It is important to understand that FML checks based on the physical side. A single player world (logical server + logical client within a physical client) will always use Dist.CLIENT ! Thread Groups If Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER is true, it is likely the current thread is on the logical server. Otherwise, it is likely on the logical client. This is useful to retrieve the logical side when you do not have access to a World object to check isRemote . It guesses which logical side you are on by looking at the group of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking world.isRemote to this check. FMLEnvironment.dist and @OnlyIn FMLEnvironment.dist holds the physical side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this is limited, however. Annotating a method or field with the @OnlyIn(Dist) annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified physical side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is little to no reason for using this annotation directly. Only use it if you are overriding a vanilla method that already has @OnlyIn defined. In most other cases where you need to dispatch behavior based on physical sides, use DistExecutor or a check on FMLEnvironment.dist instead. Common Mistakes Reaching Across Logical Sides Whenever you want to send information from one logical side to another, you must always use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client. This is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading. This mistake can also be made explicitly by accessing physical client-only classes such as Minecraft from common code that runs or can run on the logical server. This mistake is easy to miss for beginners, who debug in a physical client. The code will work there, but will immediately crash on a physical server.","title":"Sides"},{"location":"concepts/sides/#sides-in-minecraft","text":"A very important concept to understand when modding Minecraft are the two sides: client and server . There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects.","title":"Sides in Minecraft"},{"location":"concepts/sides/#different-kinds-of-sides","text":"When we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we\u2019re talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right? As it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d: Physical client - The physical client is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client. Physical server - Often known as the dedicated server, the physical server is the entire program that runs whenever you launch any sort of minecraft_server.jar that does not bring up a playable GUI. Logical server - The logical server is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within the physical server, but is also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the Server Thread . Logical client - The logical client is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the Client Thread , though often several other threads are spawned to handle things like audio and chunk render batching. In the Minecraft codebase, the physical side is represented by an enum called Dist , while the logical side is represented by an enum called LogicalSide .","title":"Different Kinds of Sides"},{"location":"concepts/sides/#performing-side-specific-operations","text":"","title":"Performing Side-Specific Operations"},{"location":"concepts/sides/#worldisremote","text":"This boolean check will be your most used way to check sides. Querying this field on a World object establishes the logical side the world belongs to. That is, if this field is true , the world is currently running on the logical client. If the field is false , the world is running on the logical server. It follows that the physical server will always contain false in this field, but we cannot assume that false implies a physical server, since this field can also be false for the logical server inside a physical client (in other words, a single player world). Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring world.isRemote is false . Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the lightest case, and crashes in the worst case. This check should be used as your go-to default. Aside from DistExecutor , rarely will you need the other ways of determining side and adjusting behavior.","title":"world.isRemote"},{"location":"concepts/sides/#distexecutor","text":"Considering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in net.minecraft.client is only present on the physical client, and all code in net.minecraft.server.dedicated is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call Minecraft.getMinecraft().<doStuff>() in block or tile entity classes, which will crash any physical server as soon as the class is loaded. How do we resolve this? Luckily, FML has DistExecutor , which provides various methods to run different methods on different physical sides, or a single method only on one side. Note It is important to understand that FML checks based on the physical side. A single player world (logical server + logical client within a physical client) will always use Dist.CLIENT !","title":"DistExecutor"},{"location":"concepts/sides/#thread-groups","text":"If Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER is true, it is likely the current thread is on the logical server. Otherwise, it is likely on the logical client. This is useful to retrieve the logical side when you do not have access to a World object to check isRemote . It guesses which logical side you are on by looking at the group of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking world.isRemote to this check.","title":"Thread Groups"},{"location":"concepts/sides/#fmlenvironmentdist-and-onlyin","text":"FMLEnvironment.dist holds the physical side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this is limited, however. Annotating a method or field with the @OnlyIn(Dist) annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified physical side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is little to no reason for using this annotation directly. Only use it if you are overriding a vanilla method that already has @OnlyIn defined. In most other cases where you need to dispatch behavior based on physical sides, use DistExecutor or a check on FMLEnvironment.dist instead.","title":"FMLEnvironment.dist and @OnlyIn"},{"location":"concepts/sides/#common-mistakes","text":"","title":"Common Mistakes"},{"location":"concepts/sides/#reaching-across-logical-sides","text":"Whenever you want to send information from one logical side to another, you must always use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client. This is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading. This mistake can also be made explicitly by accessing physical client-only classes such as Minecraft from common code that runs or can run on the logical server. This mistake is easy to miss for beginners, who debug in a physical client. The code will work there, but will immediately crash on a physical server.","title":"Reaching Across Logical Sides"},{"location":"config/annotations/","text":"@Config The @Config annotation is an alternative to Configuration . Table of Contents Basics @Config Use @Comment Use @Name Use @RangeInt Use @RangeDouble Use @LangKey Use @RequiresMcRestart Use @RequiresWorldRestart Use Sub Categories @Ignore Basics A class annotated with @Config will have any fields turned into config options. Said fields can be annotated to add information, using the plethora of annotations provided in the @Config class. Note Enum config values generate a comment that is as many lines long as the enum has values. A good example of this system is Forge's Test @Config Use This annotation is used to denote a class is the container for some configuration options. There are 4 properties: Property Type Default Value Comment modid String N/A The mod id that this configuration is associated with. name String \"\" A user friendly name for the config file, the default will be modid. type Type Type.INSTANCE The type this is, right now the only value is Type.INSTANCE . This is intended to be expanded upon later for more Forge controlled configs. category String \"general\" Root element category. If this is an empty string then the root category is disabled. Important If you disable the root category, this will cause issues unless you create Sub Categories . @Comment Use Adding a @Comment annotation to a field will add a comment to the config in its file. It has 1 property: Property Type Default Value Comment value String[] / String N/A The passed value will be converted to a String[] and for each element of the String[] a new line is added to the comment. Example @Comment({ \"You can add comments using this\", \"and if you supply an array it will be multi-line\" }) public static boolean doTheThing = true; This would produce the following config: # You can add comments using this # and if you supply an array it will be multi-line B:doTheThing=true @Name Use You should use the @Name annotation to give a config a user friendly name in the config file. This has 1 property: Property Type Default Value value String N/A Example @Name(\"FE/T for the thing\") public static int thingFE = 50; This will produce the following config: I:\"FE/T for the thing\"=50 @RangeInt Use You should use @RangeInt to limit an int or Integer config value. It has 2 properties: Property Type Default Value min int Integer.MIN_VALUE max int Integer.MAX_VALUE Example @RangeInt(min = 0) public static int thingFECapped = 50; This will produce the following config: # Min: 0 # Max: 2147483647 I:thingFECapped=50 @RangeDouble Use You should use @RangeDouble to limit a double or Double config value. It has 2 properties: Property Type Default Value min double Double.MIN_VALUE max double Double.MAX_VALUE Example @RangeDouble(min = 0, max = Math.PI) public static double chanceToDrop = 2; This will produce the following config: # Min: 0.0 # Max: 3.141592653589793 D:chanceToDrop=2.0 Note There is not currently (in 1.12.2) a @RangedFloat or @RangedLong or any other variant of the Ranged values. @LangKey Use If you want to add translations for your configs in the mod options menu, add to the config\u2019s field @LangKey . This has 1 property: Property Type Default Value value String N/A @RequiresMcRestart Use You should include this annotation on a config that if changed, will require the game to be restarted for the change to take affect. Example @RequiresMcRestart public static boolean overlayEnabled = false; This will make the game require a restart if the value is changed in the configs menu. @RequiresWorldRestart Use This will force the world to be restarted if the config is changed in the mod options menu. Example @RequiresWorldRestart public static boolean someOtherworldlyThing = false; This will force the world to be restarted if the config is changed in the mod options menu. Sub Categories A Sub Category is a way to group certain (usually related) config options together, and should be used to help make navigating your config file easier. To create a Sub Category, you must make an object and add it as a static field in the parent category\u2019s class. The object\u2019s member fields will become configs in that Sub Category. An example of how to setup a Sub Category: @Config(modid = \"modid\") public class Configs { public static SubCategory subcat = new SubCategory(); private static class SubCategory { public boolean someBool; public int relatedInt; } } In the config file, this will produce the following: subcat { B:someBool=false I:relatedInt=0 } @Ignore Use Adding the @Ignore annotation to a field in the config class will cause the ConfigManager to skip over it when processing your config file. Note This will only work on forge version 1.12.2-14.23.1.2602 and later, as the feature was added in this update","title":"Config Annotations"},{"location":"config/annotations/#config","text":"The @Config annotation is an alternative to Configuration .","title":"@Config"},{"location":"config/annotations/#table-of-contents","text":"Basics @Config Use @Comment Use @Name Use @RangeInt Use @RangeDouble Use @LangKey Use @RequiresMcRestart Use @RequiresWorldRestart Use Sub Categories @Ignore","title":"Table of Contents"},{"location":"config/annotations/#basics","text":"A class annotated with @Config will have any fields turned into config options. Said fields can be annotated to add information, using the plethora of annotations provided in the @Config class. Note Enum config values generate a comment that is as many lines long as the enum has values. A good example of this system is Forge's Test","title":"Basics"},{"location":"config/annotations/#config-use","text":"This annotation is used to denote a class is the container for some configuration options. There are 4 properties: Property Type Default Value Comment modid String N/A The mod id that this configuration is associated with. name String \"\" A user friendly name for the config file, the default will be modid. type Type Type.INSTANCE The type this is, right now the only value is Type.INSTANCE . This is intended to be expanded upon later for more Forge controlled configs. category String \"general\" Root element category. If this is an empty string then the root category is disabled. Important If you disable the root category, this will cause issues unless you create Sub Categories .","title":"@Config Use"},{"location":"config/annotations/#comment-use","text":"Adding a @Comment annotation to a field will add a comment to the config in its file. It has 1 property: Property Type Default Value Comment value String[] / String N/A The passed value will be converted to a String[] and for each element of the String[] a new line is added to the comment.","title":"@Comment Use"},{"location":"config/annotations/#example","text":"@Comment({ \"You can add comments using this\", \"and if you supply an array it will be multi-line\" }) public static boolean doTheThing = true; This would produce the following config: # You can add comments using this # and if you supply an array it will be multi-line B:doTheThing=true","title":"Example"},{"location":"config/annotations/#name-use","text":"You should use the @Name annotation to give a config a user friendly name in the config file. This has 1 property: Property Type Default Value value String N/A","title":"@Name Use"},{"location":"config/annotations/#example_1","text":"@Name(\"FE/T for the thing\") public static int thingFE = 50; This will produce the following config: I:\"FE/T for the thing\"=50","title":"Example"},{"location":"config/annotations/#rangeint-use","text":"You should use @RangeInt to limit an int or Integer config value. It has 2 properties: Property Type Default Value min int Integer.MIN_VALUE max int Integer.MAX_VALUE","title":"@RangeInt Use"},{"location":"config/annotations/#example_2","text":"@RangeInt(min = 0) public static int thingFECapped = 50; This will produce the following config: # Min: 0 # Max: 2147483647 I:thingFECapped=50","title":"Example"},{"location":"config/annotations/#rangedouble-use","text":"You should use @RangeDouble to limit a double or Double config value. It has 2 properties: Property Type Default Value min double Double.MIN_VALUE max double Double.MAX_VALUE","title":"@RangeDouble Use"},{"location":"config/annotations/#example_3","text":"@RangeDouble(min = 0, max = Math.PI) public static double chanceToDrop = 2; This will produce the following config: # Min: 0.0 # Max: 3.141592653589793 D:chanceToDrop=2.0 Note There is not currently (in 1.12.2) a @RangedFloat or @RangedLong or any other variant of the Ranged values.","title":"Example"},{"location":"config/annotations/#langkey-use","text":"If you want to add translations for your configs in the mod options menu, add to the config\u2019s field @LangKey . This has 1 property: Property Type Default Value value String N/A","title":"@LangKey Use"},{"location":"config/annotations/#requiresmcrestart-use","text":"You should include this annotation on a config that if changed, will require the game to be restarted for the change to take affect.","title":"@RequiresMcRestart Use"},{"location":"config/annotations/#example_4","text":"@RequiresMcRestart public static boolean overlayEnabled = false; This will make the game require a restart if the value is changed in the configs menu.","title":"Example"},{"location":"config/annotations/#requiresworldrestart-use","text":"This will force the world to be restarted if the config is changed in the mod options menu.","title":"@RequiresWorldRestart Use"},{"location":"config/annotations/#example_5","text":"@RequiresWorldRestart public static boolean someOtherworldlyThing = false; This will force the world to be restarted if the config is changed in the mod options menu.","title":"Example"},{"location":"config/annotations/#sub-categories","text":"A Sub Category is a way to group certain (usually related) config options together, and should be used to help make navigating your config file easier. To create a Sub Category, you must make an object and add it as a static field in the parent category\u2019s class. The object\u2019s member fields will become configs in that Sub Category. An example of how to setup a Sub Category: @Config(modid = \"modid\") public class Configs { public static SubCategory subcat = new SubCategory(); private static class SubCategory { public boolean someBool; public int relatedInt; } } In the config file, this will produce the following: subcat { B:someBool=false I:relatedInt=0 }","title":"Sub Categories"},{"location":"config/annotations/#ignore-use","text":"Adding the @Ignore annotation to a field in the config class will cause the ConfigManager to skip over it when processing your config file. Note This will only work on forge version 1.12.2-14.23.1.2602 and later, as the feature was added in this update","title":"@Ignore Use"},{"location":"conventions/loadstages/","text":"Loading Stages The Forge loading process has four main phases. All of these events shown are fired on the mod-specific eventbus, not the global Forge event bus MinecraftForge.EVENT_BUS Handlers should be registered either using @EventBusSubscriber(bus = Bus.MOD) or in the mod object constructor as follows: @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().registerListener(this::commonSetup); } private void commonSetup(FMLCommonSetupEvent evt) { ... } } Warning All four of the below events are called for all mods in parallel. That is, all mods will concurrently receive common setup, FML will wait for them all to finish, then all mods will concurrently receive sided setup, and so forth. Mods must take care to be thread safe, especially when calling other mods\u2019 API\u2019s and accessing Vanilla systems, which are not thread safe in general. This can be done using the DeferredWorkQueue class. Setup FMLCommonSetupEvent is the first to fire, and is fired early in the Minecraft starting process. Registry events are fired before this event, so you can expect all registry objects to be valid by the time this runs. Common actions to perform in common setup are: Creating and reading the config files Registering Capabilities Sided Setup FMLClientSetupEvent and FMLDedicatedServerSetupEvent are fired after common setup, and are where physical side-specific initialization should occur. Common actions to perform here are registering client-side only things such as key bindings. IMC Enqueue Here, mods should send messages to all other mods they are interested in integrating with, using the InterModComms.sendTo() method. IMC Process Here, mods should process all the messages they have received from other mods and set up integrations appropriately. A mod may retrieve the messages that have been sent to it using the InterModComms.getMessages() method. Other Important Events FMLServerStartingEvent: Register Commands","title":"Loading Stages"},{"location":"conventions/loadstages/#loading-stages","text":"The Forge loading process has four main phases. All of these events shown are fired on the mod-specific eventbus, not the global Forge event bus MinecraftForge.EVENT_BUS Handlers should be registered either using @EventBusSubscriber(bus = Bus.MOD) or in the mod object constructor as follows: @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().registerListener(this::commonSetup); } private void commonSetup(FMLCommonSetupEvent evt) { ... } } Warning All four of the below events are called for all mods in parallel. That is, all mods will concurrently receive common setup, FML will wait for them all to finish, then all mods will concurrently receive sided setup, and so forth. Mods must take care to be thread safe, especially when calling other mods\u2019 API\u2019s and accessing Vanilla systems, which are not thread safe in general. This can be done using the DeferredWorkQueue class.","title":"Loading Stages"},{"location":"conventions/loadstages/#setup","text":"FMLCommonSetupEvent is the first to fire, and is fired early in the Minecraft starting process. Registry events are fired before this event, so you can expect all registry objects to be valid by the time this runs. Common actions to perform in common setup are: Creating and reading the config files Registering Capabilities","title":"Setup"},{"location":"conventions/loadstages/#sided-setup","text":"FMLClientSetupEvent and FMLDedicatedServerSetupEvent are fired after common setup, and are where physical side-specific initialization should occur. Common actions to perform here are registering client-side only things such as key bindings.","title":"Sided Setup"},{"location":"conventions/loadstages/#imc-enqueue","text":"Here, mods should send messages to all other mods they are interested in integrating with, using the InterModComms.sendTo() method.","title":"IMC Enqueue"},{"location":"conventions/loadstages/#imc-process","text":"Here, mods should process all the messages they have received from other mods and set up integrations appropriately. A mod may retrieve the messages that have been sent to it using the InterModComms.getMessages() method.","title":"IMC Process"},{"location":"conventions/loadstages/#other-important-events","text":"FMLServerStartingEvent: Register Commands","title":"Other Important Events"},{"location":"conventions/locations/","text":"Locations Minecraft expects certain parts of your project to be in certain locations, such as textures and JSONs. All locations and items covered in this page are relative to your ./src/main/resources/ folder. mods.toml The mods.toml file is in the ./META-INF/ directory. Blockstates Blockstate definition files are in the JSON format and are in the ./assets/<modid>/blockstates/ folder. Localizations Localizations are plain-text files with the file extension .json and the name being their language code in lowercase such as en_us . They are located in the ./assets/<modid>/lang/ folder. Models Model files are in JSON format and are located in ./assets/<modid>/models/block/ or ./assets/<modid>/models/item/ depending on whether they are for a block or an item, respectively. Textures Textures are in the PNG format and are located in ./assets/<modid>/textures/blocks/ or ./assets/<modid>/textures/items/ depending on whether they are for a block or an item, respectively. Recipes Recipes are in JSON format and are located in ./data/<modid>/recipes/ .","title":"Locations"},{"location":"conventions/locations/#locations","text":"Minecraft expects certain parts of your project to be in certain locations, such as textures and JSONs. All locations and items covered in this page are relative to your ./src/main/resources/ folder.","title":"Locations"},{"location":"conventions/locations/#modstoml","text":"The mods.toml file is in the ./META-INF/ directory.","title":"mods.toml"},{"location":"conventions/locations/#blockstates","text":"Blockstate definition files are in the JSON format and are in the ./assets/<modid>/blockstates/ folder.","title":"Blockstates"},{"location":"conventions/locations/#localizations","text":"Localizations are plain-text files with the file extension .json and the name being their language code in lowercase such as en_us . They are located in the ./assets/<modid>/lang/ folder.","title":"Localizations"},{"location":"conventions/locations/#models","text":"Model files are in JSON format and are located in ./assets/<modid>/models/block/ or ./assets/<modid>/models/item/ depending on whether they are for a block or an item, respectively.","title":"Models"},{"location":"conventions/locations/#textures","text":"Textures are in the PNG format and are located in ./assets/<modid>/textures/blocks/ or ./assets/<modid>/textures/items/ depending on whether they are for a block or an item, respectively.","title":"Textures"},{"location":"conventions/locations/#recipes","text":"Recipes are in JSON format and are located in ./data/<modid>/recipes/ .","title":"Recipes"},{"location":"conventions/versioning/","text":"Versioning In general projects, Semantic Versioning is often used (which has the format MAJOR.MINOR.PATCH ). However, in the case of modding it may be more beneficial to use the format MCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH , to be able to differentiate between world-breaking and API-breaking changes of a mod. Examples Here is a (most likely incomplete) list of things that increment the various variables. MCVERSION Always matches the Minecraft version the mod is for. MAJORMOD Removing items, blocks, tile entities, etc. Changing or removing previously existing mechanics. Updating to a new Minecraft version. MAJORAPI Changing the order or variables of enums. Changing return types of methods. Removing public methods altogether. MINOR Adding items, blocks, tile entities, etc. Adding new mechanics. Deprecating public methods. (This is not a MAJORAPI increment since it doesn\u2019t break an API.) PATCH Bugfixes. When incrementing any variable, all lesser variables should reset to 0 . For instance, if MINOR would increment, PATCH would become 0 . If MAJORMOD would increment, all other variables would become 0 . Work In Progress If you are in the initial development stage of your mod (before any official releases), the MAJORMOD and MAJORAPI should always be 0 . Only MINOR should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment MAJORMOD to version 1.0.0.0 . For any further development stages, refer to the Prereleases and Release candidates section of this document. Multiple Minecraft Versions If the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the PATCH variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to both build numbers. For example, if the mod is upgraded to version 3.0.0.0 due to a Minecraft version change, the old mod should also be updated to 3.0.0.0 . The old version will become, for example, version 1.7.10-3.0.0.0 , while the new version will become 1.8-3.0.0.0 . If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same. Final Release When dropping support for a Minecraft version, the last build for that version should get the -final suffix. This denotes that the mod will no longer be supported for the denoted MCVERSION and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes. Pre-releases It is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with -betaX , where X is the number of the prerelease. (This guide does not use -pre since, at the time of writing, it is not a valid alias for -beta according to Forge.) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -beta suffix. Versions before the initial release are simply work-in-progress builds. Release Candidates Release candidates act as prereleases before an actual version change. These versions should be appended with -rcX , where X is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -rc suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.","title":"Versioning"},{"location":"conventions/versioning/#versioning","text":"In general projects, Semantic Versioning is often used (which has the format MAJOR.MINOR.PATCH ). However, in the case of modding it may be more beneficial to use the format MCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH , to be able to differentiate between world-breaking and API-breaking changes of a mod.","title":"Versioning"},{"location":"conventions/versioning/#examples","text":"Here is a (most likely incomplete) list of things that increment the various variables. MCVERSION Always matches the Minecraft version the mod is for. MAJORMOD Removing items, blocks, tile entities, etc. Changing or removing previously existing mechanics. Updating to a new Minecraft version. MAJORAPI Changing the order or variables of enums. Changing return types of methods. Removing public methods altogether. MINOR Adding items, blocks, tile entities, etc. Adding new mechanics. Deprecating public methods. (This is not a MAJORAPI increment since it doesn\u2019t break an API.) PATCH Bugfixes. When incrementing any variable, all lesser variables should reset to 0 . For instance, if MINOR would increment, PATCH would become 0 . If MAJORMOD would increment, all other variables would become 0 .","title":"Examples"},{"location":"conventions/versioning/#work-in-progress","text":"If you are in the initial development stage of your mod (before any official releases), the MAJORMOD and MAJORAPI should always be 0 . Only MINOR should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment MAJORMOD to version 1.0.0.0 . For any further development stages, refer to the Prereleases and Release candidates section of this document.","title":"Work In Progress"},{"location":"conventions/versioning/#multiple-minecraft-versions","text":"If the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the PATCH variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to both build numbers. For example, if the mod is upgraded to version 3.0.0.0 due to a Minecraft version change, the old mod should also be updated to 3.0.0.0 . The old version will become, for example, version 1.7.10-3.0.0.0 , while the new version will become 1.8-3.0.0.0 . If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same.","title":"Multiple Minecraft Versions"},{"location":"conventions/versioning/#final-release","text":"When dropping support for a Minecraft version, the last build for that version should get the -final suffix. This denotes that the mod will no longer be supported for the denoted MCVERSION and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes.","title":"Final Release"},{"location":"conventions/versioning/#pre-releases","text":"It is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with -betaX , where X is the number of the prerelease. (This guide does not use -pre since, at the time of writing, it is not a valid alias for -beta according to Forge.) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -beta suffix. Versions before the initial release are simply work-in-progress builds.","title":"Pre-releases"},{"location":"conventions/versioning/#release-candidates","text":"Release candidates act as prereleases before an actual version change. These versions should be appended with -rcX , where X is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -rc suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.","title":"Release Candidates"},{"location":"datastorage/capabilities/","text":"The Capability System Capabilities allow exposing features in a dynamic and flexible way, without having to resort to directly implementing many interfaces. In general terms, each capability provides a feature in the form of an interface, alongside with a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations. Forge adds capability support to TileEntities, Entities, ItemStacks, Worlds and Chunks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections. Forge-provided Capabilities Forge provides three capabilities: IItemHandler, IFluidHandler and IEnergyStorage IItemHandler exposes an interface for handling inventory slots. It can be applied to TileEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old IInventory and ISidedInventory with an automation-friendly system. IFluidHandler exposes an interface for handling fluid inventories. It can also be applied to TileEntities Entities, or ItemStacks. It replaces the old IFluidHandler with a more consistent and automation-friendly system. IEnergyStorage exposes an interface for handling energy containers. It can be applied to TileEntities, Entities or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH. Using an Existing Capability As mentioned earlier, TileEntities, Entities, and ItemStacks implement the capability provider feature, through the ICapabilityProvider interface. This interface adds two methods, hasCapability and getCapability , which can be used to query the capabilities present in the objects. In order to obtain a capability, you will need to refer it by its unique instance. In the case of the Item Handler, this capability is primarily stored in CapabilityItemHandler.ITEM_HANDLER_CAPABILITY , but it is possible to get other instance references by using the @CapabilityInject annotation. @CapabilityInject(IItemHandler.class) static Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = null; This annotation can be applied to fields and methods. When applied to a field, it will assign the instance of the capability (the same one gets assigned to all fields) upon registration of the capability, and left to the existing value ( null ), if the capability was never registered. Because local static field accesses are fast, it is a good idea to keep your own local copy of the reference for objects that work with capabilities. This annotation can also be used on a method, in order to get notified when a capability is registered, so that certain features can be enabled conditionally. Both the hasCapability and getCapability methods have a second parameter, of type EnumFacing, which can be used in the to request the specific instance for that one face. If passed null , it can be assumed that the request comes either from within the block, or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of getCapability will correspond to the type declared in the capability passed to the method. For the Item Handler capability, this is indeed IItemHandler . Exposing a Capability In order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object. There\u2019s two ways to obtain such an instance, through the Capability itself, or by explicitly instantiating an implementation of it. The first method is designed to use a default implementation, if those default values are useful for you. In the case of the Item Handler capability, the default implementation will expose a single slot inventory, which is most probably not what you want. The second method can be used to provide custom implementations. In the case of IItemHandler , the default implementation uses the ItemStackHandler class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about @CapabilityInject in the previous section). Once you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability. This is done by overriding the hasCapability method, and comparing the instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the facing parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player (top side => head slot?), or about the surrounding blocks in the inventory (west => slot on the left?). Don\u2019t forget to fall back to super , otherwise the attached capabilities will stop working. @Override public boolean hasCapability(Capability<?> capability, EnumFacing facing) { if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return true; } return super.hasCapability(capability, facing); } Similarly, you will want to provide the interface reference to your capability instance, when requested. Again, don\u2019t forget to fall back to super . @Override public <T> T getCapability(Capability<T> capability, EnumFacing facing) { if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return (T) inventory; } return super.getCapability(capability, facing); } It is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps or other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game. Attaching Capabilities As mentioned, attaching capabilities to entities and itemstacks can be done using AttachCapabilitiesEvent . The same event is used for all objects that can provide capabilities. AttachCapabilitiesEvent has 5 valid generic types providing the following events: AttachCapabilitiesEvent<Entity> : Fires only for entities. AttachCapabilitiesEvent<TileEntity> : Fires only for tile entities. AttachCapabilitiesEvent<ItemStack> : Fires only for item stacks. AttachCapabilitiesEvent<World> : Fires only for worlds. AttachCapabilitiesEvent<Chunk> : Fires only for chunks. The generic type cannot be more specific than the above types. For example: If you want to attach capabilities to EntityPlayer , you have to subscribe to the AttachCapabilitiesEvent<Entity> , and then determine that the provided object is an EntityPlayer before attaching the capability. In all cases, the event has a method addCapability , which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement ICapabilityProvider , if the capability needs to store data persistently it is possible to implement ICapabilitySerializable<T extends NBTBase> which, on top of returning the capabilities, will allow providing NBT save/load functions. For information on how to implement ICapabilityProvider , refer to the Exposing a Capability section. Creating Your Own Capability In general terms, a capability is declared and registered through a single method call to CapabilityManager.INSTANCE.register() . One possibility is to define a static register() method inside a dedicated class for the capability, but this is not required by the capability system. For the purpose of this documentation we will be describing each part as a separate named class, although anonymous classes are an option. CapabilityManager.INSTANCE.register(capability interface class, storage, default implementation factory); The first parameter to this method, is the type that describes the capability feature. In our example, this will be IExampleCapability.class . The second parameter is an instance of a class that implements Capability.IStorage<T> , where T is the same class we specified in the first parameter. This storage class will help manage saving and loading for the default implementation, and it can, optionally, also support other implementations. private static class Storage implements Capability.IStorage<IExampleCapability> { @Override public NBTBase writeNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side) { // return an NBT tag } @Override public void readNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side, NBTBase nbt) { // load from the NBT tag } } The last parameter is a callable factory that will return new instances of the default implementation. private static class Factory implements Callable<IExampleCapability> { @Override public IExampleCapability call() throws Exception { return new Implementation(); } } Finally, we will need the default implementation itself, to be able to instantiate it in the factory. Designing this class is up to you, but it should at least provide a basic skeleton that people can use to test the capability, if it\u2019s not a fully usable implementation on itself. Persisting Chunk and TileEntity capabilities Unlike Worlds, Entities and ItemStacks, Chunks and TileEntities are only written to disk when they have been marked as dirty. A capability implementation with persistent state for a Chunk or a TileEntity should therefore ensure that whenever its state changes, its owner is marked as dirty. ItemStackHandler , commonly used for inventories in TileEntities, has an overridable method void onContentsChanged(int slot) designed to be used to mark the TileEntity as dirty. public class MyTileEntity extends TileEntity { private final IItemHandler inventory = new ItemStackHandler(...) { @Override protected void onContentsChanged(int slot) { super.onContentsChanged(slot); markDirty(); } } ... } Synchronizing Data with Clients By default, Capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situation in which you may want to send synchronization packets, all of them optional: When the entity spawns in the world, or the block is placed, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity or block, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing network packets. Persisting across Player Deaths By default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done by handling the PlayerEvent.Clone event, reading the data from the original entity, and assigning it to the new entity. In this event, the wasDead field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case. Migrating from IExtendedEntityProperties Although the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. In this section, I will explain how to convert existing IEEPs into Capabilities. This is a quick list of IEEP concepts and their Capability equivalent: Property name/id ( String ): Capability key ( ResourceLocation ) Registration ( EntityConstructing ): Attaching ( AttachCapabilitiesEvent<Entity> ), the real registration of the Capability happens during pre-init. NBT read/write methods: Does not happen automatically. Attach an ICapabilitySerializable in the event, and run the read/write methods from the serializeNBT / deserializeNBT . Features you probably will not need (if the IEEP was for internal use only): The Capability system provides a default implementation concept, meant to simplify usage by third party consumers, but it doesn\u2019t really make much sense for an internal Capability designed to replace an IEEP. You can safely return null from the factory if the capability is be for internal use only. The Capability system provides an IStorage system that can be used to read/write data from those default implementations, if you choose not to provide default implementations, then the IStorage system will never get called, and can be left blank. The following steps assume you have read the rest of the document, and you understand the concepts of the capability system. Quick conversion guide: Convert the IEEP key/id string into a ResourceLocation (which will use your MODID as a namespace). In your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance. Change the EntityConstructing event to AttachCapabilitiesEvent , and instead of querying the IEEP, you will want to attach an ICapabilityProvider (probably ICapabilitySerializable , which allows saving/loading from NBT). Create a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.","title":"Capabilities"},{"location":"datastorage/capabilities/#the-capability-system","text":"Capabilities allow exposing features in a dynamic and flexible way, without having to resort to directly implementing many interfaces. In general terms, each capability provides a feature in the form of an interface, alongside with a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations. Forge adds capability support to TileEntities, Entities, ItemStacks, Worlds and Chunks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections.","title":"The Capability System"},{"location":"datastorage/capabilities/#forge-provided-capabilities","text":"Forge provides three capabilities: IItemHandler, IFluidHandler and IEnergyStorage IItemHandler exposes an interface for handling inventory slots. It can be applied to TileEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old IInventory and ISidedInventory with an automation-friendly system. IFluidHandler exposes an interface for handling fluid inventories. It can also be applied to TileEntities Entities, or ItemStacks. It replaces the old IFluidHandler with a more consistent and automation-friendly system. IEnergyStorage exposes an interface for handling energy containers. It can be applied to TileEntities, Entities or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH.","title":"Forge-provided Capabilities"},{"location":"datastorage/capabilities/#using-an-existing-capability","text":"As mentioned earlier, TileEntities, Entities, and ItemStacks implement the capability provider feature, through the ICapabilityProvider interface. This interface adds two methods, hasCapability and getCapability , which can be used to query the capabilities present in the objects. In order to obtain a capability, you will need to refer it by its unique instance. In the case of the Item Handler, this capability is primarily stored in CapabilityItemHandler.ITEM_HANDLER_CAPABILITY , but it is possible to get other instance references by using the @CapabilityInject annotation. @CapabilityInject(IItemHandler.class) static Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = null; This annotation can be applied to fields and methods. When applied to a field, it will assign the instance of the capability (the same one gets assigned to all fields) upon registration of the capability, and left to the existing value ( null ), if the capability was never registered. Because local static field accesses are fast, it is a good idea to keep your own local copy of the reference for objects that work with capabilities. This annotation can also be used on a method, in order to get notified when a capability is registered, so that certain features can be enabled conditionally. Both the hasCapability and getCapability methods have a second parameter, of type EnumFacing, which can be used in the to request the specific instance for that one face. If passed null , it can be assumed that the request comes either from within the block, or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of getCapability will correspond to the type declared in the capability passed to the method. For the Item Handler capability, this is indeed IItemHandler .","title":"Using an Existing Capability"},{"location":"datastorage/capabilities/#exposing-a-capability","text":"In order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object. There\u2019s two ways to obtain such an instance, through the Capability itself, or by explicitly instantiating an implementation of it. The first method is designed to use a default implementation, if those default values are useful for you. In the case of the Item Handler capability, the default implementation will expose a single slot inventory, which is most probably not what you want. The second method can be used to provide custom implementations. In the case of IItemHandler , the default implementation uses the ItemStackHandler class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about @CapabilityInject in the previous section). Once you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability. This is done by overriding the hasCapability method, and comparing the instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the facing parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player (top side => head slot?), or about the surrounding blocks in the inventory (west => slot on the left?). Don\u2019t forget to fall back to super , otherwise the attached capabilities will stop working. @Override public boolean hasCapability(Capability<?> capability, EnumFacing facing) { if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return true; } return super.hasCapability(capability, facing); } Similarly, you will want to provide the interface reference to your capability instance, when requested. Again, don\u2019t forget to fall back to super . @Override public <T> T getCapability(Capability<T> capability, EnumFacing facing) { if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return (T) inventory; } return super.getCapability(capability, facing); } It is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps or other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game.","title":"Exposing a Capability"},{"location":"datastorage/capabilities/#attaching-capabilities","text":"As mentioned, attaching capabilities to entities and itemstacks can be done using AttachCapabilitiesEvent . The same event is used for all objects that can provide capabilities. AttachCapabilitiesEvent has 5 valid generic types providing the following events: AttachCapabilitiesEvent<Entity> : Fires only for entities. AttachCapabilitiesEvent<TileEntity> : Fires only for tile entities. AttachCapabilitiesEvent<ItemStack> : Fires only for item stacks. AttachCapabilitiesEvent<World> : Fires only for worlds. AttachCapabilitiesEvent<Chunk> : Fires only for chunks. The generic type cannot be more specific than the above types. For example: If you want to attach capabilities to EntityPlayer , you have to subscribe to the AttachCapabilitiesEvent<Entity> , and then determine that the provided object is an EntityPlayer before attaching the capability. In all cases, the event has a method addCapability , which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement ICapabilityProvider , if the capability needs to store data persistently it is possible to implement ICapabilitySerializable<T extends NBTBase> which, on top of returning the capabilities, will allow providing NBT save/load functions. For information on how to implement ICapabilityProvider , refer to the Exposing a Capability section.","title":"Attaching Capabilities"},{"location":"datastorage/capabilities/#creating-your-own-capability","text":"In general terms, a capability is declared and registered through a single method call to CapabilityManager.INSTANCE.register() . One possibility is to define a static register() method inside a dedicated class for the capability, but this is not required by the capability system. For the purpose of this documentation we will be describing each part as a separate named class, although anonymous classes are an option. CapabilityManager.INSTANCE.register(capability interface class, storage, default implementation factory); The first parameter to this method, is the type that describes the capability feature. In our example, this will be IExampleCapability.class . The second parameter is an instance of a class that implements Capability.IStorage<T> , where T is the same class we specified in the first parameter. This storage class will help manage saving and loading for the default implementation, and it can, optionally, also support other implementations. private static class Storage implements Capability.IStorage<IExampleCapability> { @Override public NBTBase writeNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side) { // return an NBT tag } @Override public void readNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side, NBTBase nbt) { // load from the NBT tag } } The last parameter is a callable factory that will return new instances of the default implementation. private static class Factory implements Callable<IExampleCapability> { @Override public IExampleCapability call() throws Exception { return new Implementation(); } } Finally, we will need the default implementation itself, to be able to instantiate it in the factory. Designing this class is up to you, but it should at least provide a basic skeleton that people can use to test the capability, if it\u2019s not a fully usable implementation on itself.","title":"Creating Your Own Capability"},{"location":"datastorage/capabilities/#persisting-chunk-and-tileentity-capabilities","text":"Unlike Worlds, Entities and ItemStacks, Chunks and TileEntities are only written to disk when they have been marked as dirty. A capability implementation with persistent state for a Chunk or a TileEntity should therefore ensure that whenever its state changes, its owner is marked as dirty. ItemStackHandler , commonly used for inventories in TileEntities, has an overridable method void onContentsChanged(int slot) designed to be used to mark the TileEntity as dirty. public class MyTileEntity extends TileEntity { private final IItemHandler inventory = new ItemStackHandler(...) { @Override protected void onContentsChanged(int slot) { super.onContentsChanged(slot); markDirty(); } } ... }","title":"Persisting Chunk and TileEntity capabilities"},{"location":"datastorage/capabilities/#synchronizing-data-with-clients","text":"By default, Capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situation in which you may want to send synchronization packets, all of them optional: When the entity spawns in the world, or the block is placed, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity or block, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing network packets.","title":"Synchronizing Data with Clients"},{"location":"datastorage/capabilities/#persisting-across-player-deaths","text":"By default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done by handling the PlayerEvent.Clone event, reading the data from the original entity, and assigning it to the new entity. In this event, the wasDead field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case.","title":"Persisting across Player Deaths"},{"location":"datastorage/capabilities/#migrating-from-iextendedentityproperties","text":"Although the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. In this section, I will explain how to convert existing IEEPs into Capabilities. This is a quick list of IEEP concepts and their Capability equivalent: Property name/id ( String ): Capability key ( ResourceLocation ) Registration ( EntityConstructing ): Attaching ( AttachCapabilitiesEvent<Entity> ), the real registration of the Capability happens during pre-init. NBT read/write methods: Does not happen automatically. Attach an ICapabilitySerializable in the event, and run the read/write methods from the serializeNBT / deserializeNBT . Features you probably will not need (if the IEEP was for internal use only): The Capability system provides a default implementation concept, meant to simplify usage by third party consumers, but it doesn\u2019t really make much sense for an internal Capability designed to replace an IEEP. You can safely return null from the factory if the capability is be for internal use only. The Capability system provides an IStorage system that can be used to read/write data from those default implementations, if you choose not to provide default implementations, then the IStorage system will never get called, and can be left blank. The following steps assume you have read the rest of the document, and you understand the concepts of the capability system. Quick conversion guide: Convert the IEEP key/id string into a ResourceLocation (which will use your MODID as a namespace). In your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance. Change the EntityConstructing event to AttachCapabilitiesEvent , and instead of querying the IEEP, you will want to attach an ICapabilityProvider (probably ICapabilitySerializable , which allows saving/loading from NBT). Create a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.","title":"Migrating from IExtendedEntityProperties"},{"location":"datastorage/extendedentityproperties/","text":"Extended Entity Properties Extended entity properties allow attaching data to entities. Warning This system has been deprecated in favor of the Capability system. Declaration and Registration The basis of the EEPs is the IExtendedEntityProperties interface. This interface provides the basic methods required for managing the extended data: init : Allows the implementation to have knowledge about the entity it\u2019s attached to, and the world this entity is loaded into. saveNBTData : Allows the implementation to store data in the save file, to be loaded when the entity gets loaded into the world. loadNBTData : Allows the implementation to read the previously saved data for this entity. An implementation will have a class implementing this interface, and instances of this class will be attached to the entities, ready to store any required data. The implementation will need to make use of events in order to attach the IEEP to entities, and optionally any other required features. To help with encapsulation, you may want to create an inner class for handling those events. In the example, I created a register() method to help with that. A basic skeleton to get started: public class ExampleEntityProperty implements IExtendedEntityProperties { public static final String PROP_NAME = ExampleMod.MODID + \"_ExampleEntityData\"; public static void register() { MinecraftForge.EVENT_BUS.register(new Handler()); } // IExtendedEntityProperties methods go here public static class Handler { // Event handlers will go here } } Attaching the Implementation to Entities In order to attach the extended property to an entity, it is done by handling the EntityEvent.EntityConstructing event, and if the entity is of interest, using the Entity#registerExtendedProperties method. In order to uniquely identify your property and avoid duplication, the method takes a string parameter with an identifier for the property. A good practice is to include the modid in this string, so that it will not collide with other mods. Warning If the same property identifier is added twice, Forge will append a number to it, and return this modified identifier from the registerExtendedProperties method. If you don\u2019t want that to happen, you can use Entity#getExtendedProperties to check if an IEEP with that name was already added. In order to handle this event, you could do something like this: @SubscribeEvent public void entityConstruct(EntityEvent.EntityConstructing e) { if (e.entity instanceof EntityPlayer) { if (e.entity.getExtendedProperties(PROP_NAME) == null) { e.entity.registerExtendedProperties(PROP_NAME, new ExampleEntityProperty()); } } } Making Use of the Implementation To make use of the extended data, the instance of the IEEP implementation has to be obtained from the Entity, and because the entity could have been unloaded or may have changed dimensions, it is not safe to cache the references. To obtain the IEEP reference, one would use Entity#getExtendedProperties , with the same property ID specified on registration. The return value, if not null , is the instance of IExtendedEntityProperties added during entity construction. A good idea is to create a static get method in your IEEP implementation, that will automatically obtain the instance, and cast it to your implementation class. It can be as simple as: public static ExampleEntityProperty get(Entity p) { return (ExampleEntityProperty) p.getExtendedProperties(PROP_NAME); } Saving and Loading Data from NBT Forge allows all IEEPs attached to an entity to save and load themselves. However, keep in mind that the NBT tag provided in the saveNBTData and loadNBTData methods is a global tag for the entity, and may contain data for other IEEPs, along with all the data from the entity itself. There are some cases where an IEEP may benefit from accessing this global data, but for the most common use cases, it is important to avoid colliding with existing data, preferably by storing the data in a nested tag, using an unique name for it (such as the name used to identify the IEEP). Your code may look a bit like this: @Override public void saveNBTData(NBTTagCompound compound) { NBTTagCompound propertyData = new NBTTagCompound(); // Write data to propertyData compound.setTag(PROP_NAME, propertyData); } @Override public void loadNBTData(NBTTagCompound compound) { if(compound.hasKey(PROP_NAME, Constants.NBT.TAG_COMPOUND)) { NBTTagCompound propertyData = compound.getCompoundTag(PROP_NAME); // Read data from propertyData } } Synchronizing Data with Clients By default, the entity data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situation in which you may want to send synchronization packets, all of them optional: When the entity spawns in the world, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing the network packets. For example: private void dataChanged() { if(!world.isRemote) { EntityTracker tracker = ((WorldServer)world).getEntityTracker(); ExampleEntityPropertySync message = new ExampleEntityPropertySync(this); for (EntityPlayer entityPlayer : tracker.getTrackingPlayers(entity)) { ExampleMod.channel.sendTo(message, (EntityPlayerMP)entityPlayer); } } } private void entitySpawned() { dataChanged(); } private void playerStartedTracking(EntityPlayer entityPlayer) { ExampleMod.channel.sendTo(new ExampleEntityPropertySync(this), (EntityPlayerMP)entityPlayer); } And the corresponding event handlers: @SubscribeEvent public void entityJoinWorld(EntityJoinWorldEvent e) { ExampleEntityProperty data = ExampleEntityProperty.get(e.entity); if (data != null) data.entitySpawned(); } @SubscribeEvent public void playerStartedTracking(PlayerEvent.StartTracking e) { ExampleEntityProperty data = ExampleEntityProperty.get(e.target); if (data != null) data.playerStartedTracking(e.entityPlayer); } Persisting across Player Deaths By default, the entity data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done by handling the PlayerEvent.Clone event. In this event, the wasDead field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist, so care has to be taken to not duplicate values when returning from the End dimension. @SubscribeEvent public void onClonePlayer(PlayerEvent.Clone e) { if(e.wasDeath) { NBTTagCompound compound = new NBTTagCompound(); ExampleEntityProperty.get(e.original).saveNBTData(compound); ExampleEntityProperty.get(e.entityPlayer).loadNBTData(compound); } }","title":"Extended Entity Properties"},{"location":"datastorage/extendedentityproperties/#extended-entity-properties","text":"Extended entity properties allow attaching data to entities. Warning This system has been deprecated in favor of the Capability system.","title":"Extended Entity Properties"},{"location":"datastorage/extendedentityproperties/#declaration-and-registration","text":"The basis of the EEPs is the IExtendedEntityProperties interface. This interface provides the basic methods required for managing the extended data: init : Allows the implementation to have knowledge about the entity it\u2019s attached to, and the world this entity is loaded into. saveNBTData : Allows the implementation to store data in the save file, to be loaded when the entity gets loaded into the world. loadNBTData : Allows the implementation to read the previously saved data for this entity. An implementation will have a class implementing this interface, and instances of this class will be attached to the entities, ready to store any required data. The implementation will need to make use of events in order to attach the IEEP to entities, and optionally any other required features. To help with encapsulation, you may want to create an inner class for handling those events. In the example, I created a register() method to help with that. A basic skeleton to get started: public class ExampleEntityProperty implements IExtendedEntityProperties { public static final String PROP_NAME = ExampleMod.MODID + \"_ExampleEntityData\"; public static void register() { MinecraftForge.EVENT_BUS.register(new Handler()); } // IExtendedEntityProperties methods go here public static class Handler { // Event handlers will go here } }","title":"Declaration and Registration"},{"location":"datastorage/extendedentityproperties/#attaching-the-implementation-to-entities","text":"In order to attach the extended property to an entity, it is done by handling the EntityEvent.EntityConstructing event, and if the entity is of interest, using the Entity#registerExtendedProperties method. In order to uniquely identify your property and avoid duplication, the method takes a string parameter with an identifier for the property. A good practice is to include the modid in this string, so that it will not collide with other mods. Warning If the same property identifier is added twice, Forge will append a number to it, and return this modified identifier from the registerExtendedProperties method. If you don\u2019t want that to happen, you can use Entity#getExtendedProperties to check if an IEEP with that name was already added. In order to handle this event, you could do something like this: @SubscribeEvent public void entityConstruct(EntityEvent.EntityConstructing e) { if (e.entity instanceof EntityPlayer) { if (e.entity.getExtendedProperties(PROP_NAME) == null) { e.entity.registerExtendedProperties(PROP_NAME, new ExampleEntityProperty()); } } }","title":"Attaching the Implementation to Entities"},{"location":"datastorage/extendedentityproperties/#making-use-of-the-implementation","text":"To make use of the extended data, the instance of the IEEP implementation has to be obtained from the Entity, and because the entity could have been unloaded or may have changed dimensions, it is not safe to cache the references. To obtain the IEEP reference, one would use Entity#getExtendedProperties , with the same property ID specified on registration. The return value, if not null , is the instance of IExtendedEntityProperties added during entity construction. A good idea is to create a static get method in your IEEP implementation, that will automatically obtain the instance, and cast it to your implementation class. It can be as simple as: public static ExampleEntityProperty get(Entity p) { return (ExampleEntityProperty) p.getExtendedProperties(PROP_NAME); }","title":"Making Use of the Implementation"},{"location":"datastorage/extendedentityproperties/#saving-and-loading-data-from-nbt","text":"Forge allows all IEEPs attached to an entity to save and load themselves. However, keep in mind that the NBT tag provided in the saveNBTData and loadNBTData methods is a global tag for the entity, and may contain data for other IEEPs, along with all the data from the entity itself. There are some cases where an IEEP may benefit from accessing this global data, but for the most common use cases, it is important to avoid colliding with existing data, preferably by storing the data in a nested tag, using an unique name for it (such as the name used to identify the IEEP). Your code may look a bit like this: @Override public void saveNBTData(NBTTagCompound compound) { NBTTagCompound propertyData = new NBTTagCompound(); // Write data to propertyData compound.setTag(PROP_NAME, propertyData); } @Override public void loadNBTData(NBTTagCompound compound) { if(compound.hasKey(PROP_NAME, Constants.NBT.TAG_COMPOUND)) { NBTTagCompound propertyData = compound.getCompoundTag(PROP_NAME); // Read data from propertyData } }","title":"Saving and Loading Data from NBT"},{"location":"datastorage/extendedentityproperties/#synchronizing-data-with-clients","text":"By default, the entity data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situation in which you may want to send synchronization packets, all of them optional: When the entity spawns in the world, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing the network packets. For example: private void dataChanged() { if(!world.isRemote) { EntityTracker tracker = ((WorldServer)world).getEntityTracker(); ExampleEntityPropertySync message = new ExampleEntityPropertySync(this); for (EntityPlayer entityPlayer : tracker.getTrackingPlayers(entity)) { ExampleMod.channel.sendTo(message, (EntityPlayerMP)entityPlayer); } } } private void entitySpawned() { dataChanged(); } private void playerStartedTracking(EntityPlayer entityPlayer) { ExampleMod.channel.sendTo(new ExampleEntityPropertySync(this), (EntityPlayerMP)entityPlayer); } And the corresponding event handlers: @SubscribeEvent public void entityJoinWorld(EntityJoinWorldEvent e) { ExampleEntityProperty data = ExampleEntityProperty.get(e.entity); if (data != null) data.entitySpawned(); } @SubscribeEvent public void playerStartedTracking(PlayerEvent.StartTracking e) { ExampleEntityProperty data = ExampleEntityProperty.get(e.target); if (data != null) data.playerStartedTracking(e.entityPlayer); }","title":"Synchronizing Data with Clients"},{"location":"datastorage/extendedentityproperties/#persisting-across-player-deaths","text":"By default, the entity data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done by handling the PlayerEvent.Clone event. In this event, the wasDead field can be used to distinguish between respawning after death, and returning from the End. This is important because the data will already exist, so care has to be taken to not duplicate values when returning from the End dimension. @SubscribeEvent public void onClonePlayer(PlayerEvent.Clone e) { if(e.wasDeath) { NBTTagCompound compound = new NBTTagCompound(); ExampleEntityProperty.get(e.original).saveNBTData(compound); ExampleEntityProperty.get(e.entityPlayer).loadNBTData(compound); } }","title":"Persisting across Player Deaths"},{"location":"datastorage/worldsaveddata/","text":"World Saved Data The World Saved Data system allows attaching data to worlds, either per dimension, or global. Declaration The basis of the system is the WorldSavedData class. This class provides the basic methods used to manage the data: writeToNBT : Allows the implementation to write data to the world. readFromNBT : Allows the implementation to load previously saved data. markDirty : This method is not overridden by the implementation. Instead, it must be called after changing the data, to notify Minecraft that there are changes that need to be written. If not called, the existing data will be kept instead, and writeToNBT will not get called. An implementation will override this class, and instances of this implementation will be attached to the World objects, ready to store any required data. A basic skeleton may look like this: public class ExampleWorldSavedData extends WorldSavedData { private static final String DATA_NAME = MODID + \"_ExampleData\"; // Required constructors public ExampleWorldSavedData() { super(DATA_NAME); } public ExampleWorldSavedData(String s) { super(s); } // WorldSavedData methods } Registration and Usage The WorldSavedData is loaded and/or attached to the world on demand. A good practice is to create a static get method that will load the data, and if not present, attach a new instance. There are two ways to attach the data: per dimension, or globally. Global data will be attached to a shared map, that will be obtainable from any instance of the World class, while per-world data will not be shared across dimensions. Keep in mind the separation between client and server, as they get separate instances of global data, so if data is needed on both sides, manual synchronization will be required. In code, these storage locations are represented by two instances of MapStorage present in the World object. The global data is obtained from World#getMapStorage() , while the per-world map is obtained from World#getPerWorldStorage() . The existing data can be obtained using MapStorage#getOrLoadData , and new data can be attached using MapStorage#setData . public static ExampleWorldSavedData get(World world) { // The IS_GLOBAL constant is there for clarity, and should be simplified into the right branch. MapStorage storage = IS_GLOBAL ? world.getMapStorage() : world.getPerWorldStorage(); ExampleWorldSavedData instance = (ExampleWorldSavedData) storage.getOrLoadData(ExampleWorldSavedData.class, DATA_NAME); if (instance == null) { instance = new ExampleWorldSavedData(); storage.setData(DATA_NAME, instance); } return instance; }","title":"World Saved Data"},{"location":"datastorage/worldsaveddata/#world-saved-data","text":"The World Saved Data system allows attaching data to worlds, either per dimension, or global.","title":"World Saved Data"},{"location":"datastorage/worldsaveddata/#declaration","text":"The basis of the system is the WorldSavedData class. This class provides the basic methods used to manage the data: writeToNBT : Allows the implementation to write data to the world. readFromNBT : Allows the implementation to load previously saved data. markDirty : This method is not overridden by the implementation. Instead, it must be called after changing the data, to notify Minecraft that there are changes that need to be written. If not called, the existing data will be kept instead, and writeToNBT will not get called. An implementation will override this class, and instances of this implementation will be attached to the World objects, ready to store any required data. A basic skeleton may look like this: public class ExampleWorldSavedData extends WorldSavedData { private static final String DATA_NAME = MODID + \"_ExampleData\"; // Required constructors public ExampleWorldSavedData() { super(DATA_NAME); } public ExampleWorldSavedData(String s) { super(s); } // WorldSavedData methods }","title":"Declaration"},{"location":"datastorage/worldsaveddata/#registration-and-usage","text":"The WorldSavedData is loaded and/or attached to the world on demand. A good practice is to create a static get method that will load the data, and if not present, attach a new instance. There are two ways to attach the data: per dimension, or globally. Global data will be attached to a shared map, that will be obtainable from any instance of the World class, while per-world data will not be shared across dimensions. Keep in mind the separation between client and server, as they get separate instances of global data, so if data is needed on both sides, manual synchronization will be required. In code, these storage locations are represented by two instances of MapStorage present in the World object. The global data is obtained from World#getMapStorage() , while the per-world map is obtained from World#getPerWorldStorage() . The existing data can be obtained using MapStorage#getOrLoadData , and new data can be attached using MapStorage#setData . public static ExampleWorldSavedData get(World world) { // The IS_GLOBAL constant is there for clarity, and should be simplified into the right branch. MapStorage storage = IS_GLOBAL ? world.getMapStorage() : world.getPerWorldStorage(); ExampleWorldSavedData instance = (ExampleWorldSavedData) storage.getOrLoadData(ExampleWorldSavedData.class, DATA_NAME); if (instance == null) { instance = new ExampleWorldSavedData(); storage.setData(DATA_NAME, instance); } return instance; }","title":"Registration and Usage"},{"location":"effects/sounds/","text":"Sounds Terminology Term Description Sound Events Something that triggers a sound effect. Examples include \"minecraft:block.anvil.hit\" or \"botania:spreaderFire\" . Sound Category The category of the sound, for example \"player\" , \"block\" or simply \"master\" . The sliders in the sound settings GUI represent these categories. Sound File The literal file on disk that is played, usually an .ogg file. sounds.json This JSON defines sound events, and defines which sound files they play, the subtitle, etc. Sound events are identified with ResourceLocation s. sounds.json should be located at the root of a resource namespace ( assets/<namespace>/sounds.json ), and it defines sound events in that namespace ( assets/<namespace>/sounds.json defines sound events in the namespace namespace .). A full specification is available on the vanilla wiki , but this example highlights the important parts: { \"open_chest\": { \"category\": \"block\", \"subtitle\": \"mymod.subtitle.openChest\", \"sounds\": [ \"mymod:open_chest_sound_file\" ] }, \"epic_music\": { \"category\": \"record\", \"sounds\": [ { \"name\": \"mymod:music/epic_music\", \"stream\": true } ] } } Underneath the top-level object, each key corresponds to a sound event. Note that the namespace is not given, as it is taken from the namespace of the JSON itself. Each event specifies its category, and a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified then the game will randomly choose one to play whenever the sound event is triggered. The two examples represent two different ways to specify a sound file. The wiki has precise details, but generally, long sound files such as BGM or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but to stream it from disk. The second form can also specify the volume, pitch, and random weight of a sound file. In all cases, the path to a sound file for namespace namespace and path path is assets/<namespace>/sounds/<path>.ogg . Therefore mymod:open_chest_sound_file points to assets/mymod/sounds/open_chest_sound_file.ogg , and mymod:music/epic_music points to assets/mymod/sounds/music/epic_music.ogg . Creating Sound Events In order to actually be able to play sounds, a SoundEvent corresponding to an entry in sounds.json must be created. This SoundEvent must then be registered . Normally, the location used to create a sound event should be set as it\u2019s registry name. Creating a SoundEvent : ResourceLocation location = new ResourceLocation(\"mymod\", \"open_chest\"); SoundEvent event = new SoundEvent(location); The SoundEvent acts as a reference to the sound, and is passed around to actually play sounds. Therefore, the SoundEvent should be stored somewhere. If a mod has an API, it should expose its SoundEvent s in the API. Playing Sounds Vanilla has lots of methods for playing sounds, and it\u2019s unclear which to use at times. Note This information was gathered by looking at these various methods, analyzing their usage and categorizing them accordingly. It is up-to-date as of Forge 1907, please let someone know if it is out of date! Note that each takes a SoundEvent , the ones registered above. Additionally, the terms \u201cServer Behavior\u201d and \u201cClient Behavior\u201d refer to the respective logical side . World playSound(EntityPlayer, BlockPos, SoundEvent, SoundCategory, volume, pitch) Simply forwards to overload (2) , adding 0.5 to each coordinate of the BlockPos given. playSound(EntityPlayer, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch) Client Behavior : If the passed in player is the client player, plays the sound event to the client player. Server Behavior : Plays the sound event to everyone nearby except the passed in player. Player can be null . Usage : The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time - the logical client handles playing it to the user and the logical server handles everyone else hearing it without re-playing it to the original user. They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a null player, thus letting everyone hear it. playSound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Client Behavior : Just plays the sound event in the client world. If distanceDelay is true , then delays the sound based on how far it is from the player. Server Behavior : Does nothing. Usage : This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder. WorldClient playSound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Simply forwards to World \u2018s overload (3) , adding 0.5 to each coordinate of the BlockPos given. Entity playSound(SoundEvent, volume, pitch) Forwards to World \u2018s overload (2) , passing in null as the player. Client Behavior : Does nothing. Server Behavior : Plays the sound event to everyone at this entity\u2019s position. Usage : Emitting any sound from any non-player entity server-side. EntityPlayer playSound(SoundEvent, volume, pitch) (overriding the one in Entity ) Forwards to World \u2018s overload (2) , passing in this as the player. Client Behavior : Does nothing, see override in EntityPlayerSP . Server Behavior : Plays the sound to everyone nearby except this player. Usage : See EntityPlayerSP . EntityPlayerSP playSound(SoundEvent, volume, pitch) (overriding the one in EntityPlayer ) Forwards to World \u2018s overload (2) , passing in this as the player. Client Behavior : Just plays the Sound Event. Server Behavior : Method is client-only. Usage : Just like the ones in World , these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.","title":"Sounds"},{"location":"effects/sounds/#sounds","text":"","title":"Sounds"},{"location":"effects/sounds/#terminology","text":"Term Description Sound Events Something that triggers a sound effect. Examples include \"minecraft:block.anvil.hit\" or \"botania:spreaderFire\" . Sound Category The category of the sound, for example \"player\" , \"block\" or simply \"master\" . The sliders in the sound settings GUI represent these categories. Sound File The literal file on disk that is played, usually an .ogg file.","title":"Terminology"},{"location":"effects/sounds/#soundsjson","text":"This JSON defines sound events, and defines which sound files they play, the subtitle, etc. Sound events are identified with ResourceLocation s. sounds.json should be located at the root of a resource namespace ( assets/<namespace>/sounds.json ), and it defines sound events in that namespace ( assets/<namespace>/sounds.json defines sound events in the namespace namespace .). A full specification is available on the vanilla wiki , but this example highlights the important parts: { \"open_chest\": { \"category\": \"block\", \"subtitle\": \"mymod.subtitle.openChest\", \"sounds\": [ \"mymod:open_chest_sound_file\" ] }, \"epic_music\": { \"category\": \"record\", \"sounds\": [ { \"name\": \"mymod:music/epic_music\", \"stream\": true } ] } } Underneath the top-level object, each key corresponds to a sound event. Note that the namespace is not given, as it is taken from the namespace of the JSON itself. Each event specifies its category, and a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified then the game will randomly choose one to play whenever the sound event is triggered. The two examples represent two different ways to specify a sound file. The wiki has precise details, but generally, long sound files such as BGM or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but to stream it from disk. The second form can also specify the volume, pitch, and random weight of a sound file. In all cases, the path to a sound file for namespace namespace and path path is assets/<namespace>/sounds/<path>.ogg . Therefore mymod:open_chest_sound_file points to assets/mymod/sounds/open_chest_sound_file.ogg , and mymod:music/epic_music points to assets/mymod/sounds/music/epic_music.ogg .","title":"sounds.json"},{"location":"effects/sounds/#creating-sound-events","text":"In order to actually be able to play sounds, a SoundEvent corresponding to an entry in sounds.json must be created. This SoundEvent must then be registered . Normally, the location used to create a sound event should be set as it\u2019s registry name. Creating a SoundEvent : ResourceLocation location = new ResourceLocation(\"mymod\", \"open_chest\"); SoundEvent event = new SoundEvent(location); The SoundEvent acts as a reference to the sound, and is passed around to actually play sounds. Therefore, the SoundEvent should be stored somewhere. If a mod has an API, it should expose its SoundEvent s in the API.","title":"Creating Sound Events"},{"location":"effects/sounds/#playing-sounds","text":"Vanilla has lots of methods for playing sounds, and it\u2019s unclear which to use at times. Note This information was gathered by looking at these various methods, analyzing their usage and categorizing them accordingly. It is up-to-date as of Forge 1907, please let someone know if it is out of date! Note that each takes a SoundEvent , the ones registered above. Additionally, the terms \u201cServer Behavior\u201d and \u201cClient Behavior\u201d refer to the respective logical side .","title":"Playing Sounds"},{"location":"effects/sounds/#world","text":"playSound(EntityPlayer, BlockPos, SoundEvent, SoundCategory, volume, pitch) Simply forwards to overload (2) , adding 0.5 to each coordinate of the BlockPos given. playSound(EntityPlayer, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch) Client Behavior : If the passed in player is the client player, plays the sound event to the client player. Server Behavior : Plays the sound event to everyone nearby except the passed in player. Player can be null . Usage : The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time - the logical client handles playing it to the user and the logical server handles everyone else hearing it without re-playing it to the original user. They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a null player, thus letting everyone hear it. playSound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Client Behavior : Just plays the sound event in the client world. If distanceDelay is true , then delays the sound based on how far it is from the player. Server Behavior : Does nothing. Usage : This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder.","title":"World"},{"location":"effects/sounds/#worldclient","text":"playSound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Simply forwards to World \u2018s overload (3) , adding 0.5 to each coordinate of the BlockPos given.","title":"WorldClient"},{"location":"effects/sounds/#entity","text":"playSound(SoundEvent, volume, pitch) Forwards to World \u2018s overload (2) , passing in null as the player. Client Behavior : Does nothing. Server Behavior : Plays the sound event to everyone at this entity\u2019s position. Usage : Emitting any sound from any non-player entity server-side.","title":"Entity"},{"location":"effects/sounds/#entityplayer","text":"playSound(SoundEvent, volume, pitch) (overriding the one in Entity ) Forwards to World \u2018s overload (2) , passing in this as the player. Client Behavior : Does nothing, see override in EntityPlayerSP . Server Behavior : Plays the sound to everyone nearby except this player. Usage : See EntityPlayerSP .","title":"EntityPlayer"},{"location":"effects/sounds/#entityplayersp","text":"playSound(SoundEvent, volume, pitch) (overriding the one in EntityPlayer ) Forwards to World \u2018s overload (2) , passing in this as the player. Client Behavior : Just plays the Sound Event. Server Behavior : Method is client-only. Usage : Just like the ones in World , these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.","title":"EntityPlayerSP"},{"location":"events/intro/","text":"Events Forge uses an event bus that allows mods to intercept events from various vanilla and mod behaviors. Example: An event can be used to perform an action when a Vanilla stick is right clicked. The main event bus used for most events is located at MinecraftForge.EVENT_BUS . An event handler is a class that contains one or more public void member methods that are marked with the @SubscribeEvent annotation. Creating an Event Handler public class MyForgeEventHandler { @SubscribeEvent public void pickupItem(EntityItemPickupEvent event) { System.out.println(\"Item picked up!\"); } } This event handler listens for the EntityItemPickupEvent , which is, as the name states, posted to the event bus whenever an Entity picks up an item. To register this event handler, use MinecraftForge.EVENT_BUS.register() and pass it an instance of your event handler class. Static Event Handlers An event handler may also be static. The handling method is still annotated with @SubscribeEvent and the only difference from an instance handler is that it is also marked static . In order to register a static event handler, an instance of the class won\u2019t do, the Class itself has to be passed in. An example: public class MyStaticForgeEventHandler { @SubscribeEvent public static void arrowNocked(ArrowNockEvent event) { System.out.println(\"Arrow nocked!\"); } } which must be registered like this: MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class) . Automatically Registering Static Event Handlers A class may be annotated with the @Mod.EventBusSubscriber annotation. Such a class is automatically registered to MinecraftForge.EVENT_BUS when the @Mod class itself is constructed. This is essentially equivalent to adding MinecraftForge.EVENT_BUS.register(AnnotatedClass.class); at the end of the @Mod class\u2019s constructor. Note This does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static). Canceling If an event can be canceled, it will be marked with the @Cancelable annotation, and the method Event#isCancelable() will return true . The cancel state of a cancelable event may be modified by calling Event#setCanceled(boolean canceled) , wherin passing the boolean value true is interpreted as canceling the event, and passing the boolean value false is interpreted as \u201cun-canceling\u201d the event. However, if the event cannot be canceled (as defined by Event#isCancelable() ), an UnsupportedOperationException will be thrown regardless of the passed boolean value, since the cancel state of a non-cancelable event event is considered immutable. Important Not all events can be canceled! Attempting to cancel an event that is not cancelable will result in an unchecked UnsupportedOperationException being thrown, which is expected to result in the game crashing! Always check that an event can be canceled using Event#isCancelable() before attempting to cancel it! Results Some events have an Event.Result , a result can be one of three things, DENY which stops the event, DEFAULT which uses the Vanilla behavior, and ALLOW which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling setResult with an Event.Result on the event. Not all events have results, an event with a result will be annotated with @HasResult . Important Different events may use results in different ways, refer to the event\u2019s JavaDoc before using the result. Priority Event handler methods (marked with @SubscribeEvent ) have a priority. You can set the priority of an event handler method by setting the priority value of the annotation. The priority can be any value of the EventPriority enum ( HIGHEST , HIGH , NORMAL , LOW , and LOWEST ). Event handlers with priority HIGHEST are executed first and from there in descending order until LOWEST events which are executed last. Sub Events Many events have different variations of themselves, these can be different but all based around one common factor (e.g. PlayerEvent ) or can be an event that has multiple phases (e.g. PotionBrewEvent ). Take note that if you listen to the parent event class, you will receive calls to your method for all subclasses.","title":"Basic Usage"},{"location":"events/intro/#events","text":"Forge uses an event bus that allows mods to intercept events from various vanilla and mod behaviors. Example: An event can be used to perform an action when a Vanilla stick is right clicked. The main event bus used for most events is located at MinecraftForge.EVENT_BUS . An event handler is a class that contains one or more public void member methods that are marked with the @SubscribeEvent annotation.","title":"Events"},{"location":"events/intro/#creating-an-event-handler","text":"public class MyForgeEventHandler { @SubscribeEvent public void pickupItem(EntityItemPickupEvent event) { System.out.println(\"Item picked up!\"); } } This event handler listens for the EntityItemPickupEvent , which is, as the name states, posted to the event bus whenever an Entity picks up an item. To register this event handler, use MinecraftForge.EVENT_BUS.register() and pass it an instance of your event handler class.","title":"Creating an Event Handler"},{"location":"events/intro/#static-event-handlers","text":"An event handler may also be static. The handling method is still annotated with @SubscribeEvent and the only difference from an instance handler is that it is also marked static . In order to register a static event handler, an instance of the class won\u2019t do, the Class itself has to be passed in. An example: public class MyStaticForgeEventHandler { @SubscribeEvent public static void arrowNocked(ArrowNockEvent event) { System.out.println(\"Arrow nocked!\"); } } which must be registered like this: MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class) .","title":"Static Event Handlers"},{"location":"events/intro/#automatically-registering-static-event-handlers","text":"A class may be annotated with the @Mod.EventBusSubscriber annotation. Such a class is automatically registered to MinecraftForge.EVENT_BUS when the @Mod class itself is constructed. This is essentially equivalent to adding MinecraftForge.EVENT_BUS.register(AnnotatedClass.class); at the end of the @Mod class\u2019s constructor. Note This does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static).","title":"Automatically Registering Static Event Handlers"},{"location":"events/intro/#canceling","text":"If an event can be canceled, it will be marked with the @Cancelable annotation, and the method Event#isCancelable() will return true . The cancel state of a cancelable event may be modified by calling Event#setCanceled(boolean canceled) , wherin passing the boolean value true is interpreted as canceling the event, and passing the boolean value false is interpreted as \u201cun-canceling\u201d the event. However, if the event cannot be canceled (as defined by Event#isCancelable() ), an UnsupportedOperationException will be thrown regardless of the passed boolean value, since the cancel state of a non-cancelable event event is considered immutable. Important Not all events can be canceled! Attempting to cancel an event that is not cancelable will result in an unchecked UnsupportedOperationException being thrown, which is expected to result in the game crashing! Always check that an event can be canceled using Event#isCancelable() before attempting to cancel it!","title":"Canceling"},{"location":"events/intro/#results","text":"Some events have an Event.Result , a result can be one of three things, DENY which stops the event, DEFAULT which uses the Vanilla behavior, and ALLOW which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling setResult with an Event.Result on the event. Not all events have results, an event with a result will be annotated with @HasResult . Important Different events may use results in different ways, refer to the event\u2019s JavaDoc before using the result.","title":"Results"},{"location":"events/intro/#priority","text":"Event handler methods (marked with @SubscribeEvent ) have a priority. You can set the priority of an event handler method by setting the priority value of the annotation. The priority can be any value of the EventPriority enum ( HIGHEST , HIGH , NORMAL , LOW , and LOWEST ). Event handlers with priority HIGHEST are executed first and from there in descending order until LOWEST events which are executed last.","title":"Priority"},{"location":"events/intro/#sub-events","text":"Many events have different variations of themselves, these can be different but all based around one common factor (e.g. PlayerEvent ) or can be an event that has multiple phases (e.g. PotionBrewEvent ). Take note that if you listen to the parent event class, you will receive calls to your method for all subclasses.","title":"Sub Events"},{"location":"forgedev/","text":"Getting Started If you\u2019ve decided to contribute to Forge, you\u2019ll have to take some special steps to get started with developing. A simple mod development environment won\u2019t suffice to work with Forge\u2019s codebase directly. Instead, you can use the following guide to help you with your setup and get you started with improving Forge! Forking and Cloning the Repository Like most major open source projects you\u2019ll find, Forge is hosted on GitHub . If you\u2019ve contributed to another project before, you\u2019ll know this process already and you can skip right ahead to the next section. For those who are beginners when it comes to collaboration via Git, here are only two easy to steps to get you started. Note This guide assumes that you already have a GitHub account set up. If you don\u2019t, visit their registration page to create an account. Furthermore, this guide is not a tutorial for git\u2019s usage, please consult different sources first if you\u2019re struggling with getting it working. Forking First of all, you have to \u201cfork\u201d the MinecraftForge repository by clicking the \u201cFork\u201d button in the upper right hand corner. If you are in an organization, select the account you want your fork to be hosted on. Forking the repository is necessary since not every GitHub user can have free access to every repository. Instead, you create a copy of the original repository to later contribute your changes via a so called Pull Request, which you will learn more about later. Cloning After forking the repository, it is time to get local access to it and to actually make some changes. For this, you need to clone the repository onto your local machine. Using your favourite git client, simply clone your fork into a directory of your choice. As general example, here is a command line snippet that should work on all correctly configured systems and clones the repository into a directory called \u201cForge\u201d under the current directory (note that you have to replace <User> with your username): git clone https://github.com/<User>/MinecraftForge Forge Checking out the Correct Branch Forking and cloning the repository are the only mandatory steps to develop for Forge. However, to ease the process of creating Pull Requests for you, it is best to work with branches. It is recommended to create and check out a branch for each PR you plan to submit. This way, you can always keep around the latest changes of Forge for new PRs while you still work on older patches. After completing this step, you\u2019re ready to go and set up your development environment. Setting Up the Environment Depending on your favourite IDE, there is a different set of recommended steps you have to follow to successfully set up a development environment. Eclipse Due to the way eclipse workspaces work, ForgeGradle can do most of the work involved in getting you started with a Forge workspace for you. Open a terminal/command prompt and navigate it to the directory of your cloned fork. Type ./gradlew setup and hit enter. Wait until ForgeGradle is done. Open your eclipse workspace and go to File -> Import -> General -> Existing Projects into workspace . Browse to the <repo>/projects/ directory for the root directory in the dialog that opens. Make sure both \u201cForge\u201d and \u201cClean\u201d are checked and adjust the other settings to your liking. Complete the import by clicking the \u201cFinish\u201d button. That\u2019s all it takes to get you up and running with Eclipse, there\u2019s no extra steps required to get test mods running. Simply hit Run like in any other project and select the appropriate run configuration. IntelliJ IDEA JetBrains\u2019 flagship IDE comes with great integrated support for Gradle , Forge\u2019s build system of choice. Due to some peculiarities of Minecraft mod development, however, there are additional steps required to get everything to work properly. If you\u2019re more of a visual person, cpw has uploaded a video explaining very similar steps which will also lead to a working setup. Note These steps will only work reliably from IDEA version 2016 onwards. Older versions didn\u2019t have the appropriate Gradle support and did not support Forge development workspaces. Import Forge\u2019s build.gradle as an IDEA project. For this, simply click File -> Open , then navigate to your fork\u2019s clone and select the build.gradle file. If a dialog pops up, select \u201cOpen as Project\u201d. In the wizard that follows, make sure that \u201cCreate separate module per source set\u201d is checked and that the \u201cUse default gradle wrapper\u201d option is active. Confirm the dialog. After IDEA is done importing the project and indexing the files, open the Gradle sidebar on the right hand side of your screen Open the \u201cforge\u201d project tree, select \u201cTasks\u201d, then \u201cforgegradle\u201d and right click the \u201cCreate Forge [setup]\u201d option Once the configuration dialog shows up, edit the \u201ctasks\u201d field to contain clean setup and add -Xmx3G -Xms3G to \u201cVM Options\u201d. The latter option ensures that the resource intensive decompilation process has enough memory. Click \u201cOkay\u201d and run your newly created run configuration. This may take a while. After the setup task has completed, go once again to the Gradle sidebar and click the \u201cAttach Gradle project\u201d button (the plus icon) at the top Navigate to your clone\u2019s directory, then open the projects directory and double click the build.gradle file in there. Select \u201cUse gradle wrapper task configuration\u201d in the following dialog and confirm it. Import all modules IDEA suggests To get access to the project\u2019s run configurations, open the projects directory in your file explorer and navigate to the .idea directory (might be hidden depending on your system). Copy the runConfigurations directory into .idea under your fork\u2019s root directory Once IDEA recognizes the added configurations, complete the following steps for each one Change the configuration\u2019s module to <Config>_main where <Config> is the first part of the configuration\u2019s name Change the run directory to <clone>/projects/run That\u2019s all there is to creating a Forge development environment in IntelliJ IDEA. However, you won\u2019t be able to run the tests and debug mods included in Forge straight away. This takes some extra effort. Enabling test mods To enable the test mods coming with Forge, you will need to add the compiler output to the classpath. Again, cpw has put up a video explaining these steps. Build the test classes by selecting the src/main/test directory in your project view and then run Build -> Build module 'Forge_test' from the menu bar. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and expand the Forge module. Select the Forge_test submodule and head to the \u201cPaths\u201d tab. Remember the path listed under the \u201cTest output path\u201d label and select the Forge_main submodule from the tree. Open the \u201cDependencies\u201d tab, hit the green plus button on the right-hand side and select \u201cJARs or directories\u201d. Navigate to the path previously displayed as the Forge_test output path and confirm your selection. For the \u201cScope\u201d of this newly added dependency (currently \u201cCompile\u201d) choose \u201cRuntime\u201d, since the main code doesn\u2019t rely on the test code for compilation. Now that you\u2019ve added the test mods to the classpath, you need to rebuild them each time you make a change as they will not be built automatically. To do so, repeat step 1 from the above list or, in case you make changes to a single test mod file and want them to get rebuild, simply hit Build -> Rebuild project or the corresponding keyboard shortcut ( CTRL + F9 by default). Testing with existing mods You might want to test changes in Forge with an existing project. The video by cpw linked in the test mods section also covers this. Getting the mod to run requires similar steps to the test mod, but getting your project added to the workspace requires some additional work. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and press the green plus icon above the tree view. Select \u201cImport Module\u201d, navigate to your project\u2019s build.gradle file and confirm your selection as well as the import settings. Close the \u201cProject Structure\u201d window by clicking the \u201cOK\u201d button. Reopen the window after IDEA is done importing the project and select your project\u2019s _main module from the tree. Open the \u201cDependencies\u201d tab, click the green plus icon on the right-hand side and select \u201cModule dependency\u201d. In the window that just opened, select the Forge_main module. From here on, reproduce the steps from the test mods section, just with your project\u2019s _main module instead of the Forge_test one. Note You might need to remove existing dependencies from a normal development environment (mainly references to a forgeSrc JAR) or move the Forge module higher up in the dependency list. You should now be able to work with your mod using the changes you introduce to the Forge and Vanilla codebase. Making Changes and Pull Requests Once you\u2019ve set up your development environment, it\u2019s time to make some changes to Forge\u2019s codebase. There are, however, some pitfalls you have to avoid when editing the project\u2019s code. The most important thing to note is that if you wish to edit Minecraft source code, you must only do so in the \u201cForge\u201d sub-project. Any changes in the \u201cClean\u201d project will mess with ForgeGradle and generating the patches. This can have disastrous consequences and might render your environment completely useless. If you wish to have a flawless experience, make sure you only edit code in the \u201cForge\u201d project! Generating Patches After you\u2019ve made changes to the code base and once you\u2019ve tested them thoroughly, you may go ahead and generate patches. This is only necessary if you work on the Minecraft code base (i.e. in the \u201cForge\u201d project), but this step is vital for your changes to work elsewhere. Forge works by injecting only changed things into Vanilla Minecraft and hence needs those changes available in an appopriate format. Thankfully, ForgeGradle is capable of generating the changeset for you and all you have to do is commit it. To initiate the patch generation, simply run the genPatches Gradle task from your IDE or the command line. After its completion, you can commit all your changes (make sure you do not add any unnecessary files) and submit your Pull Request! Pull Requests The last step before your contribution is added to Forge is a Pull Request (PR in short). This is a formal request to incorporate your fork\u2019s changes into the live code base. Creating a PR is easy, simply go to this GitHub page and follow the proposed steps. It is now that a good setup with branches pays off, since you\u2019re able to select precisely the changes you want to submit. Note Pull Requests are bound to rules, not every request will blindly be accepted. Follow this document to get further information and to ensure the best quality of your PR! If you want to maximize the chances of your PR getting accepted, follow these PR guidelines !","title":"Getting Started"},{"location":"forgedev/#getting-started","text":"If you\u2019ve decided to contribute to Forge, you\u2019ll have to take some special steps to get started with developing. A simple mod development environment won\u2019t suffice to work with Forge\u2019s codebase directly. Instead, you can use the following guide to help you with your setup and get you started with improving Forge!","title":"Getting Started"},{"location":"forgedev/#forking-and-cloning-the-repository","text":"Like most major open source projects you\u2019ll find, Forge is hosted on GitHub . If you\u2019ve contributed to another project before, you\u2019ll know this process already and you can skip right ahead to the next section. For those who are beginners when it comes to collaboration via Git, here are only two easy to steps to get you started. Note This guide assumes that you already have a GitHub account set up. If you don\u2019t, visit their registration page to create an account. Furthermore, this guide is not a tutorial for git\u2019s usage, please consult different sources first if you\u2019re struggling with getting it working.","title":"Forking and Cloning the Repository"},{"location":"forgedev/#forking","text":"First of all, you have to \u201cfork\u201d the MinecraftForge repository by clicking the \u201cFork\u201d button in the upper right hand corner. If you are in an organization, select the account you want your fork to be hosted on. Forking the repository is necessary since not every GitHub user can have free access to every repository. Instead, you create a copy of the original repository to later contribute your changes via a so called Pull Request, which you will learn more about later.","title":"Forking"},{"location":"forgedev/#cloning","text":"After forking the repository, it is time to get local access to it and to actually make some changes. For this, you need to clone the repository onto your local machine. Using your favourite git client, simply clone your fork into a directory of your choice. As general example, here is a command line snippet that should work on all correctly configured systems and clones the repository into a directory called \u201cForge\u201d under the current directory (note that you have to replace <User> with your username): git clone https://github.com/<User>/MinecraftForge Forge","title":"Cloning"},{"location":"forgedev/#checking-out-the-correct-branch","text":"Forking and cloning the repository are the only mandatory steps to develop for Forge. However, to ease the process of creating Pull Requests for you, it is best to work with branches. It is recommended to create and check out a branch for each PR you plan to submit. This way, you can always keep around the latest changes of Forge for new PRs while you still work on older patches. After completing this step, you\u2019re ready to go and set up your development environment.","title":"Checking out the Correct Branch"},{"location":"forgedev/#setting-up-the-environment","text":"Depending on your favourite IDE, there is a different set of recommended steps you have to follow to successfully set up a development environment.","title":"Setting Up the Environment"},{"location":"forgedev/#eclipse","text":"Due to the way eclipse workspaces work, ForgeGradle can do most of the work involved in getting you started with a Forge workspace for you. Open a terminal/command prompt and navigate it to the directory of your cloned fork. Type ./gradlew setup and hit enter. Wait until ForgeGradle is done. Open your eclipse workspace and go to File -> Import -> General -> Existing Projects into workspace . Browse to the <repo>/projects/ directory for the root directory in the dialog that opens. Make sure both \u201cForge\u201d and \u201cClean\u201d are checked and adjust the other settings to your liking. Complete the import by clicking the \u201cFinish\u201d button. That\u2019s all it takes to get you up and running with Eclipse, there\u2019s no extra steps required to get test mods running. Simply hit Run like in any other project and select the appropriate run configuration.","title":"Eclipse"},{"location":"forgedev/#intellij-idea","text":"JetBrains\u2019 flagship IDE comes with great integrated support for Gradle , Forge\u2019s build system of choice. Due to some peculiarities of Minecraft mod development, however, there are additional steps required to get everything to work properly. If you\u2019re more of a visual person, cpw has uploaded a video explaining very similar steps which will also lead to a working setup. Note These steps will only work reliably from IDEA version 2016 onwards. Older versions didn\u2019t have the appropriate Gradle support and did not support Forge development workspaces. Import Forge\u2019s build.gradle as an IDEA project. For this, simply click File -> Open , then navigate to your fork\u2019s clone and select the build.gradle file. If a dialog pops up, select \u201cOpen as Project\u201d. In the wizard that follows, make sure that \u201cCreate separate module per source set\u201d is checked and that the \u201cUse default gradle wrapper\u201d option is active. Confirm the dialog. After IDEA is done importing the project and indexing the files, open the Gradle sidebar on the right hand side of your screen Open the \u201cforge\u201d project tree, select \u201cTasks\u201d, then \u201cforgegradle\u201d and right click the \u201cCreate Forge [setup]\u201d option Once the configuration dialog shows up, edit the \u201ctasks\u201d field to contain clean setup and add -Xmx3G -Xms3G to \u201cVM Options\u201d. The latter option ensures that the resource intensive decompilation process has enough memory. Click \u201cOkay\u201d and run your newly created run configuration. This may take a while. After the setup task has completed, go once again to the Gradle sidebar and click the \u201cAttach Gradle project\u201d button (the plus icon) at the top Navigate to your clone\u2019s directory, then open the projects directory and double click the build.gradle file in there. Select \u201cUse gradle wrapper task configuration\u201d in the following dialog and confirm it. Import all modules IDEA suggests To get access to the project\u2019s run configurations, open the projects directory in your file explorer and navigate to the .idea directory (might be hidden depending on your system). Copy the runConfigurations directory into .idea under your fork\u2019s root directory Once IDEA recognizes the added configurations, complete the following steps for each one Change the configuration\u2019s module to <Config>_main where <Config> is the first part of the configuration\u2019s name Change the run directory to <clone>/projects/run That\u2019s all there is to creating a Forge development environment in IntelliJ IDEA. However, you won\u2019t be able to run the tests and debug mods included in Forge straight away. This takes some extra effort.","title":"IntelliJ IDEA"},{"location":"forgedev/#enabling-test-mods","text":"To enable the test mods coming with Forge, you will need to add the compiler output to the classpath. Again, cpw has put up a video explaining these steps. Build the test classes by selecting the src/main/test directory in your project view and then run Build -> Build module 'Forge_test' from the menu bar. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and expand the Forge module. Select the Forge_test submodule and head to the \u201cPaths\u201d tab. Remember the path listed under the \u201cTest output path\u201d label and select the Forge_main submodule from the tree. Open the \u201cDependencies\u201d tab, hit the green plus button on the right-hand side and select \u201cJARs or directories\u201d. Navigate to the path previously displayed as the Forge_test output path and confirm your selection. For the \u201cScope\u201d of this newly added dependency (currently \u201cCompile\u201d) choose \u201cRuntime\u201d, since the main code doesn\u2019t rely on the test code for compilation. Now that you\u2019ve added the test mods to the classpath, you need to rebuild them each time you make a change as they will not be built automatically. To do so, repeat step 1 from the above list or, in case you make changes to a single test mod file and want them to get rebuild, simply hit Build -> Rebuild project or the corresponding keyboard shortcut ( CTRL + F9 by default).","title":"Enabling test mods"},{"location":"forgedev/#testing-with-existing-mods","text":"You might want to test changes in Forge with an existing project. The video by cpw linked in the test mods section also covers this. Getting the mod to run requires similar steps to the test mod, but getting your project added to the workspace requires some additional work. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and press the green plus icon above the tree view. Select \u201cImport Module\u201d, navigate to your project\u2019s build.gradle file and confirm your selection as well as the import settings. Close the \u201cProject Structure\u201d window by clicking the \u201cOK\u201d button. Reopen the window after IDEA is done importing the project and select your project\u2019s _main module from the tree. Open the \u201cDependencies\u201d tab, click the green plus icon on the right-hand side and select \u201cModule dependency\u201d. In the window that just opened, select the Forge_main module. From here on, reproduce the steps from the test mods section, just with your project\u2019s _main module instead of the Forge_test one. Note You might need to remove existing dependencies from a normal development environment (mainly references to a forgeSrc JAR) or move the Forge module higher up in the dependency list. You should now be able to work with your mod using the changes you introduce to the Forge and Vanilla codebase.","title":"Testing with existing mods"},{"location":"forgedev/#making-changes-and-pull-requests","text":"Once you\u2019ve set up your development environment, it\u2019s time to make some changes to Forge\u2019s codebase. There are, however, some pitfalls you have to avoid when editing the project\u2019s code. The most important thing to note is that if you wish to edit Minecraft source code, you must only do so in the \u201cForge\u201d sub-project. Any changes in the \u201cClean\u201d project will mess with ForgeGradle and generating the patches. This can have disastrous consequences and might render your environment completely useless. If you wish to have a flawless experience, make sure you only edit code in the \u201cForge\u201d project!","title":"Making Changes and Pull Requests"},{"location":"forgedev/#generating-patches","text":"After you\u2019ve made changes to the code base and once you\u2019ve tested them thoroughly, you may go ahead and generate patches. This is only necessary if you work on the Minecraft code base (i.e. in the \u201cForge\u201d project), but this step is vital for your changes to work elsewhere. Forge works by injecting only changed things into Vanilla Minecraft and hence needs those changes available in an appopriate format. Thankfully, ForgeGradle is capable of generating the changeset for you and all you have to do is commit it. To initiate the patch generation, simply run the genPatches Gradle task from your IDE or the command line. After its completion, you can commit all your changes (make sure you do not add any unnecessary files) and submit your Pull Request!","title":"Generating Patches"},{"location":"forgedev/#pull-requests","text":"The last step before your contribution is added to Forge is a Pull Request (PR in short). This is a formal request to incorporate your fork\u2019s changes into the live code base. Creating a PR is easy, simply go to this GitHub page and follow the proposed steps. It is now that a good setup with branches pays off, since you\u2019re able to select precisely the changes you want to submit. Note Pull Requests are bound to rules, not every request will blindly be accepted. Follow this document to get further information and to ensure the best quality of your PR! If you want to maximize the chances of your PR getting accepted, follow these PR guidelines !","title":"Pull Requests"},{"location":"forgedev/prguidelines/","text":"Pull Request Guidelines Mods are built on top of Forge, but there are some things that Forge doesn\u2019t support, and that limits what mods can do. When modders run into something like that, they can make a change to Forge to support it, and submit that change as a Pull Request on Github. To make the best use of both your and the Forge team\u2019s time, it is recommended to follow some rough guidelines when preparing a Pull Request. The following points are the most important aspects to keep in mind when it comes to writing a good Pull Request. What Exactly is Forge? At a high level, Forge is a mod compatibility layer on top of Minecraft. Early mods edited Minecraft\u2019s code directly (like coremods do now), but ran into conflicts with each other when they edited the same things. They also ran into issues when one mod changed behavior in ways that the other mods could not anticipate (like coremods do now), causing mysterious issues and lots of headaches. By using something like Forge, mods can centralize common changes and avoid conflicts. Forge also includes supporting structures for common mod features like Capabilities, Registries, Fluid handling, the Ore Dictionary, and others that allow mods to work together better. When writing a good Forge Pull Request, you also have to know what Forge is at a lower level. There are two main types of code in Forge: Minecraft patches, and Forge code. Patches Patches are applied as direct changes to Minecraft\u2019s source code, and aim to be as minimal as possible. Every time Minecraft code changes, all the Forge patches need to be looked over carefully and applied correctly to the new code. This means that large patches that change lots of things are difficult to maintain, so Forge aims to avoid those and keep patches as small as possible. In addition to making sure the code makes sense, reviews for patches will focus on minimizing the size. There are many strategies to make small patches, and reviews will often point out better methods to do things. Forge patches often insert a single line that fires an event or a code hook, which affects the code after it if the event meets some condition. This allows most of the code to exist outside of the patch, which keeps the patch small and simple. For more detailed information about creating patches, see the GitHub wiki . Forge Code Aside from the patches, Forge code is just normal Java code. It can be event code, compatibility features, or anything else that\u2019s not directly editing Minecraft code. When Minecraft updates, Forge code has to update just like everything else. However, it\u2019s much easier because it is not directly entangled in the Minecraft code. Because this code stands on its own, there is no size restriction like there is with the patches. In addition to making sure the code makes sense, reviews for this code will focus on making the code clean, with proper formatting and Java documentation. Explain Yourself All Pull Requests need to answer the question: why is this necessary? Any code added to Forge needs to be maintained, and more code means more potential for bugs, so solid justification is needed for adding code. A common Pull Request issue is offering no explanation, or giving cryptic examples for how the Pull Request might theoretically be used. This only delays the Pull Request process. A clear explanation for the general case is good, but also give a concrete example of how your mod needs this Pull Request. Sometimes there is better way to do what you wanted, or a way to do it without a Pull Request at all. Code changes can not be accepted until those possibilities have been completely ruled out. Show that it Works The code you submit to Forge should work perfectly, and it\u2019s up to you to convince the reviewers that it does. One of the best ways to do that is to add an example mod or junit test to Forge that makes use of your new code and shows it working. To set up and run a Forge Environment with the example mods, see this guide . Breaking Changes in Forge Forge can\u2019t make changes that break the mods that depend on it. This means that Pull Requests have to ensure that they do not break binary compatibility with previous Forge versions. A change that breaks binary compatibility is called a Breaking Change. There are some exceptions to this, Forge accepts Breaking Changes at the beginning of new Minecraft versions, where Minecraft itself already causes Breaking Changes for modders. Sometimes an emergency breaking change is required outside of that time window, but it is rare and can cause dependency headaches for everyone in the modded Minecraft community. Outside of those exceptional times Pull Requests with breaking changes are not accepted, they must be adapted to support the old behavior or wait for the next Minecraft version. Be Patient, Civil, and Empathetic When submitting Pull Requests you will often have to survive code review and make several changes before it is the best Pull Request possible. Keep in mind that code review is not judgement against you. Bugs in your code are not personal. Nobody is perfect, and that\u2019s why we\u2019re working together. Negativity will not help, threatening to give up on your Pull Request and write a coremod instead will just make people upset and make the modded ecosystem worse. It\u2019s important that while working together you assume the best intentions of the people who are reviewing your Pull Request and not take things personally. Review If you do your best to understand the slow and perfectionistic nature of the Pull Request process, we will do our best to understand your point of view as well. After your Pull Request has been reviewed and cleaned up to the best of everyone\u2019s ability, it will be marked for a final review by Lex, who has the final say on what is included in the project or not.","title":"PR Guidelines"},{"location":"forgedev/prguidelines/#pull-request-guidelines","text":"Mods are built on top of Forge, but there are some things that Forge doesn\u2019t support, and that limits what mods can do. When modders run into something like that, they can make a change to Forge to support it, and submit that change as a Pull Request on Github. To make the best use of both your and the Forge team\u2019s time, it is recommended to follow some rough guidelines when preparing a Pull Request. The following points are the most important aspects to keep in mind when it comes to writing a good Pull Request.","title":"Pull Request Guidelines"},{"location":"forgedev/prguidelines/#what-exactly-is-forge","text":"At a high level, Forge is a mod compatibility layer on top of Minecraft. Early mods edited Minecraft\u2019s code directly (like coremods do now), but ran into conflicts with each other when they edited the same things. They also ran into issues when one mod changed behavior in ways that the other mods could not anticipate (like coremods do now), causing mysterious issues and lots of headaches. By using something like Forge, mods can centralize common changes and avoid conflicts. Forge also includes supporting structures for common mod features like Capabilities, Registries, Fluid handling, the Ore Dictionary, and others that allow mods to work together better. When writing a good Forge Pull Request, you also have to know what Forge is at a lower level. There are two main types of code in Forge: Minecraft patches, and Forge code.","title":"What Exactly is Forge?"},{"location":"forgedev/prguidelines/#patches","text":"Patches are applied as direct changes to Minecraft\u2019s source code, and aim to be as minimal as possible. Every time Minecraft code changes, all the Forge patches need to be looked over carefully and applied correctly to the new code. This means that large patches that change lots of things are difficult to maintain, so Forge aims to avoid those and keep patches as small as possible. In addition to making sure the code makes sense, reviews for patches will focus on minimizing the size. There are many strategies to make small patches, and reviews will often point out better methods to do things. Forge patches often insert a single line that fires an event or a code hook, which affects the code after it if the event meets some condition. This allows most of the code to exist outside of the patch, which keeps the patch small and simple. For more detailed information about creating patches, see the GitHub wiki .","title":"Patches"},{"location":"forgedev/prguidelines/#forge-code","text":"Aside from the patches, Forge code is just normal Java code. It can be event code, compatibility features, or anything else that\u2019s not directly editing Minecraft code. When Minecraft updates, Forge code has to update just like everything else. However, it\u2019s much easier because it is not directly entangled in the Minecraft code. Because this code stands on its own, there is no size restriction like there is with the patches. In addition to making sure the code makes sense, reviews for this code will focus on making the code clean, with proper formatting and Java documentation.","title":"Forge Code"},{"location":"forgedev/prguidelines/#explain-yourself","text":"All Pull Requests need to answer the question: why is this necessary? Any code added to Forge needs to be maintained, and more code means more potential for bugs, so solid justification is needed for adding code. A common Pull Request issue is offering no explanation, or giving cryptic examples for how the Pull Request might theoretically be used. This only delays the Pull Request process. A clear explanation for the general case is good, but also give a concrete example of how your mod needs this Pull Request. Sometimes there is better way to do what you wanted, or a way to do it without a Pull Request at all. Code changes can not be accepted until those possibilities have been completely ruled out.","title":"Explain Yourself"},{"location":"forgedev/prguidelines/#show-that-it-works","text":"The code you submit to Forge should work perfectly, and it\u2019s up to you to convince the reviewers that it does. One of the best ways to do that is to add an example mod or junit test to Forge that makes use of your new code and shows it working. To set up and run a Forge Environment with the example mods, see this guide .","title":"Show that it Works"},{"location":"forgedev/prguidelines/#breaking-changes-in-forge","text":"Forge can\u2019t make changes that break the mods that depend on it. This means that Pull Requests have to ensure that they do not break binary compatibility with previous Forge versions. A change that breaks binary compatibility is called a Breaking Change. There are some exceptions to this, Forge accepts Breaking Changes at the beginning of new Minecraft versions, where Minecraft itself already causes Breaking Changes for modders. Sometimes an emergency breaking change is required outside of that time window, but it is rare and can cause dependency headaches for everyone in the modded Minecraft community. Outside of those exceptional times Pull Requests with breaking changes are not accepted, they must be adapted to support the old behavior or wait for the next Minecraft version.","title":"Breaking Changes in Forge"},{"location":"forgedev/prguidelines/#be-patient-civil-and-empathetic","text":"When submitting Pull Requests you will often have to survive code review and make several changes before it is the best Pull Request possible. Keep in mind that code review is not judgement against you. Bugs in your code are not personal. Nobody is perfect, and that\u2019s why we\u2019re working together. Negativity will not help, threatening to give up on your Pull Request and write a coremod instead will just make people upset and make the modded ecosystem worse. It\u2019s important that while working together you assume the best intentions of the people who are reviewing your Pull Request and not take things personally.","title":"Be Patient, Civil, and Empathetic"},{"location":"forgedev/prguidelines/#review","text":"If you do your best to understand the slow and perfectionistic nature of the Pull Request process, we will do our best to understand your point of view as well. After your Pull Request has been reviewed and cleaned up to the best of everyone\u2019s ability, it will be marked for a final review by Lex, who has the final say on what is included in the project or not.","title":"Review"},{"location":"gettingstarted/","text":"Getting Started with Forge This is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here. From Zero to Modding Obtain a source distribution from forge\u2019s [files][] site. (Look for the MDK file type) Extract the downloaded source distribution to an empty directory. You should see a bunch of files, and an example mod is placed in src/main/java for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects These files are: build.gradle gradlew.bat gradlew the gradle folder Move the files listed above to a new folder, this will be your mod project folder. Choose your IDE: * For both Intellij IDEA and Eclipse their Gradle integration will handle the rest of the initial workspace setup, this includes downloading packages from Mojang, MinecraftForge, and a few other software sharing sites. For most, if not all, changes to the build.gradle file to take effect Gradle will need to be invoked to re-evaluate the project, this can be done through Refresh buttons in the Gradle panels of both the previously mentioned IDEs. Customizing Your Mod Information Edit the build.gradle file to customize how your mod is built (the file names, versions, and other things). Important Do not edit the buildscript {} section of the build.gradle file, its default text is necessary for ForgeGradle to function. Almost anything underneath apply project: forge and the // EDITS GO BELOW HERE marker can be changed, many things can be removed and customized there as well. There is a whole site dedicated to customizing the forge build.gradle files - the ForgeGradle cookbook . Once you\u2019re comfortable with your mod setup, you\u2019ll find many useful recipes there. Simple build.gradle Customizations These customizations are highly recommended for all projects. To change the name of the file you build - edit the value of archivesBaseName to suit. To change your \u201cmaven coordinates\u201d - edit the value of group as well. To change the version number - edit the value of version . Building and Testing Your Mod To build your mod, run gradlew build . This will output a file in build/libs with the name [archivesBaseName]-[version].jar . This file can be placed in the mods folder of a forge enabled Minecraft setup, and distributed. To test run with your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run gradlew runClient . This will launch Minecraft from the <runDir> location, including your mod code. There are various customizations to this command. Consult the ForgeGradle cookbook for more information. You can also run a dedicated server using the server run config, or gradlew runServer . This will launch the Minecraft server with it\u2019s GUI. Note It is always advisable to test your mod in a dedicated server environment if it is intended to run there.","title":"Home"},{"location":"gettingstarted/#getting-started-with-forge","text":"This is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here.","title":"Getting Started with Forge"},{"location":"gettingstarted/#from-zero-to-modding","text":"Obtain a source distribution from forge\u2019s [files][] site. (Look for the MDK file type) Extract the downloaded source distribution to an empty directory. You should see a bunch of files, and an example mod is placed in src/main/java for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects These files are: build.gradle gradlew.bat gradlew the gradle folder Move the files listed above to a new folder, this will be your mod project folder. Choose your IDE: * For both Intellij IDEA and Eclipse their Gradle integration will handle the rest of the initial workspace setup, this includes downloading packages from Mojang, MinecraftForge, and a few other software sharing sites. For most, if not all, changes to the build.gradle file to take effect Gradle will need to be invoked to re-evaluate the project, this can be done through Refresh buttons in the Gradle panels of both the previously mentioned IDEs.","title":"From Zero to Modding"},{"location":"gettingstarted/#customizing-your-mod-information","text":"Edit the build.gradle file to customize how your mod is built (the file names, versions, and other things). Important Do not edit the buildscript {} section of the build.gradle file, its default text is necessary for ForgeGradle to function. Almost anything underneath apply project: forge and the // EDITS GO BELOW HERE marker can be changed, many things can be removed and customized there as well. There is a whole site dedicated to customizing the forge build.gradle files - the ForgeGradle cookbook . Once you\u2019re comfortable with your mod setup, you\u2019ll find many useful recipes there.","title":"Customizing Your Mod Information"},{"location":"gettingstarted/#simple-buildgradle-customizations","text":"These customizations are highly recommended for all projects. To change the name of the file you build - edit the value of archivesBaseName to suit. To change your \u201cmaven coordinates\u201d - edit the value of group as well. To change the version number - edit the value of version .","title":"Simple build.gradle Customizations"},{"location":"gettingstarted/#building-and-testing-your-mod","text":"To build your mod, run gradlew build . This will output a file in build/libs with the name [archivesBaseName]-[version].jar . This file can be placed in the mods folder of a forge enabled Minecraft setup, and distributed. To test run with your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run gradlew runClient . This will launch Minecraft from the <runDir> location, including your mod code. There are various customizations to this command. Consult the ForgeGradle cookbook for more information. You can also run a dedicated server using the server run config, or gradlew runServer . This will launch the Minecraft server with it\u2019s GUI. Note It is always advisable to test your mod in a dedicated server environment if it is intended to run there.","title":"Building and Testing Your Mod"},{"location":"gettingstarted/autoupdate/","text":"Forge Update Checker Forge provides a very lightweight opt-in update-checking framework. All it does is check for updates, then show a flashing icon on the Mods button of the main menu and mod list if any mods have an available update, along with the respective changelogs. It does not download updates automatically. Getting Started The first thing you want to do is specify the updateJSON parameter in your @Mod annotation. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, or on GitHub, or wherever you want, as long as it can be reliably reached by all users of your mod. Update JSON format The JSON itself has a relatively simple format, given as follows: { \"homepage\": \"<homepage/download page for your mod>\", \"<mcversion>\": { \"<modversion>\": \"<changelog for this version>\", // List all versions of your mod for the given Minecraft version, along with their changelogs ... }, ... \"promos\": { \"<mcversion>-latest\": \"<modversion>\", // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version \"<mcversion>-recommended\": \"<modversion>\", // Declare the latest \"stable\" version of your mod for the given Minecraft version ... } } This is fairly self-explanatory, but some notes: The link under homepage is the link the user will be shown when the mod is outdated. Forge uses an internal algorithm to determine whether one version String of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the ComparableVersion class if you are concerned about whether your scheme is supported. Adherence to semantic versioning is highly recommended. The changelog string can be separated into lines using \\n . Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes. Manually inputting data can be chore. You can configure your build.gradle to automatically update this file when building a release, as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader. Two concrete examples can be seen here for Charset and Botania Unofficial . Retrieving Update Check Results You can retrieve the results of the Forge Update Checker using ForgeVersion.getResult(ModContainer) . The returned object has a field status which indicates the status of the version check. Example values: FAILED (the version checker couldn\u2019t connect to the URL provided), UP_TO_DATE (the current version is equal to or newer than the latest stable version), OUTDATED (there is a new stable version), BETA_OUTDATED (there is a new unstable version), or BETA (the current version is equal to or newer than the latest unstable version). The status will be PENDING if the result requested has not finished yet; in that case, you should try again in a little bit. Otherwise, the returned object will also have the target version and any changelog lines, as specified in update.json . You can obtain your own ModContainer to pass to this method using Loader.instance().activeModContainer() , or any other mod\u2019s ModContainer using Loader.instance().getIndexedModList().get(<modid>) .","title":"Forge Update Checker"},{"location":"gettingstarted/autoupdate/#forge-update-checker","text":"Forge provides a very lightweight opt-in update-checking framework. All it does is check for updates, then show a flashing icon on the Mods button of the main menu and mod list if any mods have an available update, along with the respective changelogs. It does not download updates automatically.","title":"Forge Update Checker"},{"location":"gettingstarted/autoupdate/#getting-started","text":"The first thing you want to do is specify the updateJSON parameter in your @Mod annotation. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, or on GitHub, or wherever you want, as long as it can be reliably reached by all users of your mod.","title":"Getting Started"},{"location":"gettingstarted/autoupdate/#update-json-format","text":"The JSON itself has a relatively simple format, given as follows: { \"homepage\": \"<homepage/download page for your mod>\", \"<mcversion>\": { \"<modversion>\": \"<changelog for this version>\", // List all versions of your mod for the given Minecraft version, along with their changelogs ... }, ... \"promos\": { \"<mcversion>-latest\": \"<modversion>\", // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version \"<mcversion>-recommended\": \"<modversion>\", // Declare the latest \"stable\" version of your mod for the given Minecraft version ... } } This is fairly self-explanatory, but some notes: The link under homepage is the link the user will be shown when the mod is outdated. Forge uses an internal algorithm to determine whether one version String of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the ComparableVersion class if you are concerned about whether your scheme is supported. Adherence to semantic versioning is highly recommended. The changelog string can be separated into lines using \\n . Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes. Manually inputting data can be chore. You can configure your build.gradle to automatically update this file when building a release, as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader. Two concrete examples can be seen here for Charset and Botania Unofficial .","title":"Update JSON format"},{"location":"gettingstarted/autoupdate/#retrieving-update-check-results","text":"You can retrieve the results of the Forge Update Checker using ForgeVersion.getResult(ModContainer) . The returned object has a field status which indicates the status of the version check. Example values: FAILED (the version checker couldn\u2019t connect to the URL provided), UP_TO_DATE (the current version is equal to or newer than the latest stable version), OUTDATED (there is a new stable version), BETA_OUTDATED (there is a new unstable version), or BETA (the current version is equal to or newer than the latest unstable version). The status will be PENDING if the result requested has not finished yet; in that case, you should try again in a little bit. Otherwise, the returned object will also have the target version and any changelog lines, as specified in update.json . You can obtain your own ModContainer to pass to this method using Loader.instance().activeModContainer() , or any other mod\u2019s ModContainer using Loader.instance().getIndexedModList().get(<modid>) .","title":"Retrieving Update Check Results"},{"location":"gettingstarted/debugprofiler/","text":"Debug Profiler Minecraft provides a Debug Profiler that can be used to find time consuming code. Specially considering things like TickEvents and Ticking TileEntities this can be very useful for modders and server owners that want to find a lag source. Using the Debug Profiler The Debug Profiler is very simple to use. It requires two commands /debug start , which starts the profiling process, and /debug stop , which ends it. The important part here is that the more time you give it to collect the data the better the results will be. It is recommended to at least let it collect data for a minute. Note Naturally, you can only profile code paths that are actually being reached. Entities and TileEntities that you want to profile must exist in the world to show up in the results. After you\u2019ve stopped the debugger it will create a new file, it can be found within the debug subdirectory in your run directory. The file name will be formatted with the date and time as profile-results-yyyy-mm-dd_hh.mi.ss.txt Reading a Profiling result At the top it first tells you how long in milliseconds it was running and how many ticks ran in that time. Below that, you will find information similar to the snippet below: [00] levels - 96.70%/96.70% [01] | World Name - 99.76%/96.47% [02] | | tick - 99.31%/95.81% [03] | | | entities - 47.72%/45.72% [04] | | | | regular - 98.32%/44.95% [04] | | | | blockEntities - 0.90%/0.41% [05] | | | | | unspecified - 64.26%/0.26% [05] | | | | | minecraft:furnace - 33.35%/0.14% [05] | | | | | minecraft:chest - 2.39%/0.01% Here is a small explanation of what each part means [02] tick 99.31% 95.81% The Depth of the section The Name of the Section The percentage of time it took in relation to it\u2019s parent. For Layer 0 it\u2019s the percentage of the time a tick takes, while for Layer 1 it\u2019s the percentage of the time its parent takes The second Percentage tells you how much Time it took from the entire tick. Profiling your own code The Debug Profiler has basic support for Entity and TileEntity . If you would like to profile something else, you may need to manually create your sections like so: Profiler#startSection(yourSectionName : String); //The code you want to profile Profiler#endSection(); You can obtain the the Profiler instance from a World , MinecraftServer , or Minecraft instance. Now you just need to search the File for your section name.","title":"Debug Profiler"},{"location":"gettingstarted/debugprofiler/#debug-profiler","text":"Minecraft provides a Debug Profiler that can be used to find time consuming code. Specially considering things like TickEvents and Ticking TileEntities this can be very useful for modders and server owners that want to find a lag source.","title":"Debug Profiler"},{"location":"gettingstarted/debugprofiler/#using-the-debug-profiler","text":"The Debug Profiler is very simple to use. It requires two commands /debug start , which starts the profiling process, and /debug stop , which ends it. The important part here is that the more time you give it to collect the data the better the results will be. It is recommended to at least let it collect data for a minute. Note Naturally, you can only profile code paths that are actually being reached. Entities and TileEntities that you want to profile must exist in the world to show up in the results. After you\u2019ve stopped the debugger it will create a new file, it can be found within the debug subdirectory in your run directory. The file name will be formatted with the date and time as profile-results-yyyy-mm-dd_hh.mi.ss.txt","title":"Using the Debug Profiler"},{"location":"gettingstarted/debugprofiler/#reading-a-profiling-result","text":"At the top it first tells you how long in milliseconds it was running and how many ticks ran in that time. Below that, you will find information similar to the snippet below: [00] levels - 96.70%/96.70% [01] | World Name - 99.76%/96.47% [02] | | tick - 99.31%/95.81% [03] | | | entities - 47.72%/45.72% [04] | | | | regular - 98.32%/44.95% [04] | | | | blockEntities - 0.90%/0.41% [05] | | | | | unspecified - 64.26%/0.26% [05] | | | | | minecraft:furnace - 33.35%/0.14% [05] | | | | | minecraft:chest - 2.39%/0.01% Here is a small explanation of what each part means [02] tick 99.31% 95.81% The Depth of the section The Name of the Section The percentage of time it took in relation to it\u2019s parent. For Layer 0 it\u2019s the percentage of the time a tick takes, while for Layer 1 it\u2019s the percentage of the time its parent takes The second Percentage tells you how much Time it took from the entire tick.","title":"Reading a Profiling result"},{"location":"gettingstarted/debugprofiler/#profiling-your-own-code","text":"The Debug Profiler has basic support for Entity and TileEntity . If you would like to profile something else, you may need to manually create your sections like so: Profiler#startSection(yourSectionName : String); //The code you want to profile Profiler#endSection(); You can obtain the the Profiler instance from a World , MinecraftServer , or Minecraft instance. Now you just need to search the File for your section name.","title":"Profiling your own code"},{"location":"gettingstarted/dependencymanagement/","text":"Dependency Management Forge has some support for managing and loading mod dependencies. Libraries, and even other mods, can be embedded in builds in a way that lets Forge extract and load them at runtime in a compatible manner. The mod repository The mod repository is a Maven-like repository containing mods and libraries. An artifact in this repository is identified by its Maven coordinate: groupId:artifactId:version:classifier@extention . Classifer and extension are optional. Forge can archive, manage and load mods and libraries in this repository. The mod repository may contain multiple versions of mods and libraries, including snapshot versions. Forge can archive a jar in the repository if its Maven-Artifact manifest attribute is defined. The value of this attribute should be its Maven coordinate. The mod repository supports snapshot artifacts. If the artifact version ends with -SNAPSHOT , the artifact will be resolved as the version with the latest timestamp. The timestamp can be set as the Timestamp manifest attribute, which should be the time since the epoch in milliseconds. Dependency extraction Forge provides a simple way to embed dependencies in a mod and have them extracted at runtime. By placing dependency jars in your own jar, Forge can extract them into the mod repository and load them. This can be used as an alternative to shading, and comes with the potential benefit of resolving dependency version conflicts. The contained dependencies of a jar file are marked by the ContainedDeps manifest attribute. Its value should be a space separated list of the names of contained jar files that will be extracted. These jar files should be placed in /META-INF/libraries/{entry} . Forge will inspect the manifest of the contained jar to determine its Maven coordinate so that it may be archived. If a file /META-INF/libraries/{entry}.meta exists, Forge will read this as the jar\u2019s manifest instead. The dependency will be archived in the local repository according to its Maven-Artifact manifest attribute.","title":"Dependency Management"},{"location":"gettingstarted/dependencymanagement/#dependency-management","text":"Forge has some support for managing and loading mod dependencies. Libraries, and even other mods, can be embedded in builds in a way that lets Forge extract and load them at runtime in a compatible manner.","title":"Dependency Management"},{"location":"gettingstarted/dependencymanagement/#the-mod-repository","text":"The mod repository is a Maven-like repository containing mods and libraries. An artifact in this repository is identified by its Maven coordinate: groupId:artifactId:version:classifier@extention . Classifer and extension are optional. Forge can archive, manage and load mods and libraries in this repository. The mod repository may contain multiple versions of mods and libraries, including snapshot versions. Forge can archive a jar in the repository if its Maven-Artifact manifest attribute is defined. The value of this attribute should be its Maven coordinate. The mod repository supports snapshot artifacts. If the artifact version ends with -SNAPSHOT , the artifact will be resolved as the version with the latest timestamp. The timestamp can be set as the Timestamp manifest attribute, which should be the time since the epoch in milliseconds.","title":"The mod repository"},{"location":"gettingstarted/dependencymanagement/#dependency-extraction","text":"Forge provides a simple way to embed dependencies in a mod and have them extracted at runtime. By placing dependency jars in your own jar, Forge can extract them into the mod repository and load them. This can be used as an alternative to shading, and comes with the potential benefit of resolving dependency version conflicts. The contained dependencies of a jar file are marked by the ContainedDeps manifest attribute. Its value should be a space separated list of the names of contained jar files that will be extracted. These jar files should be placed in /META-INF/libraries/{entry} . Forge will inspect the manifest of the contained jar to determine its Maven coordinate so that it may be archived. If a file /META-INF/libraries/{entry}.meta exists, Forge will read this as the jar\u2019s manifest instead. The dependency will be archived in the local repository according to its Maven-Artifact manifest attribute.","title":"Dependency extraction"},{"location":"gettingstarted/structuring/","text":"Structuring Your Mod We\u2019ll look at how to organize your mod into different files and what those files should do. Packaging Pick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use com.example as your top level package. Important If you do not own a domain, do not use it for your top level package. It is perfectly acceptable to start your package with anything, such as your name/nickname, or the name of the mod. After the top level package (if you have one) you append a unique name for your mod, such as examplemod . In our case it will end up as com.example.examplemod . The mcmod.info file This file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the Mods button. A single info file can describe several mods. When a mod is annotated by the @Mod annotation, it may define the useMetadata property, which defaults to false . When useMetadata is true , the metadata within mcmod.info overrides whatever has been defined in the annotation. The mcmod.info file is formatted as JSON, where the root element is a list of objects and each object describes one modid. It should be stored as src/main/resources/mcmod.info . A basic mcmod.info , describing one mod, may look like this: [{ \"modid\": \"examplemod\", \"name\": \"Example Mod\", \"description\": \"Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.\", \"version\": \"1.0.0.0\", \"mcversion\": \"1.10.2\", \"logoFile\": \"assets/examplemod/textures/logo.png\", \"url\": \"minecraftforge.net/\", \"updateJSON\": \"minecraftforge.net/versions.json\", \"authorList\": [\"Author\"], \"credits\": \"I'd like to thank my mother and father.\" }] The default Gradle configuration replaces ${version} with the project version, and ${mcversion} with the Minecraft version, but only within mcmod.info , so you should use those instead of directly writing them out. Here is a table of attributes that may be given to a mod, where required means there is no default and the absence of the property causes an error. In addition to the required properties, you should also define description , version , mcversion , url , and authorList . Property Type Default Description modid string required The modid this description is linked to. If the mod is not loaded, the description is ignored. name string required The user-friendly name of this mod. description string \"\" A description of this mod in 1-2 paragraphs. version string \"\" The version of the mod. mcversion string \"\" The Minecraft version. url string \"\" A link to the mod\u2019s homepage. updateUrl string \"\" Defined but unused. Superseded by updateJSON. updateJSON string \"\" The URL to a version JSON . authorList [string] [] A list of authors to this mod. credits string \"\" A string that contains any acknowledgements you want to mention. logoFile string \"\" The path to the mod\u2019s logo. It is resolved on top of the classpath, so you should put it in a location where the name will not conflict, maybe under your own assets folder. screenshots [string] [] A list of images to be shown on the info page. Currently unimplemented. parent string \"\" The modid of a parent mod, if applicable. Using this allows modules of another mod to be listed under it in the info page, like BuildCraft. useDependencyInformation boolean false If true and Mod.useMetadata , the below 3 lists of dependencies will be used. If not, they do nothing. requiredMods [string] [] A list of modids. If one is missing, the game will crash. This does not affect the ordering of mod loading! To specify ordering as well as requirement, have a coupled entry in dependencies . dependencies [string] [] A list of modids. All of the listed mods will load before this one. If one is not present, nothing happens. dependants [string] [] A list of modids. All of the listed mods will load after this one. If one is not present, nothing happens. A good example mcmod.info that uses many of these properties is BuildCraft . The Mod File Generally, we\u2019ll start with a file named after your mod, and put into your package. This is the entry point to your mod and will contain some special indicators marking it as such. What is @Mod ? This is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. It contains various metadata about the mod. It also designates the class that will receive @EventHandler events. Here is a table of the properties of @Mod : Property Type Default Description modid String required A unique identifier for the mod. It must be lowercased, and will be truncated to 64 characters in length. name String \u201d\u201c A user-friendly name for the mod. version String \u201d\u201c The version of the mod. It should be just numbers seperated by dots, ideally conforming to Semantic Versioning . Even if useMetadata is set to true , it\u2019s a good idea to put the version here anyways. dependencies String \u201d\u201c Dependencies for the mod. The specification is described in the Forge @Mod javadoc: A dependency string can start with the following four prefixes: \"before\" , \"after\" , \"required-before\" , \"required-after\" ; then \":\" and the modid . Optionally, a version range can be specified for the mod by adding \"@\" and then the version range. * If a \u201crequired\u201d mod is missing, or a mod exists with a version outside the specified range, the game will not start and an error screen will tell the player which versions are required. useMetadata boolean false If set to true, properties in @Mod will be overridden by mcmod.info . clientSideOnly serverSideOnly boolean boolean false false If either is set to true , the jar will be skipped on the other side, and the mod will not load. If both are true, the game crashes. acceptedMinecraftVersions String \u201d\u201c The version range of Minecraft the mod will run on. * An empty string will match all versions. acceptableRemoteVersions String \u201d\u201c Specifies a remote version range that this mod will accept as valid. * \"\" Matches the current version, and \"*\" matches all versions. Note that \"*\" matches even when the mod is not present on the remote side at all. acceptableSaveVersions String \u201d\u201c A version range specifying compatible save version information. * If you follow an unusual version convention, use SaveInspectionHandler instead. certificateFingerprint String \u201d\u201c See the tutorial on jar signing . modLanguage String \u201cjava\u201d The programming language the mod is written in. Can be either \"java\" or \"scala\" . modLanguageAdapter String \u201d\u201c Path to a language adapter for the mod. The class must have a default constructor and must implement ILanguageAdapter . If it doesn\u2019t, Forge will crash. If set, overrides modLanguage . canBeDeactivated boolean false This is not implemented, but if the mod could be deactivated (e.g. a minimap mod), this would be set to true and the mod would receive FMLDeactivationEvent to perform cleanup tasks. guiFactory String \u201d\u201c Path to the mod\u2019s GUI factory, if one exists. GUI factories are used to make custom config screens, and must implement IModGuiFactory . For an example, look at FMLConfigGuiFactory . updateJSON String \u201d\u201c URL to an update JSON file. See Forge Update Checker * All version ranges use the Maven Version Range Specification . You can find an example mod in the Forge src download . Keeping Your Code Clean Using Sub-packages Rather than clutter up a single class and package with everything, it is recommended you break your mod into subpackages. A common subpackage strategy has packages for common and client code, which is code that can be run on server/client and client, respectively. Inside the common package would go things like Items, Blocks, and Tile Entities (which can each in turn be another subpackage). Things like GUIs and Renderers would go inside the client package. Note This package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system. By keeping your code in clean subpackages, you can grow your mod much more organically. Class Naming Schemes A common class naming scheme allows easier deciphering of what a class is, and also makes it easier for someone developing with your mod to find things. For Example: An Item called PowerRing would be in an item package, with a class name of ItemPowerRing . A Block called NotDirt would be in a block package, with a class name of BlockNotDirt . Finally, a TileEntity for a block called SuperChewer would be a tile or tileentity package, with a class name of TileSuperChewer . Prepending your class names with what kind of object they are makes it easier to figure out what a class is, or guess the class for an object.","title":"Structuring Your Mod"},{"location":"gettingstarted/structuring/#structuring-your-mod","text":"We\u2019ll look at how to organize your mod into different files and what those files should do.","title":"Structuring Your Mod"},{"location":"gettingstarted/structuring/#packaging","text":"Pick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use com.example as your top level package. Important If you do not own a domain, do not use it for your top level package. It is perfectly acceptable to start your package with anything, such as your name/nickname, or the name of the mod. After the top level package (if you have one) you append a unique name for your mod, such as examplemod . In our case it will end up as com.example.examplemod .","title":"Packaging"},{"location":"gettingstarted/structuring/#the-mcmodinfo-file","text":"This file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the Mods button. A single info file can describe several mods. When a mod is annotated by the @Mod annotation, it may define the useMetadata property, which defaults to false . When useMetadata is true , the metadata within mcmod.info overrides whatever has been defined in the annotation. The mcmod.info file is formatted as JSON, where the root element is a list of objects and each object describes one modid. It should be stored as src/main/resources/mcmod.info . A basic mcmod.info , describing one mod, may look like this: [{ \"modid\": \"examplemod\", \"name\": \"Example Mod\", \"description\": \"Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc.\", \"version\": \"1.0.0.0\", \"mcversion\": \"1.10.2\", \"logoFile\": \"assets/examplemod/textures/logo.png\", \"url\": \"minecraftforge.net/\", \"updateJSON\": \"minecraftforge.net/versions.json\", \"authorList\": [\"Author\"], \"credits\": \"I'd like to thank my mother and father.\" }] The default Gradle configuration replaces ${version} with the project version, and ${mcversion} with the Minecraft version, but only within mcmod.info , so you should use those instead of directly writing them out. Here is a table of attributes that may be given to a mod, where required means there is no default and the absence of the property causes an error. In addition to the required properties, you should also define description , version , mcversion , url , and authorList . Property Type Default Description modid string required The modid this description is linked to. If the mod is not loaded, the description is ignored. name string required The user-friendly name of this mod. description string \"\" A description of this mod in 1-2 paragraphs. version string \"\" The version of the mod. mcversion string \"\" The Minecraft version. url string \"\" A link to the mod\u2019s homepage. updateUrl string \"\" Defined but unused. Superseded by updateJSON. updateJSON string \"\" The URL to a version JSON . authorList [string] [] A list of authors to this mod. credits string \"\" A string that contains any acknowledgements you want to mention. logoFile string \"\" The path to the mod\u2019s logo. It is resolved on top of the classpath, so you should put it in a location where the name will not conflict, maybe under your own assets folder. screenshots [string] [] A list of images to be shown on the info page. Currently unimplemented. parent string \"\" The modid of a parent mod, if applicable. Using this allows modules of another mod to be listed under it in the info page, like BuildCraft. useDependencyInformation boolean false If true and Mod.useMetadata , the below 3 lists of dependencies will be used. If not, they do nothing. requiredMods [string] [] A list of modids. If one is missing, the game will crash. This does not affect the ordering of mod loading! To specify ordering as well as requirement, have a coupled entry in dependencies . dependencies [string] [] A list of modids. All of the listed mods will load before this one. If one is not present, nothing happens. dependants [string] [] A list of modids. All of the listed mods will load after this one. If one is not present, nothing happens. A good example mcmod.info that uses many of these properties is BuildCraft .","title":"The mcmod.info file"},{"location":"gettingstarted/structuring/#the-mod-file","text":"Generally, we\u2019ll start with a file named after your mod, and put into your package. This is the entry point to your mod and will contain some special indicators marking it as such.","title":"The Mod File"},{"location":"gettingstarted/structuring/#what-is-mod","text":"This is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. It contains various metadata about the mod. It also designates the class that will receive @EventHandler events. Here is a table of the properties of @Mod : Property Type Default Description modid String required A unique identifier for the mod. It must be lowercased, and will be truncated to 64 characters in length. name String \u201d\u201c A user-friendly name for the mod. version String \u201d\u201c The version of the mod. It should be just numbers seperated by dots, ideally conforming to Semantic Versioning . Even if useMetadata is set to true , it\u2019s a good idea to put the version here anyways. dependencies String \u201d\u201c Dependencies for the mod. The specification is described in the Forge @Mod javadoc: A dependency string can start with the following four prefixes: \"before\" , \"after\" , \"required-before\" , \"required-after\" ; then \":\" and the modid . Optionally, a version range can be specified for the mod by adding \"@\" and then the version range. * If a \u201crequired\u201d mod is missing, or a mod exists with a version outside the specified range, the game will not start and an error screen will tell the player which versions are required. useMetadata boolean false If set to true, properties in @Mod will be overridden by mcmod.info . clientSideOnly serverSideOnly boolean boolean false false If either is set to true , the jar will be skipped on the other side, and the mod will not load. If both are true, the game crashes. acceptedMinecraftVersions String \u201d\u201c The version range of Minecraft the mod will run on. * An empty string will match all versions. acceptableRemoteVersions String \u201d\u201c Specifies a remote version range that this mod will accept as valid. * \"\" Matches the current version, and \"*\" matches all versions. Note that \"*\" matches even when the mod is not present on the remote side at all. acceptableSaveVersions String \u201d\u201c A version range specifying compatible save version information. * If you follow an unusual version convention, use SaveInspectionHandler instead. certificateFingerprint String \u201d\u201c See the tutorial on jar signing . modLanguage String \u201cjava\u201d The programming language the mod is written in. Can be either \"java\" or \"scala\" . modLanguageAdapter String \u201d\u201c Path to a language adapter for the mod. The class must have a default constructor and must implement ILanguageAdapter . If it doesn\u2019t, Forge will crash. If set, overrides modLanguage . canBeDeactivated boolean false This is not implemented, but if the mod could be deactivated (e.g. a minimap mod), this would be set to true and the mod would receive FMLDeactivationEvent to perform cleanup tasks. guiFactory String \u201d\u201c Path to the mod\u2019s GUI factory, if one exists. GUI factories are used to make custom config screens, and must implement IModGuiFactory . For an example, look at FMLConfigGuiFactory . updateJSON String \u201d\u201c URL to an update JSON file. See Forge Update Checker * All version ranges use the Maven Version Range Specification . You can find an example mod in the Forge src download .","title":"What is @Mod?"},{"location":"gettingstarted/structuring/#keeping-your-code-clean-using-sub-packages","text":"Rather than clutter up a single class and package with everything, it is recommended you break your mod into subpackages. A common subpackage strategy has packages for common and client code, which is code that can be run on server/client and client, respectively. Inside the common package would go things like Items, Blocks, and Tile Entities (which can each in turn be another subpackage). Things like GUIs and Renderers would go inside the client package. Note This package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system. By keeping your code in clean subpackages, you can grow your mod much more organically.","title":"Keeping Your Code Clean Using Sub-packages"},{"location":"gettingstarted/structuring/#class-naming-schemes","text":"A common class naming scheme allows easier deciphering of what a class is, and also makes it easier for someone developing with your mod to find things. For Example: An Item called PowerRing would be in an item package, with a class name of ItemPowerRing . A Block called NotDirt would be in a block package, with a class name of BlockNotDirt . Finally, a TileEntity for a block called SuperChewer would be a tile or tileentity package, with a class name of TileSuperChewer . Prepending your class names with what kind of object they are makes it easier to figure out what a class is, or guess the class for an object.","title":"Class Naming Schemes"},{"location":"items/items/","text":"Items Along with blocks, items are a key component of most mods. While blocks make up the world around you, items are what let you change it. Creating an Item Basic Items Basic items that need no special functionality (think sticks or sugar) don\u2019t need custom classes. You can simply instantiate Item and call its various setters to set some simple properties. Method Description setCreativeTab Sets which creative tab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class CreativeTabs . setMaxDamage Sets the maximum damage value for this item. If it\u2019s over 0 , 2 item properties \u201cdamaged\u201d and \u201cdamage\u201d are added. setMaxStackSize Sets the maximum stack size. setNoRepair Makes this item impossible to repair, even if it is damageable. setUnlocalizedName Sets this item\u2019s unlocalized name, with \u201citem.\u201d prepended. setHarvestLevel Adds or removes a pair of harvest class ( \"shovel\" , \"axe\" ) and harvest level. This method is not chainable. The above methods are chainable, unless otherwise stated, meaning they return this to facilitate calling them in series. Advanced Items Setting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods. Registering an Item Items must be registered to function.","title":"Home"},{"location":"items/items/#items","text":"Along with blocks, items are a key component of most mods. While blocks make up the world around you, items are what let you change it.","title":"Items"},{"location":"items/items/#creating-an-item","text":"","title":"Creating an Item"},{"location":"items/items/#basic-items","text":"Basic items that need no special functionality (think sticks or sugar) don\u2019t need custom classes. You can simply instantiate Item and call its various setters to set some simple properties. Method Description setCreativeTab Sets which creative tab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class CreativeTabs . setMaxDamage Sets the maximum damage value for this item. If it\u2019s over 0 , 2 item properties \u201cdamaged\u201d and \u201cdamage\u201d are added. setMaxStackSize Sets the maximum stack size. setNoRepair Makes this item impossible to repair, even if it is damageable. setUnlocalizedName Sets this item\u2019s unlocalized name, with \u201citem.\u201d prepended. setHarvestLevel Adds or removes a pair of harvest class ( \"shovel\" , \"axe\" ) and harvest level. This method is not chainable. The above methods are chainable, unless otherwise stated, meaning they return this to facilitate calling them in series.","title":"Basic Items"},{"location":"items/items/#advanced-items","text":"Setting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods.","title":"Advanced Items"},{"location":"items/items/#registering-an-item","text":"Items must be registered to function.","title":"Registering an Item"},{"location":"items/loot_tables/","text":"Loot Tables Loot tables are an easy way to generate random loot given random distributions of items. They are used in vanilla to generate random chest loot as well as for mob drops. The vanilla wiki describes the loot table JSON format in great detail, so this article instead will focus on code that you might have to write to use and manipulate loot tables in your mod. To get the most out of this article, read the aforementioned wiki page in its entirety before reading this article. Registering a Modded Loot Table In order to make Minecraft load and be aware of your loot table, simply call LootTableList.register(new ResourceLocation(\"modid\", \"loot_table_name\")) , which will resolve and load /assets/modid/loot_tables/loot_table_name.json . This call can be made during any of preinit, init, or postinit. You may organize your tables into folders freely. Note Loot pools in mod loot tables must include an additional name tag that uniquely identifies that pool within the table. A common strategy is to name the pool with the kinds of items that its entries contain. If you specify multiple loot entries with the same name tag (e.g. the same item but with different functions each time), then you must give each of those entries an entryName tag that uniquely identifies that entry within the pool. For name tags that do not clash, then entryName is automatically set to the value of name . These additional requirements are imposed by Forge to facilitate modification of tables at load time using LootTableLoadEvent (see below). Registering Custom Objects In addition to vanilla\u2019s, you can also register your own loot conditions, loot functions, and entity properties. Entity properties are solely for use of the minecraft:entity_properties loot condition, and are used to test if entities involved in the looting (the looted entity or the killer) have certain properties. The only property in vanilla is minecraft:on_fire . All three are registered similarly, by calling LootConditionManager.registerCondition , LootFunctionManager.registerFunction() , or EntityPropertyManager.registerProperty() , respectively. The methods take a Serializer instance, which takes the ID of the object as a ResourceLocation , and the Class implementing the behavior in code - LootCondition , LootFunction , and EntityProperty , respectively. Since you register the JSON serializer and deserializer, you can require additional fields when using your condition, function, or property. See the vanilla implementations in net.minecraft.world.storage.loot.{conditions, functions, properties} for examples. Then, in order to use your conditions, functions, or properties, simply specify the registry name you passed to the Serializer constructor. An example loot entry: { \"type\": \"item\", \"name\": \"mymod:myitem\", \"conditions\": [ { \"condition\": \"mymod:mycondition\", \"foo\": 1, // can require custom parameters in deserializer }, { \"condition\": \"minecraft:entity_properties\", \"entity\": \"this\", \"properties\": { \"mymod:my_property\": { // structure of the right side is completely up to deserializer \"bar\": 2 } } } ], \"functions\": [ { \"function\": \"mymod:myfunction\", \"foobar\": 3 // can require custom parameters in deserializer } ] } Modifying Vanilla Loot Overview Not only can you specify your own loot tables, conditions, functions, and entity properties, you can also modify others as they load. Note Users are allowed by vanilla to place their own loot tables in the world save directory to override the game\u2019s (and mods\u2019) own tables. These are considered config files and thus cannot be modified by the methods described below, by design . The entry point to modifying tables at runtime is LootTableLoadEvent , which is fired once for each table loaded. From here, you may query and remove pools by name, or add instances of LootPool . This is why modded loot pools are required to have names. You might be wondering how we modify vanilla tables, then, since they do not have names. Forge resolves this by generating names for all pools in vanilla tables. The first pool is named main , since many tables only have one pool. Subsequent pools are named by position: pool1 for the second pool, pool2 for the third, and so on. Removing a pool does not shift the names of the other pools. Within each LootPool , you may also modify the roll and bonus roll attributes of the pool (how many times the table will call this pool) as well as query and remove entries by name, or add instances of LootEntry . Similar to the case for pools, entries need unique names for retrieval and removal. Forge resolves this by adding a hidden entryName field to all loot entries. If the entry\u2019s name field is unique within the pool, then entryName is automatically set to name . Otherwise, a name must be specified in modded entries, and is automatically generated for vanilla entries. For each repeat, a number is incremented. For example, if there are three entries in a vanilla pool each with name: \"minecraft:stick\" , then the three entryName tags generated would be minecraft:stick , minecraft:stick#0 , and minecraft:stick#1 . Likewise, removing an entry does not shift the names of the other entries. Note You must perform all of your desired changes to the table during that table\u2019s LootTableLoadEvent , any changes afterward are disallowed by safety checks or will cause undefined behavior if the safety checks are bypassed. Adding Dungeon Loot Next, an example of one of the most common use cases for modifying vanilla loot: adding dungeon item spawns. First, listen for the event for the table we want to modify: @SubscribeEvent public void lootLoad(LootTableLoadEvent evt) { if (evt.getName().toString().equals(\"minecraft:chests/simple_dungeon\")) { // do stuff with evt.getTable() } } In this case, we are adding to the potential spawns, but don\u2019t want to interfere with the entry weights of the preexisting pools. The most flexible and simple solution is to add another pool with a single loot entry referencing your own loot table JSON, because loot entries are able to recursively draw from a completely different table. For example, your mod might include /assets/mymod/loot_tables/inject/simple_dungeon.json : { \"pools\": [ { \"name\": \"main\", \"rolls\": 1, \"entries\": [ { \"type\": \"item\", \"name\": \"minecraft:nether_star\", \"weight\": 40 }, { \"type\": \"empty\", \"weight\": 60 } ] } ] } Note You still need to register this table with LootTableList.register() ! Then the loot entry and pool are created and added, resulting in a new loot pool for dungeon chests that has a 60% chance of nothing and 40% of a nether star. LootEntry entry = new LootEntryTable(new ResourceLocation(\"mymod:inject/simple_dungeon\"), <weight>, <quality>, <conditions>, <entryName>); // weight doesn't matter since it's the only entry in the pool. Other params set as you wish. LootPool pool = new LootPool(new LootEntry[] {entry}, <conditions>, <rolls>, <bonusRolls>, <name>); // Other params set as you wish. evt.getTable().addPool(pool); Of course, if the loot you want to add cannot be determined ahead of time, you can freely construct and add LootPool s and implementations of LootEntry in your event handler similar to the calls shown above. A real-world example of this approach in action can be seen in Botania. The event handler is located here , and the injected tables are located here . Changing Mob Drops Subclasses of EntityLiving automatically support drawing from a loot table upon death. This is done by overriding the getLootTable method to return a ResourceLocation to the desired table. This serves as the mob\u2019s default table; the tables of both your and other mods\u2019 mobs can be overridden for a single entity by setting the deathLootTable field of the entity. Generating Loot In-Code Occasionally, you may want to generate ItemStack s from a loot table from your own code. First, obtain the loot table itself (you need access to a World ): LootTable table = this.world.getLootTableManager().getLootTableFromLocation(new ResourceLocation(\"mymod:my_table\")); // resolves to /assets/mymod/loot_tables/my_table.json Next, create a LootContext using the provided LootContextBuilder , which holds information about the context of the looting, such as the killer, luck of the looter, and finishing blow. LootContext ctx = new LootContext.Builder(world) .withLuck(...) // adjust luck, commonly EntityPlayer.getLuck() .withLootedEntity(...) // set looted entity .withPlayer(...) // set player as killer .withDamageSource(...) // pass killing blow and non-player killer .build(); Finally, to get a collection of ItemStack s: List<ItemStack> stacks = table.generateLootForPools(world.rand, ctx); Or to fill an inventory: table.fillInventory(iinventory, world.rand, ctx); Note This only works with IInventory for now.","title":"Loot Tables"},{"location":"items/loot_tables/#loot-tables","text":"Loot tables are an easy way to generate random loot given random distributions of items. They are used in vanilla to generate random chest loot as well as for mob drops. The vanilla wiki describes the loot table JSON format in great detail, so this article instead will focus on code that you might have to write to use and manipulate loot tables in your mod. To get the most out of this article, read the aforementioned wiki page in its entirety before reading this article.","title":"Loot Tables"},{"location":"items/loot_tables/#registering-a-modded-loot-table","text":"In order to make Minecraft load and be aware of your loot table, simply call LootTableList.register(new ResourceLocation(\"modid\", \"loot_table_name\")) , which will resolve and load /assets/modid/loot_tables/loot_table_name.json . This call can be made during any of preinit, init, or postinit. You may organize your tables into folders freely. Note Loot pools in mod loot tables must include an additional name tag that uniquely identifies that pool within the table. A common strategy is to name the pool with the kinds of items that its entries contain. If you specify multiple loot entries with the same name tag (e.g. the same item but with different functions each time), then you must give each of those entries an entryName tag that uniquely identifies that entry within the pool. For name tags that do not clash, then entryName is automatically set to the value of name . These additional requirements are imposed by Forge to facilitate modification of tables at load time using LootTableLoadEvent (see below).","title":"Registering a Modded Loot Table"},{"location":"items/loot_tables/#registering-custom-objects","text":"In addition to vanilla\u2019s, you can also register your own loot conditions, loot functions, and entity properties. Entity properties are solely for use of the minecraft:entity_properties loot condition, and are used to test if entities involved in the looting (the looted entity or the killer) have certain properties. The only property in vanilla is minecraft:on_fire . All three are registered similarly, by calling LootConditionManager.registerCondition , LootFunctionManager.registerFunction() , or EntityPropertyManager.registerProperty() , respectively. The methods take a Serializer instance, which takes the ID of the object as a ResourceLocation , and the Class implementing the behavior in code - LootCondition , LootFunction , and EntityProperty , respectively. Since you register the JSON serializer and deserializer, you can require additional fields when using your condition, function, or property. See the vanilla implementations in net.minecraft.world.storage.loot.{conditions, functions, properties} for examples. Then, in order to use your conditions, functions, or properties, simply specify the registry name you passed to the Serializer constructor. An example loot entry: { \"type\": \"item\", \"name\": \"mymod:myitem\", \"conditions\": [ { \"condition\": \"mymod:mycondition\", \"foo\": 1, // can require custom parameters in deserializer }, { \"condition\": \"minecraft:entity_properties\", \"entity\": \"this\", \"properties\": { \"mymod:my_property\": { // structure of the right side is completely up to deserializer \"bar\": 2 } } } ], \"functions\": [ { \"function\": \"mymod:myfunction\", \"foobar\": 3 // can require custom parameters in deserializer } ] }","title":"Registering Custom Objects"},{"location":"items/loot_tables/#modifying-vanilla-loot","text":"","title":"Modifying Vanilla Loot"},{"location":"items/loot_tables/#overview","text":"Not only can you specify your own loot tables, conditions, functions, and entity properties, you can also modify others as they load. Note Users are allowed by vanilla to place their own loot tables in the world save directory to override the game\u2019s (and mods\u2019) own tables. These are considered config files and thus cannot be modified by the methods described below, by design . The entry point to modifying tables at runtime is LootTableLoadEvent , which is fired once for each table loaded. From here, you may query and remove pools by name, or add instances of LootPool . This is why modded loot pools are required to have names. You might be wondering how we modify vanilla tables, then, since they do not have names. Forge resolves this by generating names for all pools in vanilla tables. The first pool is named main , since many tables only have one pool. Subsequent pools are named by position: pool1 for the second pool, pool2 for the third, and so on. Removing a pool does not shift the names of the other pools. Within each LootPool , you may also modify the roll and bonus roll attributes of the pool (how many times the table will call this pool) as well as query and remove entries by name, or add instances of LootEntry . Similar to the case for pools, entries need unique names for retrieval and removal. Forge resolves this by adding a hidden entryName field to all loot entries. If the entry\u2019s name field is unique within the pool, then entryName is automatically set to name . Otherwise, a name must be specified in modded entries, and is automatically generated for vanilla entries. For each repeat, a number is incremented. For example, if there are three entries in a vanilla pool each with name: \"minecraft:stick\" , then the three entryName tags generated would be minecraft:stick , minecraft:stick#0 , and minecraft:stick#1 . Likewise, removing an entry does not shift the names of the other entries. Note You must perform all of your desired changes to the table during that table\u2019s LootTableLoadEvent , any changes afterward are disallowed by safety checks or will cause undefined behavior if the safety checks are bypassed.","title":"Overview"},{"location":"items/loot_tables/#adding-dungeon-loot","text":"Next, an example of one of the most common use cases for modifying vanilla loot: adding dungeon item spawns. First, listen for the event for the table we want to modify: @SubscribeEvent public void lootLoad(LootTableLoadEvent evt) { if (evt.getName().toString().equals(\"minecraft:chests/simple_dungeon\")) { // do stuff with evt.getTable() } } In this case, we are adding to the potential spawns, but don\u2019t want to interfere with the entry weights of the preexisting pools. The most flexible and simple solution is to add another pool with a single loot entry referencing your own loot table JSON, because loot entries are able to recursively draw from a completely different table. For example, your mod might include /assets/mymod/loot_tables/inject/simple_dungeon.json : { \"pools\": [ { \"name\": \"main\", \"rolls\": 1, \"entries\": [ { \"type\": \"item\", \"name\": \"minecraft:nether_star\", \"weight\": 40 }, { \"type\": \"empty\", \"weight\": 60 } ] } ] } Note You still need to register this table with LootTableList.register() ! Then the loot entry and pool are created and added, resulting in a new loot pool for dungeon chests that has a 60% chance of nothing and 40% of a nether star. LootEntry entry = new LootEntryTable(new ResourceLocation(\"mymod:inject/simple_dungeon\"), <weight>, <quality>, <conditions>, <entryName>); // weight doesn't matter since it's the only entry in the pool. Other params set as you wish. LootPool pool = new LootPool(new LootEntry[] {entry}, <conditions>, <rolls>, <bonusRolls>, <name>); // Other params set as you wish. evt.getTable().addPool(pool); Of course, if the loot you want to add cannot be determined ahead of time, you can freely construct and add LootPool s and implementations of LootEntry in your event handler similar to the calls shown above. A real-world example of this approach in action can be seen in Botania. The event handler is located here , and the injected tables are located here .","title":"Adding Dungeon Loot"},{"location":"items/loot_tables/#changing-mob-drops","text":"Subclasses of EntityLiving automatically support drawing from a loot table upon death. This is done by overriding the getLootTable method to return a ResourceLocation to the desired table. This serves as the mob\u2019s default table; the tables of both your and other mods\u2019 mobs can be overridden for a single entity by setting the deathLootTable field of the entity.","title":"Changing Mob Drops"},{"location":"items/loot_tables/#generating-loot-in-code","text":"Occasionally, you may want to generate ItemStack s from a loot table from your own code. First, obtain the loot table itself (you need access to a World ): LootTable table = this.world.getLootTableManager().getLootTableFromLocation(new ResourceLocation(\"mymod:my_table\")); // resolves to /assets/mymod/loot_tables/my_table.json Next, create a LootContext using the provided LootContextBuilder , which holds information about the context of the looting, such as the killer, luck of the looter, and finishing blow. LootContext ctx = new LootContext.Builder(world) .withLuck(...) // adjust luck, commonly EntityPlayer.getLuck() .withLootedEntity(...) // set looted entity .withPlayer(...) // set player as killer .withDamageSource(...) // pass killing blow and non-player killer .build(); Finally, to get a collection of ItemStack s: List<ItemStack> stacks = table.generateLootForPools(world.rand, ctx); Or to fill an inventory: table.fillInventory(iinventory, world.rand, ctx); Note This only works with IInventory for now.","title":"Generating Loot In-Code"},{"location":"models/color/","text":"Coloring Textures Many blocks and items in vanilla change their texture color depending on where they are, such as grass. Models support specifying \u201ctint indices\u201d on faces, which are integers that can then be handled by IBlockColor s and IItemColor s. See the wiki for information on how tint indices are defined in vanilla models. IBlockColor / IItemColor Both of these are single-method interfaces. IBlockColor takes an IBlockState , an (nullable) IBlockAccess , and a (nullable) BlockPos . IItemColor takes an ItemStack . Both of them take a parameter tintindex , which is the tint index of the face being colored. Both of them return an int , a color multiplier. This int is treated as 4 unsigned bytes, alpha, red, green, and blue, in that order, from most significant byte to least. For each pixel in the tinted face, the value of each color channel is (int)((float)base * multiplier / 255) , where base is the original value for the channel, and multiplier is the associated byte from the color multiplier. Note that blocks do not use the alpha channel. For example, the grass texture, untinted, looks white and gray. The IBlockColor and IItemColor for grass return color multipliers with low red and blue components, but high alpha and green components, (at least in worm biomes) so when the multiplication is performed, the green is brought out and the red/blue diminished. If an item inherits from the builtin/generated model, each layer (\u201clayer0\u201d, \u201clayer1\u201d, etc.) has a tint index corresponding to its layer index. Creating Color Handlers IBlockColors need to be registered to the BlockColors instance of the game. BlockColors can be acquired through Minecraft.getMinecraft().getBlockColors() , and an IBlockColor can be registered by BlockColors::registerBlockColorHandler . Note that this does not cause the ItemBlock for the given block to be colored. ItemBlock s are items and need to colored with an IItemColor . IItemColors need to be registered to the ItemColors instance of the game. ItemColors can be acquired through Minecraft.getMinecraft().getItemColors() , and an IItemColor can be registered by ItemColors::registerItemColorHandler . This method is overloaded to also take Block s, which simply registers the color handler for the item Item.getItemFromBlock(block) (i.e. the block\u2019s ItemBlock ). This registration must be done client-side, in the initialization phase.","title":"Coloring Textures"},{"location":"models/color/#coloring-textures","text":"Many blocks and items in vanilla change their texture color depending on where they are, such as grass. Models support specifying \u201ctint indices\u201d on faces, which are integers that can then be handled by IBlockColor s and IItemColor s. See the wiki for information on how tint indices are defined in vanilla models.","title":"Coloring Textures"},{"location":"models/color/#iblockcoloriitemcolor","text":"Both of these are single-method interfaces. IBlockColor takes an IBlockState , an (nullable) IBlockAccess , and a (nullable) BlockPos . IItemColor takes an ItemStack . Both of them take a parameter tintindex , which is the tint index of the face being colored. Both of them return an int , a color multiplier. This int is treated as 4 unsigned bytes, alpha, red, green, and blue, in that order, from most significant byte to least. For each pixel in the tinted face, the value of each color channel is (int)((float)base * multiplier / 255) , where base is the original value for the channel, and multiplier is the associated byte from the color multiplier. Note that blocks do not use the alpha channel. For example, the grass texture, untinted, looks white and gray. The IBlockColor and IItemColor for grass return color multipliers with low red and blue components, but high alpha and green components, (at least in worm biomes) so when the multiplication is performed, the green is brought out and the red/blue diminished. If an item inherits from the builtin/generated model, each layer (\u201clayer0\u201d, \u201clayer1\u201d, etc.) has a tint index corresponding to its layer index.","title":"IBlockColor/IItemColor"},{"location":"models/color/#creating-color-handlers","text":"IBlockColors need to be registered to the BlockColors instance of the game. BlockColors can be acquired through Minecraft.getMinecraft().getBlockColors() , and an IBlockColor can be registered by BlockColors::registerBlockColorHandler . Note that this does not cause the ItemBlock for the given block to be colored. ItemBlock s are items and need to colored with an IItemColor . IItemColors need to be registered to the ItemColors instance of the game. ItemColors can be acquired through Minecraft.getMinecraft().getItemColors() , and an IItemColor can be registered by ItemColors::registerItemColorHandler . This method is overloaded to also take Block s, which simply registers the color handler for the item Item.getItemFromBlock(block) (i.e. the block\u2019s ItemBlock ). This registration must be done client-side, in the initialization phase.","title":"Creating Color Handlers"},{"location":"models/files/","text":"Model Files A \u201cmodel\u201d is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you\u2019ll see will be in the vanilla JSON format. Models in other formats are loaded into IModel s by an ICustomModelLoader at runtime. Forge provides default implementations for WaveFront OBJ files and Blitz3D files. Most things do not care about what loaded the model or what format it\u2019s in as they all implement a common interface, IModel , in code. When ResourceLocation refers to a model, the path is normally relative to models (e.g. examplemod:block/block \u2192 assets/examplemod/models/block/block ). A notable exception is within a blockstate JSON (all 3 formats), where model paths are relative to models/block (e.g. examplemod:block \u2192 assets/examplemod/models/block/block ). Block and item models differ in a few ways, the major one being item property overrides . Textures Textures, like models, are contained within resource packs and are referred to with ResourceLocation s. When ResourceLocation s refer to textures in models, the paths are taken to be relative to textures/ (e.g. examplemod:blocks/test \u2192 assets/examplemod/textures/blocks/test.png ). Additionally, in Minecraft, the UV coordinates (0,0) are taken to mean the top-left corner. UVs are always from 0 to 16. If a texture is larger or smaller, the coordinates are scaled to fit. A texture must also be square, and the side length of a texture should be a power of two, as doing otherwise breaks mipmapping. (E.g. 1x1, 2x2, 8x8, 16x16, and 128x128 are good. 5x5 and 30x30 are not recommended because they are not powers of 2. 5x10 and 4x8 are completely broken as they are not square.) If there is an mcmeta file associated with the texture, and an animation is defined, the image can be rectangular and is interpreted as a vertical sequence of square regions from top to bottom, where each square is a frame of the animation. JSON Models Vanilla Minecraft\u2019s JSON model format is rather simple. It defines cuboid (cube/rectangular prism) elements, and assigns textures to their faces. On the wiki , there is a definition of its format. Note JSON models only support cuboid elements; there is no way to express a triangular wedge or anything like it. To have more complicated models, another format must be used. When a ResourceLocation refers to the location of a JSON model, it is not suffixed with .json , unlike OBJ and B3D models (e.g. minecraft:block/cube_all , not minecraft:block/cube_all.json ). WaveFront OBJ Models Forge adds a loader for the .obj file format. To use these models, the resource namespace must be registered through OBJLoader.addDomain . This loader accepts any model location that is in a registered namespace and whose path ends in .obj . The .mtl file should be placed next to the .obj and will automatically be used with the .obj . The .mtl file will probably have to be manually edited to change the paths pointing to textures into Minecraft ResourceLocation s. Additinally, the V axis for textures may be flipped depending on the external program that created the model (i.e. V = 0 may be the bottom edge, not the top). This may be rectified in the modelling program itself or done in a Forge blockstate JSON like so: { \"__comment\": \"Add the following line on the same level as a 'model' declaration.\", \"custom\": { \"flip-v\": true }, \"model\": \"examplemod:model.obj\" } Blitz3D Models Forge adds a loader for the .b3d file format. To use these models, the resource namespace must be registered through B3DLoader.addDomain . This loader accepts any model location that is in a registered namespace and whose path ends in .b3d .","title":"Model Files"},{"location":"models/files/#model-files","text":"A \u201cmodel\u201d is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you\u2019ll see will be in the vanilla JSON format. Models in other formats are loaded into IModel s by an ICustomModelLoader at runtime. Forge provides default implementations for WaveFront OBJ files and Blitz3D files. Most things do not care about what loaded the model or what format it\u2019s in as they all implement a common interface, IModel , in code. When ResourceLocation refers to a model, the path is normally relative to models (e.g. examplemod:block/block \u2192 assets/examplemod/models/block/block ). A notable exception is within a blockstate JSON (all 3 formats), where model paths are relative to models/block (e.g. examplemod:block \u2192 assets/examplemod/models/block/block ). Block and item models differ in a few ways, the major one being item property overrides .","title":"Model Files"},{"location":"models/files/#textures","text":"Textures, like models, are contained within resource packs and are referred to with ResourceLocation s. When ResourceLocation s refer to textures in models, the paths are taken to be relative to textures/ (e.g. examplemod:blocks/test \u2192 assets/examplemod/textures/blocks/test.png ). Additionally, in Minecraft, the UV coordinates (0,0) are taken to mean the top-left corner. UVs are always from 0 to 16. If a texture is larger or smaller, the coordinates are scaled to fit. A texture must also be square, and the side length of a texture should be a power of two, as doing otherwise breaks mipmapping. (E.g. 1x1, 2x2, 8x8, 16x16, and 128x128 are good. 5x5 and 30x30 are not recommended because they are not powers of 2. 5x10 and 4x8 are completely broken as they are not square.) If there is an mcmeta file associated with the texture, and an animation is defined, the image can be rectangular and is interpreted as a vertical sequence of square regions from top to bottom, where each square is a frame of the animation.","title":"Textures"},{"location":"models/files/#json-models","text":"Vanilla Minecraft\u2019s JSON model format is rather simple. It defines cuboid (cube/rectangular prism) elements, and assigns textures to their faces. On the wiki , there is a definition of its format. Note JSON models only support cuboid elements; there is no way to express a triangular wedge or anything like it. To have more complicated models, another format must be used. When a ResourceLocation refers to the location of a JSON model, it is not suffixed with .json , unlike OBJ and B3D models (e.g. minecraft:block/cube_all , not minecraft:block/cube_all.json ).","title":"JSON Models"},{"location":"models/files/#wavefront-obj-models","text":"Forge adds a loader for the .obj file format. To use these models, the resource namespace must be registered through OBJLoader.addDomain . This loader accepts any model location that is in a registered namespace and whose path ends in .obj . The .mtl file should be placed next to the .obj and will automatically be used with the .obj . The .mtl file will probably have to be manually edited to change the paths pointing to textures into Minecraft ResourceLocation s. Additinally, the V axis for textures may be flipped depending on the external program that created the model (i.e. V = 0 may be the bottom edge, not the top). This may be rectified in the modelling program itself or done in a Forge blockstate JSON like so: { \"__comment\": \"Add the following line on the same level as a 'model' declaration.\", \"custom\": { \"flip-v\": true }, \"model\": \"examplemod:model.obj\" }","title":"WaveFront OBJ Models"},{"location":"models/files/#blitz3d-models","text":"Forge adds a loader for the .b3d file format. To use these models, the resource namespace must be registered through B3DLoader.addDomain . This loader accepts any model location that is in a registered namespace and whose path ends in .b3d .","title":"Blitz3D Models"},{"location":"models/introduction/","text":"Intro to Models The model system is Minecraft\u2019s way of giving blocks and items their shapes. Through the model system, blocks and items are mapped to their models, which define how they look. One of the main goals of the model system is to allow not only textures but the entire shape of a block/item to be changed by resource packs. Indeed, any mod that adds items or blocks also contains a mini-resource pack for their blocks and items. In order to link code to models and textures on disk, there exists the class ResourceLocation . One may recognize them from the registry system; however, their original purpose was to identify files on disk; they just happened to be useful as unique identifiers as well. A ResourceLocation is a simple object composed of 2 String s: a namespace and a path. When a ResourceLocation is represented as a plain string, it looks like namespace:path . When a ResourceLocation is created and a namespace isn\u2019t explicitly given, the namespace defaults to minecraft . However, it is good practice to include the namespace anyway. The namespace of a ResourceLocation in the model system represents a directory directly underneath assets/ . Usually, the namespace is the same as the modid (e.g. in vanilla Minecraft the namespace is always minecraft ). The path portion of a ResourceLocation represents a context-sensitive path to file underneath the namespace. What the path means and where exactly it points depends on what\u2019s using it. For example, when refering to a model, the path is normally resolved under models , but when refering to a texture it\u2019s under textures . Therefore, mod:file means assets/mod/models/file in one context but assets/mod/textures/file in another. When something is described as requiring a ResourceLocation , it will be defined what exactly the path means. All strings related to the model system (especially ResourceLocation s) should be in snake case (meaning_all_lowercase_and_underscore_separated_words_like_this). This is enforced since Minecraft 1.11.","title":"Intro to Models"},{"location":"models/introduction/#intro-to-models","text":"The model system is Minecraft\u2019s way of giving blocks and items their shapes. Through the model system, blocks and items are mapped to their models, which define how they look. One of the main goals of the model system is to allow not only textures but the entire shape of a block/item to be changed by resource packs. Indeed, any mod that adds items or blocks also contains a mini-resource pack for their blocks and items. In order to link code to models and textures on disk, there exists the class ResourceLocation . One may recognize them from the registry system; however, their original purpose was to identify files on disk; they just happened to be useful as unique identifiers as well. A ResourceLocation is a simple object composed of 2 String s: a namespace and a path. When a ResourceLocation is represented as a plain string, it looks like namespace:path . When a ResourceLocation is created and a namespace isn\u2019t explicitly given, the namespace defaults to minecraft . However, it is good practice to include the namespace anyway. The namespace of a ResourceLocation in the model system represents a directory directly underneath assets/ . Usually, the namespace is the same as the modid (e.g. in vanilla Minecraft the namespace is always minecraft ). The path portion of a ResourceLocation represents a context-sensitive path to file underneath the namespace. What the path means and where exactly it points depends on what\u2019s using it. For example, when refering to a model, the path is normally resolved under models , but when refering to a texture it\u2019s under textures . Therefore, mod:file means assets/mod/models/file in one context but assets/mod/textures/file in another. When something is described as requiring a ResourceLocation , it will be defined what exactly the path means. All strings related to the model system (especially ResourceLocation s) should be in snake case (meaning_all_lowercase_and_underscore_separated_words_like_this). This is enforced since Minecraft 1.11.","title":"Intro to Models"},{"location":"models/overrides/","text":"Item Property Overrides Item properties are a way for the \u201cproperties\u201d of items to be exposed to the model system. An example is the bow, where the most important property is how far the bow has been pulled. This information is then used to choose a model for the bow, creating an animation for pulling it. This is different from assigning ModelResourceLocation s directly to items through ModelLoader.setCustomModelResourceLocation or ModelLoader.setCustomMeshDefinition . These methods fix the possible set of models. Used on a bow, for example, these methods would permanently fix the number of frames in the pull animation to 4. However, properties are more flexible. An item property assigns a certain float value to every ItemStack it is registered for, and vanilla item model definitions can use these values to define \u201coverrides\u201d, where an item defaults to a certain model, but if an override matches, it overrides the model and uses another. The format of item models, including overrides, can be found on the [wiki][]. They are useful mainly because of the fact that they are continuous. For example, bows use item properties to define their pull animation. Since the value of the property is a float , it increases continuously from 0 to 1. This allows resource packs to add as many models as they want for the bow pulling animation along that spectrum, instead of being stuck with four \u201cslots\u201d for their models in the animation. The same is true of the compass and clock. Adding Properties to Items Item::addPropertyOverride is used to add a property to an item. The ResourceLocation parameter is the name given to the property (e.g. new ResourceLocation(\"pull\") ). The IItemPropertyGetter is a function that takes the ItemStack , the World it\u2019s in, and the EntityLivingBase that holds it, returning the float value for the property. Some examples are the \"pulling\" and \u201c pull \u201d properties in ItemBow , and the several static final ones in Item . For modded item properties, it is recommended that the modid of the mod is used as the namespace (e.g. examplemod:property and not just property , as that really means minecraft:property ). Using Overrides The format of an override can be seen on the wiki , and a good example can be found in model/item/bow.json . For reference, here is a hypothetical example of an item with an examplemod:power property. If the values have no match, the default is the current model. Important A predicate applies to all values greater than or equal to the given value. { \"parent\": \"item/generated\", \"textures\": { \"__comment\": \"Default\", \"layer0\": \"examplemod:items/examplePartial\" }, \"overrides\": [ { \"__comment\": \"power >= .75\", \"predicate\": { \"examplemod:power\": 0.75 }, \"model\": \"examplemod:item/examplePowered\" } ] } And here\u2019s a hypothetical snippet from the supporting code. (This does not have to be client-only; it will work on a server too. In vanilla, properties are registered in the item\u2019s constructor.) item.addPropertyOverride(new IItemPropertyGetter() { @SideOnly(Side.CLIENT) @Override public float apply(ItemStack stack, @Nullable World world, @Nullable EntityLivingBase entity) { return (float)getPowerLevel(stack) / (float)getMaxPower(stack); // Some external methods } }","title":"Item Property Overrides"},{"location":"models/overrides/#item-property-overrides","text":"Item properties are a way for the \u201cproperties\u201d of items to be exposed to the model system. An example is the bow, where the most important property is how far the bow has been pulled. This information is then used to choose a model for the bow, creating an animation for pulling it. This is different from assigning ModelResourceLocation s directly to items through ModelLoader.setCustomModelResourceLocation or ModelLoader.setCustomMeshDefinition . These methods fix the possible set of models. Used on a bow, for example, these methods would permanently fix the number of frames in the pull animation to 4. However, properties are more flexible. An item property assigns a certain float value to every ItemStack it is registered for, and vanilla item model definitions can use these values to define \u201coverrides\u201d, where an item defaults to a certain model, but if an override matches, it overrides the model and uses another. The format of item models, including overrides, can be found on the [wiki][]. They are useful mainly because of the fact that they are continuous. For example, bows use item properties to define their pull animation. Since the value of the property is a float , it increases continuously from 0 to 1. This allows resource packs to add as many models as they want for the bow pulling animation along that spectrum, instead of being stuck with four \u201cslots\u201d for their models in the animation. The same is true of the compass and clock.","title":"Item Property Overrides"},{"location":"models/overrides/#adding-properties-to-items","text":"Item::addPropertyOverride is used to add a property to an item. The ResourceLocation parameter is the name given to the property (e.g. new ResourceLocation(\"pull\") ). The IItemPropertyGetter is a function that takes the ItemStack , the World it\u2019s in, and the EntityLivingBase that holds it, returning the float value for the property. Some examples are the \"pulling\" and \u201c pull \u201d properties in ItemBow , and the several static final ones in Item . For modded item properties, it is recommended that the modid of the mod is used as the namespace (e.g. examplemod:property and not just property , as that really means minecraft:property ).","title":"Adding Properties to Items"},{"location":"models/overrides/#using-overrides","text":"The format of an override can be seen on the wiki , and a good example can be found in model/item/bow.json . For reference, here is a hypothetical example of an item with an examplemod:power property. If the values have no match, the default is the current model. Important A predicate applies to all values greater than or equal to the given value. { \"parent\": \"item/generated\", \"textures\": { \"__comment\": \"Default\", \"layer0\": \"examplemod:items/examplePartial\" }, \"overrides\": [ { \"__comment\": \"power >= .75\", \"predicate\": { \"examplemod:power\": 0.75 }, \"model\": \"examplemod:item/examplePowered\" } ] } And here\u2019s a hypothetical snippet from the supporting code. (This does not have to be client-only; it will work on a server too. In vanilla, properties are registered in the item\u2019s constructor.) item.addPropertyOverride(new IItemPropertyGetter() { @SideOnly(Side.CLIENT) @Override public float apply(ItemStack stack, @Nullable World world, @Nullable EntityLivingBase entity) { return (float)getPowerLevel(stack) / (float)getMaxPower(stack); // Some external methods } }","title":"Using Overrides"},{"location":"models/using/","text":"Connecting Blocks and Items to Models Block Models Blocks are not directly linked to models, instead, block states are mapped to ModelResourceLocation s, which point to models (\u201cmodels\u201d includes blockstate JSONs). An IBlockState is mapped to a ModelResourceLocation by an IStateMapper . The default statemapper, which works by default for all blocks, works as follows: Get the registry name of the blockstate\u2019s block. Set said name as the ResourceLocation part of the ModelResourceLocation . Get all properties and their values in the blockstate. Get the name of each property with IProperty#getName . Get the name of each value with IProperty<T>#getName(T) . Sort the pairs alphabetically by the name of the property only . Produce a comma delimited string of key-value pairs (e.g. a=b,c=d,e=f ). Set that as the variant part of the ModelResourceLocation . If the variant string is empty (i.e. no properties defined), default the variant to normal . The variant string is silently toLowerCase d, so if a statemapper returns mod:model#VARIANT , the game will query the JSON for the string \u201cvariant\u201d, not \u201cVARIANT.\u201d Custom IStateMapper s It\u2019s simple to use a custom IStateMapper . Once an instance is acquired, it may be registered with a call to ModelLoader.setCustomStateMapper . IStateMapper s are registered per block, so this method receives both the IStateMapper and the block it works on. There is also a builder StateMap.Builder for some common use cases. StateMap.Builder The builder StateMap.Builder can create IStateMapper s for some of the most common use cases. Once one is instantiated, methods can be called to set its parameters, and a call to build will generate an IStateMapper using those parameters. withName withName takes a property as argument and sets that as the \u201cname\u201d (actually the path) of the returned ModelResourceLocation . When the resulting IStateMapper is applied to a blockstate, it takes the value of the property given, then finds the name for that value, and uses that as the resource path. It is clearer with an example: PropertyDirection PROP_FACING = PropertyDirection.create(\"facing\"); // Start with a property IStateMapper mapper = new StateMap.Builder().withName(PROP_FACING).build(); // Use the builder Now, if mapper is asked to find the ModelResourceLocation for the blockstate examplemod:block1[facing=east] , it will map it to examplemod:east#normal . Given examplemod:block2[color=red,facing=north] , it will map it to examplemod:north#color=red . withSuffix The suffix is a plain string that gets tacked on to the end of the resource path. For example, if the suffix is set to _suff , the resulting IStateMapper will map the blockstate examplemod:block[facing=east] to the ModelResourceLocation examplemod:block_suff#facing=east . ignore This causes the IStateMapper to simply ignore the given properties when mapping a blockstate. When called twice, the two lists are merged. An example: PropertyDirection PROP_OUT = PropertyDirection.create(\"out\"); PropertyDirection PROP_IN = PropertyDirection.create(\"in\"); // These two are equivalent IStateMapper together = new StateMap.Builder().ignore(PROP_OUT, PROP_IN).build(); IStateMapper merged = new StateMap.Builder().ignore(PROP_OUT).ignore(PROP_IN).build(); When either together or merged are asked to map the blockstate examplemod:block1[in=north,out=south] , they\u2019ll give the ModelResourceLocation examplemod:block1#normal . Given examplemod:block2[in=north,out=south,color=blue] , they\u2019ll produce examplemod:block2#color=blue . Finally, given examplemod:block3[color=white,out=east] (no in ), they\u2019ll produce examplemod:block3#color=white . Item Models Unlike blocks, which automatically have a default IStateMapper that works without any extra registration, items must be registered to their models manually. This is done through ModelLoader.setCustomModelResourceLocation . This method takes the item, a metadata value, and a ModelResourceLocation , and registers a mapping so that all ItemStack s with the item and metadata given use the given ModelResourceLocation for their model. The way the game searches for the model is as follows: For a ModelResourceLocation <namespace>:<path>#<varstr> Attempt to find a custom model loader that volunteers to load this model. If that succeeds, load the model with the found loader and break out of these instructions. If that fails, attempt to load it from the blockstate JSON loader. If that fails, attempt to load it from the vanilla JSON loader (which loads the model assets/<namespace>/models/item/<path>.json ). JSON item models from models/item can also leverage overrides . Note ModelLoader.setCustomModelResourceLocation also calls ModelLoader.registerItemVariants with the item and ModelResourceLocation given. This sets up the model for baking later. ItemMeshDefinition An ItemMeshDefinition is a function that takes ItemStack s and maps them to ModelResourceLocation s. They are registered per item, and this can be done with ModelLoader.setCustomMeshDefinition , which takes an item and the ItemMeshDefinition to use for its ItemStack s. Important ModelLoader.setCustomMeshDefinition does not call ModelLoader.registerItemVariants . Therefore, ModelLoader.registerItemVariants method must be passed every ModelResourceLocation the ItemMeshDefinition can return in order for it to work. Blockstate JSONs for Items Note that items can use block state JSONs. This is possible by simply passing a ModelResourceLocation pointing to a blockstate JSON into ModelLoader.setCustomModelResourceLocation or returning it from an ItemMeshDefinition . Doing so allows the model to take advantage of things like submodels and combining variants. The two main use cases are items that share their models with blocks (especially ItemBlock s) and the default item layer model (The textures block inside combining variant definitions can be used to build up the layers of the model, with one property setting layer0 , another setting layer1 , etc.). Note 1.9 multipart blockstates will not work as item models out of the box, as they require an IBlockState to select a model. Important There is one major caveat. Blockstate JSONs can only resolve paths to models under models/block ; they cannot see models under models/item (even using ../item causes an error). This means that the minecraft:item/generated model (which sets the default transforms for items) cannot be used in a blockstate JSON. As a workaround, the minecraft:builtin/generated model can be used instead and the transforms set with the transform tag in the blockstate JSON. (Block models that inherit from minecraft:block/block already set transforms, so this isn\u2019t necessary for them.) Here\u2019s an example: \"defaults\": { \"model\": \"builtin/generated\", \"__comment\": \"Get Forge to inject the default rotations and scales for an item in a player's hand, on the ground, etc.\", \"transform\": \"forge:default-item\" }","title":"Connecting Blocks and Items to Models"},{"location":"models/using/#connecting-blocks-and-items-to-models","text":"","title":"Connecting Blocks and Items to Models"},{"location":"models/using/#block-models","text":"Blocks are not directly linked to models, instead, block states are mapped to ModelResourceLocation s, which point to models (\u201cmodels\u201d includes blockstate JSONs). An IBlockState is mapped to a ModelResourceLocation by an IStateMapper . The default statemapper, which works by default for all blocks, works as follows: Get the registry name of the blockstate\u2019s block. Set said name as the ResourceLocation part of the ModelResourceLocation . Get all properties and their values in the blockstate. Get the name of each property with IProperty#getName . Get the name of each value with IProperty<T>#getName(T) . Sort the pairs alphabetically by the name of the property only . Produce a comma delimited string of key-value pairs (e.g. a=b,c=d,e=f ). Set that as the variant part of the ModelResourceLocation . If the variant string is empty (i.e. no properties defined), default the variant to normal . The variant string is silently toLowerCase d, so if a statemapper returns mod:model#VARIANT , the game will query the JSON for the string \u201cvariant\u201d, not \u201cVARIANT.\u201d","title":"Block Models"},{"location":"models/using/#custom-istatemappers","text":"It\u2019s simple to use a custom IStateMapper . Once an instance is acquired, it may be registered with a call to ModelLoader.setCustomStateMapper . IStateMapper s are registered per block, so this method receives both the IStateMapper and the block it works on. There is also a builder StateMap.Builder for some common use cases.","title":"Custom IStateMappers"},{"location":"models/using/#statemapbuilder","text":"The builder StateMap.Builder can create IStateMapper s for some of the most common use cases. Once one is instantiated, methods can be called to set its parameters, and a call to build will generate an IStateMapper using those parameters.","title":"StateMap.Builder"},{"location":"models/using/#withname","text":"withName takes a property as argument and sets that as the \u201cname\u201d (actually the path) of the returned ModelResourceLocation . When the resulting IStateMapper is applied to a blockstate, it takes the value of the property given, then finds the name for that value, and uses that as the resource path. It is clearer with an example: PropertyDirection PROP_FACING = PropertyDirection.create(\"facing\"); // Start with a property IStateMapper mapper = new StateMap.Builder().withName(PROP_FACING).build(); // Use the builder Now, if mapper is asked to find the ModelResourceLocation for the blockstate examplemod:block1[facing=east] , it will map it to examplemod:east#normal . Given examplemod:block2[color=red,facing=north] , it will map it to examplemod:north#color=red .","title":"withName"},{"location":"models/using/#withsuffix","text":"The suffix is a plain string that gets tacked on to the end of the resource path. For example, if the suffix is set to _suff , the resulting IStateMapper will map the blockstate examplemod:block[facing=east] to the ModelResourceLocation examplemod:block_suff#facing=east .","title":"withSuffix"},{"location":"models/using/#ignore","text":"This causes the IStateMapper to simply ignore the given properties when mapping a blockstate. When called twice, the two lists are merged. An example: PropertyDirection PROP_OUT = PropertyDirection.create(\"out\"); PropertyDirection PROP_IN = PropertyDirection.create(\"in\"); // These two are equivalent IStateMapper together = new StateMap.Builder().ignore(PROP_OUT, PROP_IN).build(); IStateMapper merged = new StateMap.Builder().ignore(PROP_OUT).ignore(PROP_IN).build(); When either together or merged are asked to map the blockstate examplemod:block1[in=north,out=south] , they\u2019ll give the ModelResourceLocation examplemod:block1#normal . Given examplemod:block2[in=north,out=south,color=blue] , they\u2019ll produce examplemod:block2#color=blue . Finally, given examplemod:block3[color=white,out=east] (no in ), they\u2019ll produce examplemod:block3#color=white .","title":"ignore"},{"location":"models/using/#item-models","text":"Unlike blocks, which automatically have a default IStateMapper that works without any extra registration, items must be registered to their models manually. This is done through ModelLoader.setCustomModelResourceLocation . This method takes the item, a metadata value, and a ModelResourceLocation , and registers a mapping so that all ItemStack s with the item and metadata given use the given ModelResourceLocation for their model. The way the game searches for the model is as follows: For a ModelResourceLocation <namespace>:<path>#<varstr> Attempt to find a custom model loader that volunteers to load this model. If that succeeds, load the model with the found loader and break out of these instructions. If that fails, attempt to load it from the blockstate JSON loader. If that fails, attempt to load it from the vanilla JSON loader (which loads the model assets/<namespace>/models/item/<path>.json ). JSON item models from models/item can also leverage overrides . Note ModelLoader.setCustomModelResourceLocation also calls ModelLoader.registerItemVariants with the item and ModelResourceLocation given. This sets up the model for baking later.","title":"Item Models"},{"location":"models/using/#itemmeshdefinition","text":"An ItemMeshDefinition is a function that takes ItemStack s and maps them to ModelResourceLocation s. They are registered per item, and this can be done with ModelLoader.setCustomMeshDefinition , which takes an item and the ItemMeshDefinition to use for its ItemStack s. Important ModelLoader.setCustomMeshDefinition does not call ModelLoader.registerItemVariants . Therefore, ModelLoader.registerItemVariants method must be passed every ModelResourceLocation the ItemMeshDefinition can return in order for it to work.","title":"ItemMeshDefinition"},{"location":"models/using/#blockstate-jsons-for-items","text":"Note that items can use block state JSONs. This is possible by simply passing a ModelResourceLocation pointing to a blockstate JSON into ModelLoader.setCustomModelResourceLocation or returning it from an ItemMeshDefinition . Doing so allows the model to take advantage of things like submodels and combining variants. The two main use cases are items that share their models with blocks (especially ItemBlock s) and the default item layer model (The textures block inside combining variant definitions can be used to build up the layers of the model, with one property setting layer0 , another setting layer1 , etc.). Note 1.9 multipart blockstates will not work as item models out of the box, as they require an IBlockState to select a model. Important There is one major caveat. Blockstate JSONs can only resolve paths to models under models/block ; they cannot see models under models/item (even using ../item causes an error). This means that the minecraft:item/generated model (which sets the default transforms for items) cannot be used in a blockstate JSON. As a workaround, the minecraft:builtin/generated model can be used instead and the transforms set with the transform tag in the blockstate JSON. (Block models that inherit from minecraft:block/block already set transforms, so this isn\u2019t necessary for them.) Here\u2019s an example: \"defaults\": { \"model\": \"builtin/generated\", \"__comment\": \"Get Forge to inject the default rotations and scales for an item in a player's hand, on the ground, etc.\", \"transform\": \"forge:default-item\" }","title":"Blockstate JSONs for Items"},{"location":"models/advanced/extended-blockstates/","text":"Extended Blockstates Extended blockstates provide a way for blocks to pass arbitrary data to their models. Ordinary blockstates and properties occupy only a fixed set of possible states, while extended states can form infinite sets. This accomplished through the use of unlisted properties ( IUnlistedProperty<V> ), extended block states ( IExtendedBlockState ), and extended block state containers ( ExtendedBlockState ). Ordinary block state containers ( BlockStateContainer ) take a set of listed properties ( IProperty<V> ) that define all possible values for themselves and use those to create all possible combinatons of values. These combinations are then turned into IBlockState s and stored in the finite set of all possible states. The properties are called \u201clisted\u201d as they appear on the F3 debug screen, all the way to the right. Extended block state containers take a set of listed properties, and also a set of unlisted properties. Unlisted properties\u2019 values can be anything that matches their type, and are not limited to a finite set. However, values are still required to satisfy the predicate IUnlistedProperty::isValid . The listed properties are again used to create the set of states, this time IExtendedBlockState s, but the unlisted properties remain unset. The unlisted properties are only set when IExtendedBlockState::withProperty is called to do so. Most of the methods on IExtendedBlockState are self-explanatory, maybe with the exception of getClean . getClean returns the base IBlockState with none of the unlisted properties set. Why Extended Blockstates Why use extended blockstates at all? Why not simply pass an IBlockAccess and BlockPos into the rendering system directly and have the IBakedModel itself deal with it? Indeed, extended blockstates allow this to happen anyway! Why have the system at all when we could just do that? The reason is that it makes the system more flexible. External code can take an IExtendedBlockState and fill in some data by itself, overriding the block\u2019s own data. This allows that code to alter the model in ways that would be impossible if it was just a black box that took a world and a position and spat out some geometry. One such use case is advanced camouflaging blocks. The camouflaging block may have a tile entity that holds the IBlockState representative of the camouflagee, and an unlisted property to hold that state during rendering. This property can then be filled by getExtendedState . Finally, a custom IBakedModel can steal the model for that state and use it instead of using the uncamouflaged model. Declaring Unlisted Properties Unlisted properties are declared in Block.createBlockState , the same place as regular (\u201clisted\u201d) properties. Instead of returning a BlockStateContainer , one must return an ExtendedBlockState . Forge provides a builder BlockStateContainer.Builder , which will automatically handle returning an ExtendedBlockState for you. Example: @Override public BlockStateContainer createBlockState() { return new BlockStateContainer.Builder(this).add(LISTED_PROP).add(UNLISTED_PROP).build(); } Note that you do not need to set default values for your unlisted properties. Filling Extended States Before an IBlockState is passed to an IBakedModel , it will always have Block.getExtendedState called on it first. In this method, you will give all your unlisted properties values. Assuming you registered at least one unlisted property in the previous section, the IBlockState parameter can be safely casted to IExtendedBlockState , which has a withProperty method for unlisted properties analogous to its listed property cousin. Here, you can query whatever you want from the World, the Tile Entity, etc. (with appropriate safety checks, of course) and insert it into the extended blockstate. Warning It is highly recommended that your unlisted property values be immutable. Baked model implementations will use the extended state and unlisted values on multiple threads, so any value must be used in a threadsafe manner. The easiest way is to simply make that information an immutable snapshot. Anything you might possibly want to know in your custom IBakedModel , you should be passing an immutable snapshot of through Block.getExtendedState . Example: @Override public IExtendedBlockState getExtendedState(IBlockState state, IBlockAccess world, BlockPos pos) { IExtendedBlockState ext = (IExtendedBlockState) state; TileEntity te = world.getTileEntity(pos); if (te instanceof MyTE) { ext = ext.withProperty(UNLISTED_PROP, ((MyTE) te).getSomeImmutableData()); } return ext; } Using Extended States In a custom IBakedModel , the IBlockState parameter passed to you will be exactly the object you returned in Block.getExtendedState , and you can pull data out of it and use it to affect your rendering as you wish. Here is a basic example of using an unlisted property to determine which model to render, assuming UNLISTED_PROP is an IUnlistedProperty<String> : // in custom IBakedModel private final Map<String, IBakedModel> submodels = new HashMap<>(); // populated in a custom manner out of the scope of this article @Override public List<BakedQuad> getQuads(@Nullable IBlockState state, EnumFacing facing, long rand) { IBakedModel fallback = Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelShapes().getModelManager().getMissingModel(); if (state == null) return fallback.getQuads(state, facing, rand); IExtendedBlockState ex = (IExtendedBlockState) state; String id = ex.getValue(UNLISTED_PROP); return submodels.getOrDefault(id, fallback).getQuads(state, facing, rand); } Since there are no longer a fixed set of IExtendedBlockState generated at startup, comparisons involving an extended state must use getClean() , which is a method on IExtendedBlockState that returns the vanilla state (i.e. the fixed set of IBlockState with only the listed properties). IExtendedBlockState state = ...; IBlockState worldState = world.getBlockState(pos); if(state.getClean() == worldState) { ... }","title":"Extended Blockstates"},{"location":"models/advanced/extended-blockstates/#extended-blockstates","text":"Extended blockstates provide a way for blocks to pass arbitrary data to their models. Ordinary blockstates and properties occupy only a fixed set of possible states, while extended states can form infinite sets. This accomplished through the use of unlisted properties ( IUnlistedProperty<V> ), extended block states ( IExtendedBlockState ), and extended block state containers ( ExtendedBlockState ). Ordinary block state containers ( BlockStateContainer ) take a set of listed properties ( IProperty<V> ) that define all possible values for themselves and use those to create all possible combinatons of values. These combinations are then turned into IBlockState s and stored in the finite set of all possible states. The properties are called \u201clisted\u201d as they appear on the F3 debug screen, all the way to the right. Extended block state containers take a set of listed properties, and also a set of unlisted properties. Unlisted properties\u2019 values can be anything that matches their type, and are not limited to a finite set. However, values are still required to satisfy the predicate IUnlistedProperty::isValid . The listed properties are again used to create the set of states, this time IExtendedBlockState s, but the unlisted properties remain unset. The unlisted properties are only set when IExtendedBlockState::withProperty is called to do so. Most of the methods on IExtendedBlockState are self-explanatory, maybe with the exception of getClean . getClean returns the base IBlockState with none of the unlisted properties set.","title":"Extended Blockstates"},{"location":"models/advanced/extended-blockstates/#why-extended-blockstates","text":"Why use extended blockstates at all? Why not simply pass an IBlockAccess and BlockPos into the rendering system directly and have the IBakedModel itself deal with it? Indeed, extended blockstates allow this to happen anyway! Why have the system at all when we could just do that? The reason is that it makes the system more flexible. External code can take an IExtendedBlockState and fill in some data by itself, overriding the block\u2019s own data. This allows that code to alter the model in ways that would be impossible if it was just a black box that took a world and a position and spat out some geometry. One such use case is advanced camouflaging blocks. The camouflaging block may have a tile entity that holds the IBlockState representative of the camouflagee, and an unlisted property to hold that state during rendering. This property can then be filled by getExtendedState . Finally, a custom IBakedModel can steal the model for that state and use it instead of using the uncamouflaged model.","title":"Why Extended Blockstates"},{"location":"models/advanced/extended-blockstates/#declaring-unlisted-properties","text":"Unlisted properties are declared in Block.createBlockState , the same place as regular (\u201clisted\u201d) properties. Instead of returning a BlockStateContainer , one must return an ExtendedBlockState . Forge provides a builder BlockStateContainer.Builder , which will automatically handle returning an ExtendedBlockState for you. Example: @Override public BlockStateContainer createBlockState() { return new BlockStateContainer.Builder(this).add(LISTED_PROP).add(UNLISTED_PROP).build(); } Note that you do not need to set default values for your unlisted properties.","title":"Declaring Unlisted Properties"},{"location":"models/advanced/extended-blockstates/#filling-extended-states","text":"Before an IBlockState is passed to an IBakedModel , it will always have Block.getExtendedState called on it first. In this method, you will give all your unlisted properties values. Assuming you registered at least one unlisted property in the previous section, the IBlockState parameter can be safely casted to IExtendedBlockState , which has a withProperty method for unlisted properties analogous to its listed property cousin. Here, you can query whatever you want from the World, the Tile Entity, etc. (with appropriate safety checks, of course) and insert it into the extended blockstate. Warning It is highly recommended that your unlisted property values be immutable. Baked model implementations will use the extended state and unlisted values on multiple threads, so any value must be used in a threadsafe manner. The easiest way is to simply make that information an immutable snapshot. Anything you might possibly want to know in your custom IBakedModel , you should be passing an immutable snapshot of through Block.getExtendedState . Example: @Override public IExtendedBlockState getExtendedState(IBlockState state, IBlockAccess world, BlockPos pos) { IExtendedBlockState ext = (IExtendedBlockState) state; TileEntity te = world.getTileEntity(pos); if (te instanceof MyTE) { ext = ext.withProperty(UNLISTED_PROP, ((MyTE) te).getSomeImmutableData()); } return ext; }","title":"Filling Extended States"},{"location":"models/advanced/extended-blockstates/#using-extended-states","text":"In a custom IBakedModel , the IBlockState parameter passed to you will be exactly the object you returned in Block.getExtendedState , and you can pull data out of it and use it to affect your rendering as you wish. Here is a basic example of using an unlisted property to determine which model to render, assuming UNLISTED_PROP is an IUnlistedProperty<String> : // in custom IBakedModel private final Map<String, IBakedModel> submodels = new HashMap<>(); // populated in a custom manner out of the scope of this article @Override public List<BakedQuad> getQuads(@Nullable IBlockState state, EnumFacing facing, long rand) { IBakedModel fallback = Minecraft.getMinecraft().getBlockRendererDispatcher().getBlockModelShapes().getModelManager().getMissingModel(); if (state == null) return fallback.getQuads(state, facing, rand); IExtendedBlockState ex = (IExtendedBlockState) state; String id = ex.getValue(UNLISTED_PROP); return submodels.getOrDefault(id, fallback).getQuads(state, facing, rand); } Since there are no longer a fixed set of IExtendedBlockState generated at startup, comparisons involving an extended state must use getClean() , which is a method on IExtendedBlockState that returns the vanilla state (i.e. the fixed set of IBlockState with only the listed properties). IExtendedBlockState state = ...; IBlockState worldState = world.getBlockState(pos); if(state.getClean() == worldState) { ... }","title":"Using Extended States"},{"location":"models/advanced/ibakedmodel/","text":"IBakedModel IBakedModel is the result of calling IModel::bake . Unlike IModel , which purely represents a shape without any concept of items or blocks, IBakedModel is not as abstract; it represents geometry that has been optimized and reduced to a form where it is (almost) ready to go to the GPU. It can also process the state of an item or block to change the model. In a majority of cases, it is not really necessary to implement this interface manually. One can instead use one of the existing implementations. getOverrides Returns the ItemOverrideList to use for this model. This is only used if this model is being rendered as an item. isAmbientOcclusion If the model is being rendered as a block in the world, the block in question does not emit any light, and ambient occlusion is enabled, this causes the model to be rendered with ambient occlusion. isGui3D If the model is being rendered as an item in an inventory, on the ground as an entity, on an item frame, etc. this makes it look \u201cflat.\u201d In GUIs this also disables the lighting. isBuiltInRenderer Important Unless you know what you\u2019re doing and are OK with using deprecated features, just return false from this and continue on. When rendering this as an item, returning true causes the model to not be rendered, instead falling back to TileEntityItemStackRenderer::renderItem . For certain vanilla items such as chests and banners, this method is hardcoded to copy data from the item into a TileEntity , before using a TileEntitySpecialRenderer to render that TE in place of the item. For all other items, it will use the TileEntityItemStackRenderer instance provided by Item#setTileEntityItemStackRenderer ; refer to TileEntityItemStackRenderer page for more information. getParticleTexture Whatever texture should be used for the particles. For blocks, this shows when an entity falls on it, when it breaks, etc. For items, this shows when it breaks or when it\u2019s eaten. getItemCameraTransforms Deprecated in favor of implementing handlePerspective . The default implementation is fine if handlePerspective is implmented. See Perspective . handlePerspective See Perspective . getQuads This is the main method of IBakedModel . It returns BakedQuad s, which contain the low-level vertex data that will be used to render the model. If the model is being rendered as a block, then the IBlockState passed in is non-null. Additionally, Block::getExtendedState is called to create the passed IBlockState , which allows for arbitrary data to be passed from the block to the model. If the model is being rendered as an item, the ItemOverrideList returned from getOverrides is responsible for handling the state of the item, and the IBlockState parameter will be null . The EnumFacing passed in is used for face culling. If the block against the given side of the block being rendered is opaque, then the faces associated with that side are not rendered. If that parameter is null , all faces not associated with a side are returned (that will never be culled). Note that this method is called very often: once for every combination of non-culled face and supported block render layer (anywhere between 0 to 28 times) per block in world . This method should be as fast as possible, and should probably cache heavily. The long parameter is a random number.","title":"IBakedModel"},{"location":"models/advanced/ibakedmodel/#ibakedmodel","text":"IBakedModel is the result of calling IModel::bake . Unlike IModel , which purely represents a shape without any concept of items or blocks, IBakedModel is not as abstract; it represents geometry that has been optimized and reduced to a form where it is (almost) ready to go to the GPU. It can also process the state of an item or block to change the model. In a majority of cases, it is not really necessary to implement this interface manually. One can instead use one of the existing implementations.","title":"IBakedModel"},{"location":"models/advanced/ibakedmodel/#getoverrides","text":"Returns the ItemOverrideList to use for this model. This is only used if this model is being rendered as an item.","title":"getOverrides"},{"location":"models/advanced/ibakedmodel/#isambientocclusion","text":"If the model is being rendered as a block in the world, the block in question does not emit any light, and ambient occlusion is enabled, this causes the model to be rendered with ambient occlusion.","title":"isAmbientOcclusion"},{"location":"models/advanced/ibakedmodel/#isgui3d","text":"If the model is being rendered as an item in an inventory, on the ground as an entity, on an item frame, etc. this makes it look \u201cflat.\u201d In GUIs this also disables the lighting.","title":"isGui3D"},{"location":"models/advanced/ibakedmodel/#isbuiltinrenderer","text":"Important Unless you know what you\u2019re doing and are OK with using deprecated features, just return false from this and continue on. When rendering this as an item, returning true causes the model to not be rendered, instead falling back to TileEntityItemStackRenderer::renderItem . For certain vanilla items such as chests and banners, this method is hardcoded to copy data from the item into a TileEntity , before using a TileEntitySpecialRenderer to render that TE in place of the item. For all other items, it will use the TileEntityItemStackRenderer instance provided by Item#setTileEntityItemStackRenderer ; refer to TileEntityItemStackRenderer page for more information.","title":"isBuiltInRenderer"},{"location":"models/advanced/ibakedmodel/#getparticletexture","text":"Whatever texture should be used for the particles. For blocks, this shows when an entity falls on it, when it breaks, etc. For items, this shows when it breaks or when it\u2019s eaten.","title":"getParticleTexture"},{"location":"models/advanced/ibakedmodel/#getitemcameratransforms","text":"Deprecated in favor of implementing handlePerspective . The default implementation is fine if handlePerspective is implmented. See Perspective .","title":"getItemCameraTransforms"},{"location":"models/advanced/ibakedmodel/#handleperspective","text":"See Perspective .","title":"handlePerspective"},{"location":"models/advanced/ibakedmodel/#getquads","text":"This is the main method of IBakedModel . It returns BakedQuad s, which contain the low-level vertex data that will be used to render the model. If the model is being rendered as a block, then the IBlockState passed in is non-null. Additionally, Block::getExtendedState is called to create the passed IBlockState , which allows for arbitrary data to be passed from the block to the model. If the model is being rendered as an item, the ItemOverrideList returned from getOverrides is responsible for handling the state of the item, and the IBlockState parameter will be null . The EnumFacing passed in is used for face culling. If the block against the given side of the block being rendered is opaque, then the faces associated with that side are not rendered. If that parameter is null , all faces not associated with a side are returned (that will never be culled). Note that this method is called very often: once for every combination of non-culled face and supported block render layer (anywhere between 0 to 28 times) per block in world . This method should be as fast as possible, and should probably cache heavily. The long parameter is a random number.","title":"getQuads"},{"location":"models/advanced/icustommodelloader/","text":"ICustomModelLoader Recall that when a model is requested for a ModelResourceLocation , every ICustomModelLoader is queried to find the one that volunteers to load the model from the ModelResourceLocation . In order to actually use a custom implementation of IModel , whether it be a full blown model format like OBJ models or a completely in-code model generator like ModelDynBucket , it must be done through an ICustomModelLoader . Even though it has \u201cloader\u201d in the name, there is no need for it to actually load anything; for in-code models like ModelDynBucket , the ICustomModelLoader will normally be a dummy that just instantiates the IModel without touching any files. If multiple ICustomModelLoader s attempt to load the same ResourceLocation , the game will crash with a LoaderException . Therefore, care must be taken to keep the namespace of an ICustomModelLoader safe from being infringed upon. The Forge OBJ and B3D loaders do so by requiring that the namespace of a ResourceLocation be registered to them beforehand, and they only match ResourceLocation s with the appropriate file extension. In order for an ICustomModelLoader to actually be used, it must be registered with ModelLoaderRegistry.registerLoader . accepts Tests whether this ICustomModelLoader is willing to load the given ResourceLocation . Preferably, this should be based on the ResourceLocation alone and not on the file contents. If two ICustomModelLoader s accept the same ResourceLocation , a LoaderException is thrown. Therefore, care should be taken to make sure that the namespace of the ICustomModelLoader is unique enough to avoid collisions. loadModel Get the model for the given ResourceLocation . Note that it doesn\u2019t need to \u201cload\u201d anything. For example, completely in-code models will simply instantiate the IModel class and totally ignore the file. onResourceManagerReload Called whenever the resource packs are (re)loaded. In this method, any caches the ICustomModelLoader keeps should be dumped. Following this, loadModel will be called again to reload all the IModel s, so if the IModel s kept some caches in themselves, they do not need to be cleared.","title":"ICustomModelLoader"},{"location":"models/advanced/icustommodelloader/#icustommodelloader","text":"Recall that when a model is requested for a ModelResourceLocation , every ICustomModelLoader is queried to find the one that volunteers to load the model from the ModelResourceLocation . In order to actually use a custom implementation of IModel , whether it be a full blown model format like OBJ models or a completely in-code model generator like ModelDynBucket , it must be done through an ICustomModelLoader . Even though it has \u201cloader\u201d in the name, there is no need for it to actually load anything; for in-code models like ModelDynBucket , the ICustomModelLoader will normally be a dummy that just instantiates the IModel without touching any files. If multiple ICustomModelLoader s attempt to load the same ResourceLocation , the game will crash with a LoaderException . Therefore, care must be taken to keep the namespace of an ICustomModelLoader safe from being infringed upon. The Forge OBJ and B3D loaders do so by requiring that the namespace of a ResourceLocation be registered to them beforehand, and they only match ResourceLocation s with the appropriate file extension. In order for an ICustomModelLoader to actually be used, it must be registered with ModelLoaderRegistry.registerLoader .","title":"ICustomModelLoader"},{"location":"models/advanced/icustommodelloader/#accepts","text":"Tests whether this ICustomModelLoader is willing to load the given ResourceLocation . Preferably, this should be based on the ResourceLocation alone and not on the file contents. If two ICustomModelLoader s accept the same ResourceLocation , a LoaderException is thrown. Therefore, care should be taken to make sure that the namespace of the ICustomModelLoader is unique enough to avoid collisions.","title":"accepts"},{"location":"models/advanced/icustommodelloader/#loadmodel","text":"Get the model for the given ResourceLocation . Note that it doesn\u2019t need to \u201cload\u201d anything. For example, completely in-code models will simply instantiate the IModel class and totally ignore the file.","title":"loadModel"},{"location":"models/advanced/icustommodelloader/#onresourcemanagerreload","text":"Called whenever the resource packs are (re)loaded. In this method, any caches the ICustomModelLoader keeps should be dumped. Following this, loadModel will be called again to reload all the IModel s, so if the IModel s kept some caches in themselves, they do not need to be cleared.","title":"onResourceManagerReload"},{"location":"models/advanced/imodel/","text":"IModel IModel is a type that represents a model in its raw state. This is how a model is represented right after it has been loaded. Usually this directly represents the source of the model (e.g. an object deserialized from JSON, or an OBJ container). At this high level, a model has no concept of items, blocks, or anything of that sort; it purely represents a shape. Important IModel is immutable. Methods such as process that alter the model should never mutate the IModel , as they should construct new IModel s instead. getDependencies This is a collection of the ResourceLocation s of all the models this model depends on. These models are guaranteed to be loaded before this one is baked. For example, a model deserialized from a blockstate JSON will depend on the models defined within. Only models that are directly mapped to a block/item are loaded normally; to ensure loading of other models, they must be declared as dependencies of another. Cyclic dependencies will cause a LoaderException to be thrown. getTextures This is a collection of the ResourceLocation s of all the textures this model depends on. These textures are guaranteed to be loaded before this model is baked. For example, a vanilla JSON model depends on all the textures defined within. bake This is the main method of IModel . It takes an IModelState , a VertexFormat , and a function ResourceLocation \u2192 TextureAtlasSprite , to return an IBakedModel . IBakedModel is less abstract than IModel , and it is what interacts with blocks and items. The function ResourceLocation \u2192 TextureAtlasSprite is used to get textures from ResourceLocation s (i.e. the ResourceLocation s of textures are passed to this function and the returned TextureAtlasSprite contains the texture). process This method allows a model to process extra data from external sources. The Forge blockstate variant format provides a way to define this data in the resource pack. Within the Forge blockstate format, the property that is used to pass this data is called custom . First, an example: { \"forge_marker\": 1, \"defaults\": { \"custom\": { \"__comment\": \"These can be any JSON primitives with any names, but models should only use what they understand.\", \"meaningOfLife\": 42, \"showQuestion\": false }, \"model\": \"examplemod:life_meaning\" }, \"variants\": { \"dying\": { \"true\": { \"__comment\": \"Custom data is inherited. Therefore, here `meaningOfLife` is inherited but `showQuestion` is overriden. The model itself remains inherited.\", \"custom\": { \"showQuestion\": true } }, \"false\": {} } } } As seen above, custom data can be of any type. Additionally, it is inherited from the defaults into the variants. The custom data is passed in as an ImmutableMap<String, String> . This is a map where the keys are the property names (in the above example, \u201cmeaningOfLife\u201d, \u201cshowQuestion\u201d, and \u201ctitle\u201d). Astute observers may notice that numeric and boolean data were defined in within the blockstate but this method only receives String s. This is because all data is converted into strings before being processed. If a model does not understand what a property means, it should just ignore it. smoothLighting In vanilla, smooth lighting enables ambient occlusion. This flag can be controlled by the smooth_lighting property in a Forge blockstate (which can appear wherever a model property can and is inherited). The default implementation does nothing. gui3D gui3D controls whether a model looks \u201cflat\u201d in certain positions (e.g. with gui3d set to true , EntityItem renders a stack with multiple items as several layers of the model. With gui3d set to false , the item is always one layer), and also controls lighting inside GUIs. This flag can be controlled by the gui3d property in a Forge blockstate. The default implementation does nothing. retexture This method is used to change the textures a model might use. This is similar to how texture variables in vanilla JSON models work. A model can start out with certain faces with certain textures, and then by setting/overriding texture variables these faces can be changed. An example: { \"forge_marker\": 1, \"defaults\": { \"textures\": { \"varA\": \"examplemod:items/hgttg\", \"varB\": \"examplemod:blocks/earth\", \"varC\": \"#varA\", \"varZ\": null }, \"model\": \"examplemod:universe\" } } In this example, the textures block will be deserialized as-is into an ImmutableMap with the exception that null s are turned into \"\" (i.e. the final result is \"varA\" \u2192 \"examplemod:items/hgttg\", \"varB\" \u2192 \"examplemod:blocks/earth\", \"varC\" \u2192 \"#varA\", \"varZ\" \u2192 \"\" ). Then, retexture is called to change the textures as needed. How this is done is up to the model. It may be advisable, however, to support resolving texture variables such as \u201c#var\u201d (like vanilla JSON models) instead of taking them literally. The default implementation does nothing. uvlock This method is used to toggle UV lock. UV lock means that when the model itself rotates, the textures applied to the model do not rotate with it. The default implementation does nothing. This can be controlled with the uvlock property in a Forge blockstate. An example: { \"forge_marker\": 1, \"defaults\": { \"model\": \"minecraft:half_slab\", \"textures\": { \"__comment\": \"Texture definitions here...\" } }, \"variants\": { \"a\": [{ \"__comment\": \"No change\" }], \"b\": [{ \"__comment\": \"This is like literally taking the slab and flipping it upside down. The 'side' texture on the side faces is cropped to the bottom half and rotated 180 degrees, just as if a real object were turned upside down.\", \"x\": 180 }], \"c\": [{ \"__comment\": \"Now this is more interesting. The UV vertices are altered so that the texture won't rotate with the model, so that the side faces have the side texture rightside up and cropped to the top half.\", \"x\": 180, \"uvlock\": true }] } }","title":"IModel"},{"location":"models/advanced/imodel/#imodel","text":"IModel is a type that represents a model in its raw state. This is how a model is represented right after it has been loaded. Usually this directly represents the source of the model (e.g. an object deserialized from JSON, or an OBJ container). At this high level, a model has no concept of items, blocks, or anything of that sort; it purely represents a shape. Important IModel is immutable. Methods such as process that alter the model should never mutate the IModel , as they should construct new IModel s instead.","title":"IModel"},{"location":"models/advanced/imodel/#getdependencies","text":"This is a collection of the ResourceLocation s of all the models this model depends on. These models are guaranteed to be loaded before this one is baked. For example, a model deserialized from a blockstate JSON will depend on the models defined within. Only models that are directly mapped to a block/item are loaded normally; to ensure loading of other models, they must be declared as dependencies of another. Cyclic dependencies will cause a LoaderException to be thrown.","title":"getDependencies"},{"location":"models/advanced/imodel/#gettextures","text":"This is a collection of the ResourceLocation s of all the textures this model depends on. These textures are guaranteed to be loaded before this model is baked. For example, a vanilla JSON model depends on all the textures defined within.","title":"getTextures"},{"location":"models/advanced/imodel/#bake","text":"This is the main method of IModel . It takes an IModelState , a VertexFormat , and a function ResourceLocation \u2192 TextureAtlasSprite , to return an IBakedModel . IBakedModel is less abstract than IModel , and it is what interacts with blocks and items. The function ResourceLocation \u2192 TextureAtlasSprite is used to get textures from ResourceLocation s (i.e. the ResourceLocation s of textures are passed to this function and the returned TextureAtlasSprite contains the texture).","title":"bake"},{"location":"models/advanced/imodel/#process","text":"This method allows a model to process extra data from external sources. The Forge blockstate variant format provides a way to define this data in the resource pack. Within the Forge blockstate format, the property that is used to pass this data is called custom . First, an example: { \"forge_marker\": 1, \"defaults\": { \"custom\": { \"__comment\": \"These can be any JSON primitives with any names, but models should only use what they understand.\", \"meaningOfLife\": 42, \"showQuestion\": false }, \"model\": \"examplemod:life_meaning\" }, \"variants\": { \"dying\": { \"true\": { \"__comment\": \"Custom data is inherited. Therefore, here `meaningOfLife` is inherited but `showQuestion` is overriden. The model itself remains inherited.\", \"custom\": { \"showQuestion\": true } }, \"false\": {} } } } As seen above, custom data can be of any type. Additionally, it is inherited from the defaults into the variants. The custom data is passed in as an ImmutableMap<String, String> . This is a map where the keys are the property names (in the above example, \u201cmeaningOfLife\u201d, \u201cshowQuestion\u201d, and \u201ctitle\u201d). Astute observers may notice that numeric and boolean data were defined in within the blockstate but this method only receives String s. This is because all data is converted into strings before being processed. If a model does not understand what a property means, it should just ignore it.","title":"process"},{"location":"models/advanced/imodel/#smoothlighting","text":"In vanilla, smooth lighting enables ambient occlusion. This flag can be controlled by the smooth_lighting property in a Forge blockstate (which can appear wherever a model property can and is inherited). The default implementation does nothing.","title":"smoothLighting"},{"location":"models/advanced/imodel/#gui3d","text":"gui3D controls whether a model looks \u201cflat\u201d in certain positions (e.g. with gui3d set to true , EntityItem renders a stack with multiple items as several layers of the model. With gui3d set to false , the item is always one layer), and also controls lighting inside GUIs. This flag can be controlled by the gui3d property in a Forge blockstate. The default implementation does nothing.","title":"gui3D"},{"location":"models/advanced/imodel/#retexture","text":"This method is used to change the textures a model might use. This is similar to how texture variables in vanilla JSON models work. A model can start out with certain faces with certain textures, and then by setting/overriding texture variables these faces can be changed. An example: { \"forge_marker\": 1, \"defaults\": { \"textures\": { \"varA\": \"examplemod:items/hgttg\", \"varB\": \"examplemod:blocks/earth\", \"varC\": \"#varA\", \"varZ\": null }, \"model\": \"examplemod:universe\" } } In this example, the textures block will be deserialized as-is into an ImmutableMap with the exception that null s are turned into \"\" (i.e. the final result is \"varA\" \u2192 \"examplemod:items/hgttg\", \"varB\" \u2192 \"examplemod:blocks/earth\", \"varC\" \u2192 \"#varA\", \"varZ\" \u2192 \"\" ). Then, retexture is called to change the textures as needed. How this is done is up to the model. It may be advisable, however, to support resolving texture variables such as \u201c#var\u201d (like vanilla JSON models) instead of taking them literally. The default implementation does nothing.","title":"retexture"},{"location":"models/advanced/imodel/#uvlock","text":"This method is used to toggle UV lock. UV lock means that when the model itself rotates, the textures applied to the model do not rotate with it. The default implementation does nothing. This can be controlled with the uvlock property in a Forge blockstate. An example: { \"forge_marker\": 1, \"defaults\": { \"model\": \"minecraft:half_slab\", \"textures\": { \"__comment\": \"Texture definitions here...\" } }, \"variants\": { \"a\": [{ \"__comment\": \"No change\" }], \"b\": [{ \"__comment\": \"This is like literally taking the slab and flipping it upside down. The 'side' texture on the side faces is cropped to the bottom half and rotated 180 degrees, just as if a real object were turned upside down.\", \"x\": 180 }], \"c\": [{ \"__comment\": \"Now this is more interesting. The UV vertices are altered so that the texture won't rotate with the model, so that the side faces have the side texture rightside up and cropped to the top half.\", \"x\": 180, \"uvlock\": true }] } }","title":"uvlock"},{"location":"models/advanced/imodelstate%2Bpart/","text":"IModelState and IModelPart IModelState and IModelPart are a way to transform models (or parts thereof). An IModelPart represents the part of the model being transformed. An IModelState represents a function IModelPart \u2192 TRSRTransform . By applying the IModelState to an IModelPart , we get a TRSRTransform representing how to transform that part. Note that passing Optional.absent() to IModelState::apply has a different meaning than usual. Doing so means getting the transform for the entire model, instead of just a part of it. One of the uses of this is animation. An IModelState can represent a certain frame of the animation and supply transforms to turn the original model into the current frame. By supplying different IModelState s over time, an animation can be performed. For example, the B3D model format supports this kind of animation directly through its nodes; however, the animation system is still WIP. Another, more common use case is Forge blockstate JSONs. The models within the blockstates can be transformed with transform tags, which translate into simple IModelState s that are passed into the contained models. Finally, another use case is perspective aware models . Which IModelPart s a certain model will use is dependent on the model itself. If I had a B3DState that dealt with B3D NodeJoint s and tried to use it on a vanilla JSON model, it wouldn\u2019t work as vanilla models have no idea what a NodeJoint is and will not even ask about them.","title":"IModelState and IModelPart"},{"location":"models/advanced/imodelstate%2Bpart/#imodelstate-and-imodelpart","text":"IModelState and IModelPart are a way to transform models (or parts thereof). An IModelPart represents the part of the model being transformed. An IModelState represents a function IModelPart \u2192 TRSRTransform . By applying the IModelState to an IModelPart , we get a TRSRTransform representing how to transform that part. Note that passing Optional.absent() to IModelState::apply has a different meaning than usual. Doing so means getting the transform for the entire model, instead of just a part of it. One of the uses of this is animation. An IModelState can represent a certain frame of the animation and supply transforms to turn the original model into the current frame. By supplying different IModelState s over time, an animation can be performed. For example, the B3D model format supports this kind of animation directly through its nodes; however, the animation system is still WIP. Another, more common use case is Forge blockstate JSONs. The models within the blockstates can be transformed with transform tags, which translate into simple IModelState s that are passed into the contained models. Finally, another use case is perspective aware models . Which IModelPart s a certain model will use is dependent on the model itself. If I had a B3DState that dealt with B3D NodeJoint s and tried to use it on a vanilla JSON model, it wouldn\u2019t work as vanilla models have no idea what a NodeJoint is and will not even ask about them.","title":"IModelState and IModelPart"},{"location":"models/advanced/introduction/","text":"Intro to Advanced Models While simple models and blockstates are all well and good, they aren\u2019t dynamic. For example, Forge\u2019s Universal Bucket can hold all kinds of fluid, which may be mod added. It has to dynamically piece the model together from the base bucket model and the liquid. How is that done? Enter IModel . In order to understand how this works, let\u2019s go through the internals of the model system. Throughout this section, you will probably have to refer to this to grasp a clear understanding of what is happening. This is true in reverse as well. You will likely not understand everything happening here, but as you move through this section you should be able to grasp more and more of it until everything is clear. Important If this is your first time reading through do not skip anything ! It is imperative that you read everything in order so as to build a comprehensive understanding! In the same vein, if this is your first time reading, do not follow links if they lead to pages further ahead in the section. A set of ModelResourceLocation s are marked as models to be loaded through ModelLoader . For items, their models must be manually marked for loading with ModelLoader.registerItemVariants . ( ModelLoader.setCustomModelResourceLocation does this.) For blocks, their statemappers produce a Map<IBlockState, ModelResourceLocation> . All blocks are iterated, and then the values of this map are marked to be loaded. IModel s are loaded from each ModelResourceLocation and cached in a Map<ModelResourceLocation, IModel> . An IModel is loaded from the only ICustomModelLoader that accepts it. (Multiple loaders attempting to load a model will cause a LoaderException .) If none is found and the ResourceLocation is actually a ModelResourceLocation (that is, this is not a normal model; it\u2019s actually a blockstate variant), it goes to the blockstate loader ( VariantLoader ). Otherwise the model is a normal vanilla JSON model and is loaded the vanilla way ( VanillaLoader ). A vanilla JSON model ( models/item/*.json or models/block/*.json ), when loaded, is a ModelBlock (yes, even for items). This is a vanilla class that is not related to IModel in any way. To rectify this, it gets wrapped into a VanillaModelWrapper , which does implement IModel . A vanilla/Forge blockstate variant, when loaded, first loads the entire blockstate JSON it comes from. The JSON is deserialized into a ModelBlockDefinition that is then cached to the path of the JSON. A list of variant definitions is then extracted from the ModelBlockDefinition and placed into a WeightedRandomModel . When loading a vanilla JSON item model ( models/item/*.json ), the model is requested from a ModelResourceLocation with variant inventory (e.g. the dirt block item model is minecraft:dirt#inventory ); thereby causing the model to be loaded by VariantLoader (as it is a ModelResourceLocation ). When VariantLoader fails to load the model from the blockstate JSON, it falls back to VanillaLoader . The most important side-effect of this is that if an error occurs in VariantLoader , it will try to also load the model via VanillaLoader . If this also fails, then the resulting exception produces two stacktraces. The first is the VanillaLoader stacktrace, and the second is from VariantLoader . When debugging model errors, it is important to ensure that the right stacktrace is being analyzed. An IModel can be loaded from a ResourceLocation or retrieved from the cache by invoking ModelLoaderRegistry.getModel or one of the exception handling alternatives. All texture dependencies of the loaded models are loaded and stitched into the atlas. The atlas is a giant texture that contains all the model textures pasted together. When a model refers to a texture, during rendering, an extra UV offset is applied to match the texture\u2019s position in the atlas. Every model is baked by calling model.bake(model.getDefaultState(), ...) . The resulting IBakedModel s are cached in a Map<ModelResourceLocation, IBakedModel> . This map is then stored in the ModelManager . The ModelManager for an instance of the game is stored in Minecraft::modelManager , which is private with no getter. The ModelManager may be acquired, without reflection or access tranformation, through Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager() or Minecraft.getMinecraft().getBlockRenderDispatcher().getBlockModelShapes().getModelManager() . Contrary to their names, these are equivalent. One may request an IBakedModel from the cache (without loading and/or baking models, only accessing the existing cache) in a ModelManager with ModelManager::getModel . Eventually, an IBakedModel will be rendered. This is done by calling IBakedModel::getQuads . The result is a list of BakedQuad s (quadrilaterals: polygons with 4 vertices). These can then be passed to the GPU for rendering. Items and blocks diverge a bit here, but it\u2019s relatively simple to follow. Items in vanilla have properties and overrides. To facilitate this, IBakedModel defines getOverrides , which returns an ItemOverrideList . ItemOverrideList defines handleItemState , which takes the original model, the entity, world, and stack, to find the final model. Overrides are applied before all other operations on the model, including getQuads . As IBlockState is not applicable to items, IBakedModel::getQuads receives null as its state parameter when being rendered as an item. Blocks have blockstates, and when a block\u2019s IBakedModel is being rendered, the IBlockState is passed directly into the getQuads method. In the context of models only, blockstates can have an extra set of properties, known as unlisted properties .","title":"Intro to Advanced Models"},{"location":"models/advanced/introduction/#intro-to-advanced-models","text":"While simple models and blockstates are all well and good, they aren\u2019t dynamic. For example, Forge\u2019s Universal Bucket can hold all kinds of fluid, which may be mod added. It has to dynamically piece the model together from the base bucket model and the liquid. How is that done? Enter IModel . In order to understand how this works, let\u2019s go through the internals of the model system. Throughout this section, you will probably have to refer to this to grasp a clear understanding of what is happening. This is true in reverse as well. You will likely not understand everything happening here, but as you move through this section you should be able to grasp more and more of it until everything is clear. Important If this is your first time reading through do not skip anything ! It is imperative that you read everything in order so as to build a comprehensive understanding! In the same vein, if this is your first time reading, do not follow links if they lead to pages further ahead in the section. A set of ModelResourceLocation s are marked as models to be loaded through ModelLoader . For items, their models must be manually marked for loading with ModelLoader.registerItemVariants . ( ModelLoader.setCustomModelResourceLocation does this.) For blocks, their statemappers produce a Map<IBlockState, ModelResourceLocation> . All blocks are iterated, and then the values of this map are marked to be loaded. IModel s are loaded from each ModelResourceLocation and cached in a Map<ModelResourceLocation, IModel> . An IModel is loaded from the only ICustomModelLoader that accepts it. (Multiple loaders attempting to load a model will cause a LoaderException .) If none is found and the ResourceLocation is actually a ModelResourceLocation (that is, this is not a normal model; it\u2019s actually a blockstate variant), it goes to the blockstate loader ( VariantLoader ). Otherwise the model is a normal vanilla JSON model and is loaded the vanilla way ( VanillaLoader ). A vanilla JSON model ( models/item/*.json or models/block/*.json ), when loaded, is a ModelBlock (yes, even for items). This is a vanilla class that is not related to IModel in any way. To rectify this, it gets wrapped into a VanillaModelWrapper , which does implement IModel . A vanilla/Forge blockstate variant, when loaded, first loads the entire blockstate JSON it comes from. The JSON is deserialized into a ModelBlockDefinition that is then cached to the path of the JSON. A list of variant definitions is then extracted from the ModelBlockDefinition and placed into a WeightedRandomModel . When loading a vanilla JSON item model ( models/item/*.json ), the model is requested from a ModelResourceLocation with variant inventory (e.g. the dirt block item model is minecraft:dirt#inventory ); thereby causing the model to be loaded by VariantLoader (as it is a ModelResourceLocation ). When VariantLoader fails to load the model from the blockstate JSON, it falls back to VanillaLoader . The most important side-effect of this is that if an error occurs in VariantLoader , it will try to also load the model via VanillaLoader . If this also fails, then the resulting exception produces two stacktraces. The first is the VanillaLoader stacktrace, and the second is from VariantLoader . When debugging model errors, it is important to ensure that the right stacktrace is being analyzed. An IModel can be loaded from a ResourceLocation or retrieved from the cache by invoking ModelLoaderRegistry.getModel or one of the exception handling alternatives. All texture dependencies of the loaded models are loaded and stitched into the atlas. The atlas is a giant texture that contains all the model textures pasted together. When a model refers to a texture, during rendering, an extra UV offset is applied to match the texture\u2019s position in the atlas. Every model is baked by calling model.bake(model.getDefaultState(), ...) . The resulting IBakedModel s are cached in a Map<ModelResourceLocation, IBakedModel> . This map is then stored in the ModelManager . The ModelManager for an instance of the game is stored in Minecraft::modelManager , which is private with no getter. The ModelManager may be acquired, without reflection or access tranformation, through Minecraft.getMinecraft().getRenderItem().getItemModelMesher().getModelManager() or Minecraft.getMinecraft().getBlockRenderDispatcher().getBlockModelShapes().getModelManager() . Contrary to their names, these are equivalent. One may request an IBakedModel from the cache (without loading and/or baking models, only accessing the existing cache) in a ModelManager with ModelManager::getModel . Eventually, an IBakedModel will be rendered. This is done by calling IBakedModel::getQuads . The result is a list of BakedQuad s (quadrilaterals: polygons with 4 vertices). These can then be passed to the GPU for rendering. Items and blocks diverge a bit here, but it\u2019s relatively simple to follow. Items in vanilla have properties and overrides. To facilitate this, IBakedModel defines getOverrides , which returns an ItemOverrideList . ItemOverrideList defines handleItemState , which takes the original model, the entity, world, and stack, to find the final model. Overrides are applied before all other operations on the model, including getQuads . As IBlockState is not applicable to items, IBakedModel::getQuads receives null as its state parameter when being rendered as an item. Blocks have blockstates, and when a block\u2019s IBakedModel is being rendered, the IBlockState is passed directly into the getQuads method. In the context of models only, blockstates can have an extra set of properties, known as unlisted properties .","title":"Intro to Advanced Models"},{"location":"models/advanced/itemoverridelist/","text":"ItemOverrideList ItemOverrideList provides a way for an IBakedModel to process the state of an ItemStack and return a new IBakedModel ; thereafter, the returned model replaces the old one. ItemOverrideList represents an arbitrary function (IBakedModel, ItemStack, World, EntityLivingBase) \u2192 IBakedModel , making it useful for dynamic models. In vanilla, it is used to implement item property overrides. ItemOverrideList() Given a list of ItemOverride s, the constructor copies that list and stores the copy. The list may be accessed with getOverrides , and it is used to implement the vanilla applyOverride , which, in turn, is used in the vanilla handleItemState . applyOverride This is a deprecated vanilla method. It is only called in the vanilla handleItemState , and in almost all cases can be safely ignored. handleItemState This takes an IBakedModel , an ItemStack , a World , and an EntityLivingBase to produce another IBakedModel to use for rendering. This is where models can handle the state of their items. This should not mutate the world. getOverrides Returns an immutable list containing all the ItemOverride s used by this ItemOverrideList . If none are applicable, this returns the empty list. ItemOverride This class represents a vanilla item override, which holds several predicates for the properties on an item and a model to use in case those predicates are satisfied. They are the objects in the overrides array of a vanilla item JSON model: { \"__comment\": \"Inside a vanilla JSON item model.\", \"overrides\": [ { \"__comment\": \"This is an ItemOverride.\", \"predicate\": { \"__comment\": \"This is the Map<ResourceLocation, Float>, containing the names of properties and their minimum values.\", \"example1:prop\": 4 }, \"__comment\": \"This is the 'location', or target model, of the override, which is used if the predicate above matches.\", \"model\": \"example1:item/model\" }, { \"__comment\": \"This is another ItemOverride.\", \"predicate\": { \"prop\": 1 }, \"model\": \"example2:item/model\" } ] }","title":"ItemOverrideList"},{"location":"models/advanced/itemoverridelist/#itemoverridelist","text":"ItemOverrideList provides a way for an IBakedModel to process the state of an ItemStack and return a new IBakedModel ; thereafter, the returned model replaces the old one. ItemOverrideList represents an arbitrary function (IBakedModel, ItemStack, World, EntityLivingBase) \u2192 IBakedModel , making it useful for dynamic models. In vanilla, it is used to implement item property overrides.","title":"ItemOverrideList"},{"location":"models/advanced/itemoverridelist/#itemoverridelist_1","text":"Given a list of ItemOverride s, the constructor copies that list and stores the copy. The list may be accessed with getOverrides , and it is used to implement the vanilla applyOverride , which, in turn, is used in the vanilla handleItemState .","title":"ItemOverrideList()"},{"location":"models/advanced/itemoverridelist/#applyoverride","text":"This is a deprecated vanilla method. It is only called in the vanilla handleItemState , and in almost all cases can be safely ignored.","title":"applyOverride"},{"location":"models/advanced/itemoverridelist/#handleitemstate","text":"This takes an IBakedModel , an ItemStack , a World , and an EntityLivingBase to produce another IBakedModel to use for rendering. This is where models can handle the state of their items. This should not mutate the world.","title":"handleItemState"},{"location":"models/advanced/itemoverridelist/#getoverrides","text":"Returns an immutable list containing all the ItemOverride s used by this ItemOverrideList . If none are applicable, this returns the empty list.","title":"getOverrides"},{"location":"models/advanced/itemoverridelist/#itemoverride","text":"This class represents a vanilla item override, which holds several predicates for the properties on an item and a model to use in case those predicates are satisfied. They are the objects in the overrides array of a vanilla item JSON model: { \"__comment\": \"Inside a vanilla JSON item model.\", \"overrides\": [ { \"__comment\": \"This is an ItemOverride.\", \"predicate\": { \"__comment\": \"This is the Map<ResourceLocation, Float>, containing the names of properties and their minimum values.\", \"example1:prop\": 4 }, \"__comment\": \"This is the 'location', or target model, of the override, which is used if the predicate above matches.\", \"model\": \"example1:item/model\" }, { \"__comment\": \"This is another ItemOverride.\", \"predicate\": { \"prop\": 1 }, \"model\": \"example2:item/model\" } ] }","title":"ItemOverride"},{"location":"models/advanced/perspective/","text":"Perspective When an IBakedModel is being rendered as an item, it can apply special handling depending on which perspective it is being rendered in. \u201cPerspective\u201d means in what context the model is being rendered. The possible perspectives are represented in code by the ItemCameraTransforms.TransformType enum. There are two systems for handling perspective: the deprecated vanilla system, constituted by IBakedModel::getItemCameraTransforms , ItemCameraTranforms , and ItemTransformVec3f , and the Forge system, embodied by the method IBakedModel::handlePerspective . The vanilla code is patched to favor using handlePerspective over the vanilla system whenever possible. TransformType NONE - Unused. THIRD_PERSON_LEFT_HAND / THIRD_PERSON_RIGHT_HAND / FIRST_PERSON_LEFT_HAND / FIRST_PERSON_RIGHT_HAND - The first person values represent when the player is holding the item in their own hand. The third person values represent when another player is holding the item and the client is looking at them in the 3rd person. Hands are self-explanatory. HEAD - Represents when any player is wearing the item in the helmet slot (e.g. pumpkins). GUI - Represents when the item is being rendered in a GUI. GROUND - Represents when the item is being rendered in the world as an EntityItem . FIXED - Used for item frames. This enum is also patched to implement IModelPart . This allows IModelState s to alter the perspective handling of models. However, the model itself must implement this behavior. (See below .) The Vanilla Way The vanilla way of handling perspective is through IBakedModel::getItemCameraTransforms . This method returns an ItemCameraTransforms , which is a simple object that contains various ItemTransformVec3f s as public final fields. An ItemTransformVec3f represents a rotation, a translation, and a scale to be applied to the model. The ItemCameraTransforms is a container for these, holding one for each of the TransformType s, sans NONE . In the vanilla implementation, calling getTransform for NONE results in the default transform, ItemTransformVec3f.DEFAULT . The entire vanilla system for handling transforms is deprecated by Forge, and most implementations of IBakedModel should simply return ItemCameraTransforms.DEFAULT (which is the default implementation) from IBakedModel::getItemCameraTransforms . Instead, they should implement handlePerspective . The Forge Way The Forge way of handling transforms is handlePerspective , a method patched into IBakedModel . It supersedes the getItemCameraTransforms method. Additionally, the class PerspectiveMapWrapper is a simple implementation of an IBakedModel with the method; it is a wrapper around other IBakedModel s, augmenting them with a Map<TransformType, TRSRTransformation> to handle perspective. IBakedModel::handlePerspective Given a TransformType , this method produces an IBakedModel and Matrix4f . The model is what will be rendered, and the (nullable) matrix is the transform to use. Because the returned IBakedModel can be a totally new model, this method is more flexible than the vanilla method (e.g. a piece of paper that looks flat in hand but crumpled on the ground). PerspectiveMapWrapper A wrapper around other IBakedModel s, this class delegates to the wrapped model for all IBakedModel methods except handlePerspective , and utilizes a simple Map<TransformType, TRSRTransformation> for handlePerspective . However, the more interesting parts of this class are the static helper methods. getTransforms Given an ItemCameraTransforms or an IModelState , this method will extract an ImmutableMap<TransformType, TRSRTransformation> from it. To extract this information from an IModelState , each TransformType is passed to apply . This is how models should support custom perspective transforms through IModelState . IModel s should use getTransforms in bake and store the passed in perspective transforms in the IBakedModel . Then the IBakedModel can use these custom transforms in handlePerspective , composing them on top of its own. handlePerspective Given either a map of transforms or an IModelState , an IBakedModel , and a TransformType , this finds the Matrix4f for the transform from the map or the IModelState , and then pairs it with the given model. To extract the transform from an IModelState , the TransformType is passed to apply . This method is meant to be a simple implementation of IBakedModel::handlePerspective .","title":"Perspective"},{"location":"models/advanced/perspective/#perspective","text":"When an IBakedModel is being rendered as an item, it can apply special handling depending on which perspective it is being rendered in. \u201cPerspective\u201d means in what context the model is being rendered. The possible perspectives are represented in code by the ItemCameraTransforms.TransformType enum. There are two systems for handling perspective: the deprecated vanilla system, constituted by IBakedModel::getItemCameraTransforms , ItemCameraTranforms , and ItemTransformVec3f , and the Forge system, embodied by the method IBakedModel::handlePerspective . The vanilla code is patched to favor using handlePerspective over the vanilla system whenever possible.","title":"Perspective"},{"location":"models/advanced/perspective/#transformtype","text":"NONE - Unused. THIRD_PERSON_LEFT_HAND / THIRD_PERSON_RIGHT_HAND / FIRST_PERSON_LEFT_HAND / FIRST_PERSON_RIGHT_HAND - The first person values represent when the player is holding the item in their own hand. The third person values represent when another player is holding the item and the client is looking at them in the 3rd person. Hands are self-explanatory. HEAD - Represents when any player is wearing the item in the helmet slot (e.g. pumpkins). GUI - Represents when the item is being rendered in a GUI. GROUND - Represents when the item is being rendered in the world as an EntityItem . FIXED - Used for item frames. This enum is also patched to implement IModelPart . This allows IModelState s to alter the perspective handling of models. However, the model itself must implement this behavior. (See below .)","title":"TransformType"},{"location":"models/advanced/perspective/#the-vanilla-way","text":"The vanilla way of handling perspective is through IBakedModel::getItemCameraTransforms . This method returns an ItemCameraTransforms , which is a simple object that contains various ItemTransformVec3f s as public final fields. An ItemTransformVec3f represents a rotation, a translation, and a scale to be applied to the model. The ItemCameraTransforms is a container for these, holding one for each of the TransformType s, sans NONE . In the vanilla implementation, calling getTransform for NONE results in the default transform, ItemTransformVec3f.DEFAULT . The entire vanilla system for handling transforms is deprecated by Forge, and most implementations of IBakedModel should simply return ItemCameraTransforms.DEFAULT (which is the default implementation) from IBakedModel::getItemCameraTransforms . Instead, they should implement handlePerspective .","title":"The Vanilla Way"},{"location":"models/advanced/perspective/#the-forge-way","text":"The Forge way of handling transforms is handlePerspective , a method patched into IBakedModel . It supersedes the getItemCameraTransforms method. Additionally, the class PerspectiveMapWrapper is a simple implementation of an IBakedModel with the method; it is a wrapper around other IBakedModel s, augmenting them with a Map<TransformType, TRSRTransformation> to handle perspective.","title":"The Forge Way"},{"location":"models/advanced/perspective/#ibakedmodelhandleperspective","text":"Given a TransformType , this method produces an IBakedModel and Matrix4f . The model is what will be rendered, and the (nullable) matrix is the transform to use. Because the returned IBakedModel can be a totally new model, this method is more flexible than the vanilla method (e.g. a piece of paper that looks flat in hand but crumpled on the ground).","title":"IBakedModel::handlePerspective"},{"location":"models/advanced/perspective/#perspectivemapwrapper","text":"A wrapper around other IBakedModel s, this class delegates to the wrapped model for all IBakedModel methods except handlePerspective , and utilizes a simple Map<TransformType, TRSRTransformation> for handlePerspective . However, the more interesting parts of this class are the static helper methods.","title":"PerspectiveMapWrapper"},{"location":"models/advanced/perspective/#gettransforms","text":"Given an ItemCameraTransforms or an IModelState , this method will extract an ImmutableMap<TransformType, TRSRTransformation> from it. To extract this information from an IModelState , each TransformType is passed to apply . This is how models should support custom perspective transforms through IModelState . IModel s should use getTransforms in bake and store the passed in perspective transforms in the IBakedModel . Then the IBakedModel can use these custom transforms in handlePerspective , composing them on top of its own.","title":"getTransforms"},{"location":"models/advanced/perspective/#handleperspective","text":"Given either a map of transforms or an IModelState , an IBakedModel , and a TransformType , this finds the Matrix4f for the transform from the map or the IModelState , and then pairs it with the given model. To extract the transform from an IModelState , the TransformType is passed to apply . This method is meant to be a simple implementation of IBakedModel::handlePerspective .","title":"handlePerspective"},{"location":"models/blockstates/forgeBlockstates/","text":"Forge\u2019s Blockstates Forge has its own blockstate json format to accommodate for modders needs. It introduces submodels, which allows you to build the final blockstate from different parts. Attention Note that all models and textures referenced are from vanilla minecraft. For your own mod, you have to use the full location! For example: \"mymod:blocks/blockTexture\" . You don\u2019t have to use Forge\u2019s blockstate format at all, you can also use the vanilla format! General Structure of the Format { \"forge_marker\": 1, \"defaults\": { \"textures\": { \"all\": \"blocks/dirt\" }, \"model\": \"cube_all\", \"uvlock\": true }, \"variants\": { \"normal\": [{}] } } This json declares a simple blockstate that has dirt on each side. Let\u2019s go through it step by step. \"forge_marker\": 1, This tells the game that the blockstate json is the one from Forge, not from vanilla Minecraft. The 1 is the version of the format, which ensures that old blockstate JSONs can be supported should the format ever change. Currently there is only this one. \"defaults\": { \"textures\": { \"all\": \"blocks/dirt\" }, \"model\": \"cube_all\", \"uvlock\": true } The defaults section contains the default values for all variants. They can be overwritten by the variants. The defaults section is optional ! You do not need to define defaults, the block can be omitted altogether. \"variants\": { \"normal\": [{}] } This defines all variants for the block. The simple dirt block only has its default, the normal variant. It does not contain any additional information in this case. Everything that is defined in defaults could also be defined here. For example: \"normal\": [{ \"textures\": { \"side\": \"blocks/cobblestone\", \"end\": \"blocks/dirt\" }, \"model\": \"cube_column\" }] This normal variant would use the cube_column model with cobblestone on the sides and dirt on top and bottom. An entry in the variants section either defines a blockstate property or a plain variant. A property definition is of the form: \"variants\": { \"property_name\": { \"value0\": {}, \"value1\": {}, \"__comment\": \"Etc.\" } } A given blockstate can have any number of these. When the blockstate is loaded, the values within each property are used to create all possible variants for the block. The above would create two variants, property_name=value0 and property_name=value1 . If there were two properties, it would create variants prop1=value11,prop2=value21 , prop1=value12,prop2=value21 , prop1=value11,prop2=value22 , and so on (where the property names are sorted alphabetically). Each such variant is the union of all the variant definitions that went into it. For example, given: { \"forge_marker\": 1, \"variants\": { \"shiny\": { \"true\": { \"textures\": { \"all\": \"some:shiny_texture\" } }, \"false\": { \"textures\": { \"all\": \"some:flat_texture\" } } }, \"broken\": { \"true\": { \"model\": \"some:broken_model\" }, \"false\": { \"model\": \"some:intact_model\" } } } } The variant \u201cbroken=false,shiny=true\u201d takes the \u201csome:intact_model\u201d from variants.broken.true.model , and the some:shiny_texture from variants.shiny.true.textures . An entry can also be a plain variant, like: \"variants\": { \"normal\": { \"model\": \"some:model\" } } This kind of definition defines a variant \u201cnormal\u201d directly, without forming combinations with those listed in the property-value format. It still inherits from a \u201cdefaults\u201d block, if present, and if the property-value formatted variants generate a variant with the same name, the directly defined variant combines with and overrides values from it. If the variant is defined as a list, then each element is a variant definition, and the one that will be used is random: \"defaults\": { \"model\": \"some:model\" } \"variants\": { \"__comment\": \"When used, the model will have a 75% chance of being rotated.\", \"normal\": [{ \"y\": 0 }, { \"y\": 90 }, { \"y\": 180 }, { \"y\": 270 }] } A property definition is disambiguated from a straight variant by the type of the first entry. If the first entry of variants.<something> is an object, then it is a property definition. If it is anything else, it is a straight variant. In order to avoid mixups, it is recommended to wrap straight variants in a list with one element: \"variants\": { \"simple\": [{ \"custom\": {}, \"model\": \"some:model\", \"__comment\": \"Without the list, the custom: {} would make Forge think this was a property definition.\" }] } Sub-Models To show the use of submodels we will create a model that has different variants. Each variant will use submodels to create a different model. The model will be a pressure plate, and depending on its state it will have parts added to it. { \"forge_marker\": 1, \"defaults\": { \"textures\": { \"texture\": \"blocks/planks_oak\", \"wall\": \"blocks/planks_oak\" }, \"model\": \"pressure_plate_up\", \"uvlock\": true }, \"variants\": { \"__comment\": \"mossy is a boolean property.\", \"mossy\": { \"true\": { \"__comment\": \"If true it changes the pressure plate from oak planks to mossy cobble.\", \"textures\": { \"texture\": \"blocks/cobblestone_mossy\" } }, \"false\": { \"__comment\": \"Change nothing. The entry has to be here so the Forge blockstate loader knows to generate this variant.\" } }, \"__comment\": \"pillarcount is a property that determines how many pillar submodels we have. Ranges from 0 to 2.\", \"pillarcount\": { \"0\": { \"__comment\": \"No pillar. Remember, this empty definition has to be here.\" }, \"1\": { \"__comment\": \"If it is true, it will add the wall model and combine it with the pressure plate.\", \"submodel\": \"wall_n\" }, \"2\": { \"textures\": { \"wall\": \"blocks/cobblestone\" }, \"submodel\": { \"pillar1\": { \"model\": \"wall_n\" }, \"pillar2\": { \"model\": \"wall_n\", \"y\": 90 } } } } } } The comments already explain the details on the separate parts, but here\u2019s how it works overall: The block definition in code has two properties. One boolean property named mossy and one integer property named pillarCount . Note Notice here that the string used in the json is lowercase . It has to be lowercase or it won\u2019t be found. Instead of defining \u201cthis combination of properties gives model X\u201d we say \u201c this value for this property has that impact on the model\u201d. In this example it\u2019s quite straight forward: If mossy is true , the pressure plate uses the mossy cobblestone texture If pillarCount is 1 it will add one wall with connection facing north. The default texture for the wall is oak-planks. If pillarCount is 2 it will add two walls, both facing north. However the second wall will be rotated by 90 degree. This showcases that you do not need separate model with Forge\u2019s system. You only need once and rotate it around the Y axis. Additionally the texture of the walls is changed to cobblestone. If pillarCount is 0 no walls will be added. And here is the result of our work:","title":"Forge Blockstate JSON"},{"location":"models/blockstates/forgeBlockstates/#forges-blockstates","text":"Forge has its own blockstate json format to accommodate for modders needs. It introduces submodels, which allows you to build the final blockstate from different parts. Attention Note that all models and textures referenced are from vanilla minecraft. For your own mod, you have to use the full location! For example: \"mymod:blocks/blockTexture\" . You don\u2019t have to use Forge\u2019s blockstate format at all, you can also use the vanilla format!","title":"Forge's Blockstates"},{"location":"models/blockstates/forgeBlockstates/#general-structure-of-the-format","text":"{ \"forge_marker\": 1, \"defaults\": { \"textures\": { \"all\": \"blocks/dirt\" }, \"model\": \"cube_all\", \"uvlock\": true }, \"variants\": { \"normal\": [{}] } } This json declares a simple blockstate that has dirt on each side. Let\u2019s go through it step by step. \"forge_marker\": 1, This tells the game that the blockstate json is the one from Forge, not from vanilla Minecraft. The 1 is the version of the format, which ensures that old blockstate JSONs can be supported should the format ever change. Currently there is only this one. \"defaults\": { \"textures\": { \"all\": \"blocks/dirt\" }, \"model\": \"cube_all\", \"uvlock\": true } The defaults section contains the default values for all variants. They can be overwritten by the variants. The defaults section is optional ! You do not need to define defaults, the block can be omitted altogether. \"variants\": { \"normal\": [{}] } This defines all variants for the block. The simple dirt block only has its default, the normal variant. It does not contain any additional information in this case. Everything that is defined in defaults could also be defined here. For example: \"normal\": [{ \"textures\": { \"side\": \"blocks/cobblestone\", \"end\": \"blocks/dirt\" }, \"model\": \"cube_column\" }] This normal variant would use the cube_column model with cobblestone on the sides and dirt on top and bottom. An entry in the variants section either defines a blockstate property or a plain variant. A property definition is of the form: \"variants\": { \"property_name\": { \"value0\": {}, \"value1\": {}, \"__comment\": \"Etc.\" } } A given blockstate can have any number of these. When the blockstate is loaded, the values within each property are used to create all possible variants for the block. The above would create two variants, property_name=value0 and property_name=value1 . If there were two properties, it would create variants prop1=value11,prop2=value21 , prop1=value12,prop2=value21 , prop1=value11,prop2=value22 , and so on (where the property names are sorted alphabetically). Each such variant is the union of all the variant definitions that went into it. For example, given: { \"forge_marker\": 1, \"variants\": { \"shiny\": { \"true\": { \"textures\": { \"all\": \"some:shiny_texture\" } }, \"false\": { \"textures\": { \"all\": \"some:flat_texture\" } } }, \"broken\": { \"true\": { \"model\": \"some:broken_model\" }, \"false\": { \"model\": \"some:intact_model\" } } } } The variant \u201cbroken=false,shiny=true\u201d takes the \u201csome:intact_model\u201d from variants.broken.true.model , and the some:shiny_texture from variants.shiny.true.textures . An entry can also be a plain variant, like: \"variants\": { \"normal\": { \"model\": \"some:model\" } } This kind of definition defines a variant \u201cnormal\u201d directly, without forming combinations with those listed in the property-value format. It still inherits from a \u201cdefaults\u201d block, if present, and if the property-value formatted variants generate a variant with the same name, the directly defined variant combines with and overrides values from it. If the variant is defined as a list, then each element is a variant definition, and the one that will be used is random: \"defaults\": { \"model\": \"some:model\" } \"variants\": { \"__comment\": \"When used, the model will have a 75% chance of being rotated.\", \"normal\": [{ \"y\": 0 }, { \"y\": 90 }, { \"y\": 180 }, { \"y\": 270 }] } A property definition is disambiguated from a straight variant by the type of the first entry. If the first entry of variants.<something> is an object, then it is a property definition. If it is anything else, it is a straight variant. In order to avoid mixups, it is recommended to wrap straight variants in a list with one element: \"variants\": { \"simple\": [{ \"custom\": {}, \"model\": \"some:model\", \"__comment\": \"Without the list, the custom: {} would make Forge think this was a property definition.\" }] }","title":"General Structure of the Format"},{"location":"models/blockstates/forgeBlockstates/#sub-models","text":"To show the use of submodels we will create a model that has different variants. Each variant will use submodels to create a different model. The model will be a pressure plate, and depending on its state it will have parts added to it. { \"forge_marker\": 1, \"defaults\": { \"textures\": { \"texture\": \"blocks/planks_oak\", \"wall\": \"blocks/planks_oak\" }, \"model\": \"pressure_plate_up\", \"uvlock\": true }, \"variants\": { \"__comment\": \"mossy is a boolean property.\", \"mossy\": { \"true\": { \"__comment\": \"If true it changes the pressure plate from oak planks to mossy cobble.\", \"textures\": { \"texture\": \"blocks/cobblestone_mossy\" } }, \"false\": { \"__comment\": \"Change nothing. The entry has to be here so the Forge blockstate loader knows to generate this variant.\" } }, \"__comment\": \"pillarcount is a property that determines how many pillar submodels we have. Ranges from 0 to 2.\", \"pillarcount\": { \"0\": { \"__comment\": \"No pillar. Remember, this empty definition has to be here.\" }, \"1\": { \"__comment\": \"If it is true, it will add the wall model and combine it with the pressure plate.\", \"submodel\": \"wall_n\" }, \"2\": { \"textures\": { \"wall\": \"blocks/cobblestone\" }, \"submodel\": { \"pillar1\": { \"model\": \"wall_n\" }, \"pillar2\": { \"model\": \"wall_n\", \"y\": 90 } } } } } } The comments already explain the details on the separate parts, but here\u2019s how it works overall: The block definition in code has two properties. One boolean property named mossy and one integer property named pillarCount . Note Notice here that the string used in the json is lowercase . It has to be lowercase or it won\u2019t be found. Instead of defining \u201cthis combination of properties gives model X\u201d we say \u201c this value for this property has that impact on the model\u201d. In this example it\u2019s quite straight forward: If mossy is true , the pressure plate uses the mossy cobblestone texture If pillarCount is 1 it will add one wall with connection facing north. The default texture for the wall is oak-planks. If pillarCount is 2 it will add two walls, both facing north. However the second wall will be rotated by 90 degree. This showcases that you do not need separate model with Forge\u2019s system. You only need once and rotate it around the Y axis. Additionally the texture of the walls is changed to cobblestone. If pillarCount is 0 no walls will be added. And here is the result of our work:","title":"Sub-Models"},{"location":"models/blockstates/introduction/","text":"Introduction to Blockstate JSONs Blockstate JSONs are Minecraft\u2019s way to map \u201cvariant strings\u201d to models. A variant string can be absolutely anything, from \u201cinventory\u201d to \u201cpower=5\u201d to \u201cI am your father.\u201d They represent an actual model, where the blockstate is just a container for them. In code, a variant string within a blockstate JSON is represented by a ModelResourceLocation . When the game searches for a model corresponding to a block in the world, it takes the blockstate for that position, and then it uses an IStateMapper to find the corresponding ModelResourceLocation for it, which then refers to the actual model. The default IStateMapper uses the block\u2019s registry name as the location of the blockstate JSON. (E.g. block examplemod:testblock goes to the ResourceLocation examplemod:testblock .) The variant string is pieced together from the blockstate\u2019s properties. More information can be found here . As an example, let\u2019s take a look at the vanilla oak_log.json : { \"variants\": { \"axis=y\": { \"model\": \"oak_log\" }, \"axis=z\": { \"model\": \"oak_log_side\" }, \"axis=x\": { \"model\": \"oak_log_side\", \"y\": 90 }, \"axis=none\": { \"model\": \"oak_bark\" } } } Here we define 4 variant strings, and for each we use a certain model, either the upright log, the sideways log (rotated or not), and the all bark model (this model is not seen normally in vanilla; you have to use /setblock to create it). Since logs use the default IStateMapper , these variants will define the look of a log depending on the property axis . A blockstate always has to be defined for all possible variant strings. When you have many properties, this results in lots of possible variants, as every combination of properties must be defined. In Minecraft 1.8\u2019s blockstate format, you have to define every string explicitly, which leads to long, complicated files. It also doesn\u2019t support the concept of submodels, or multiple models in the same blockstate. In order to allievate this, Forge introduced its own blockstate format , which is available in Minecraft 1.8 and up. Starting from Minecraft 1.9, Mojang also introduced the \u201cmultipart\u201d format. You can find a definition of its format on the wiki . Forge\u2019s format and the multipart format are not better than each other; they each cover different use cases and it is your choice which one you want to use. Note The Forge format is really more like syntactic sugar for automatically calculating the set of all possible variants for you behind the scenes. This allows you to use the resulting ModelResourceLocation s for things other than blocks. ( Such as items . This is also true of the 1.8 format, but there is almost no reason to use that format.) The 1.9 format is a more complicated system that depends on having an IBlockState to pick the model. It will not directly work in other contexts without some code around it. For reference, here\u2019s an excerpt from the 1.8 blockstate for fences, fence.json : \"east=true,north=false,south=false,west=false\": { \"model\": \"oak_fence_n\", \"y\": 90, \"uvlock\": true } This is just one variant out of 16. Even worse, there are 6 models for fences, one each for no connections, one connection, two connections in a straight line, two perpendicular connections, three connections, and one for all four connections. Here\u2019s an excerpt from the same file in 1.9, which uses the multipart format: { \"when\": { \"east\": \"true\" }, \"apply\": { \"model\": \"oak_fence_side\", \"y\": 90, \"uvlock\": true } } This is one case of 5. You can read this as \u201cwhen east=true, use the model oak_fence_side rotated 90 degrees\u201d. This allows the final model to be built up from 5 smaller parts, 4 of which (the connections) are conditional and the 5th being the unconditional central post. This uses only two models, one for the post, and one for the side connection.","title":"Intro to Blockstate JSONs"},{"location":"models/blockstates/introduction/#introduction-to-blockstate-jsons","text":"Blockstate JSONs are Minecraft\u2019s way to map \u201cvariant strings\u201d to models. A variant string can be absolutely anything, from \u201cinventory\u201d to \u201cpower=5\u201d to \u201cI am your father.\u201d They represent an actual model, where the blockstate is just a container for them. In code, a variant string within a blockstate JSON is represented by a ModelResourceLocation . When the game searches for a model corresponding to a block in the world, it takes the blockstate for that position, and then it uses an IStateMapper to find the corresponding ModelResourceLocation for it, which then refers to the actual model. The default IStateMapper uses the block\u2019s registry name as the location of the blockstate JSON. (E.g. block examplemod:testblock goes to the ResourceLocation examplemod:testblock .) The variant string is pieced together from the blockstate\u2019s properties. More information can be found here . As an example, let\u2019s take a look at the vanilla oak_log.json : { \"variants\": { \"axis=y\": { \"model\": \"oak_log\" }, \"axis=z\": { \"model\": \"oak_log_side\" }, \"axis=x\": { \"model\": \"oak_log_side\", \"y\": 90 }, \"axis=none\": { \"model\": \"oak_bark\" } } } Here we define 4 variant strings, and for each we use a certain model, either the upright log, the sideways log (rotated or not), and the all bark model (this model is not seen normally in vanilla; you have to use /setblock to create it). Since logs use the default IStateMapper , these variants will define the look of a log depending on the property axis . A blockstate always has to be defined for all possible variant strings. When you have many properties, this results in lots of possible variants, as every combination of properties must be defined. In Minecraft 1.8\u2019s blockstate format, you have to define every string explicitly, which leads to long, complicated files. It also doesn\u2019t support the concept of submodels, or multiple models in the same blockstate. In order to allievate this, Forge introduced its own blockstate format , which is available in Minecraft 1.8 and up. Starting from Minecraft 1.9, Mojang also introduced the \u201cmultipart\u201d format. You can find a definition of its format on the wiki . Forge\u2019s format and the multipart format are not better than each other; they each cover different use cases and it is your choice which one you want to use. Note The Forge format is really more like syntactic sugar for automatically calculating the set of all possible variants for you behind the scenes. This allows you to use the resulting ModelResourceLocation s for things other than blocks. ( Such as items . This is also true of the 1.8 format, but there is almost no reason to use that format.) The 1.9 format is a more complicated system that depends on having an IBlockState to pick the model. It will not directly work in other contexts without some code around it. For reference, here\u2019s an excerpt from the 1.8 blockstate for fences, fence.json : \"east=true,north=false,south=false,west=false\": { \"model\": \"oak_fence_n\", \"y\": 90, \"uvlock\": true } This is just one variant out of 16. Even worse, there are 6 models for fences, one each for no connections, one connection, two connections in a straight line, two perpendicular connections, three connections, and one for all four connections. Here\u2019s an excerpt from the same file in 1.9, which uses the multipart format: { \"when\": { \"east\": \"true\" }, \"apply\": { \"model\": \"oak_fence_side\", \"y\": 90, \"uvlock\": true } } This is one case of 5. You can read this as \u201cwhen east=true, use the model oak_fence_side rotated 90 degrees\u201d. This allows the final model to be built up from 5 smaller parts, 4 of which (the connections) are conditional and the 5th being the unconditional central post. This uses only two models, one for the post, and one for the side connection.","title":"Introduction to Blockstate JSONs"},{"location":"networking/","text":"Networking Communication between servers and clients is the backbone of a successful mod implementation. Read an overview of why networking matters and the basic strategies in thinking about networking. There are a variety of techniques provided by Forge to facilitate communication - mostly built on top of netty . The simplest, for a new mod, would be SimpleImpl , where most of the complexity of the netty system is abstracted away. It uses a message and handler style system.","title":"Home"},{"location":"networking/#networking","text":"Communication between servers and clients is the backbone of a successful mod implementation. Read an overview of why networking matters and the basic strategies in thinking about networking. There are a variety of techniques provided by Forge to facilitate communication - mostly built on top of netty . The simplest, for a new mod, would be SimpleImpl , where most of the complexity of the netty system is abstracted away. It uses a message and handler style system.","title":"Networking"},{"location":"networking/entities/","text":"Entities In addition to regular network messages, there are various other systems provided to handle synchronizing entity data. Spawn Data In general, the spawning of modded entities is handled seperately, by Forge. Note This means that simply extending a vanilla entity class may not inherit all its behaviour here. You may need to implement certain vanilla behaviours yourself. You can add extra data to the spawn packet Forge sends by implementing the following interface. IEntityAdditionalSpawnData If your entity has data that is needed on the client, but doesn\u2019t change over time, then it can be added to the entity spawn packet using this interface. writeSpawnData() and readSpawnData() control how the data should be en/decoded to/from the network buffer. Dynamic Data Data Parameters This is the main vanilla system for synchronizing entity data from the server to the client. As such, a number of vanilla examples are available to refer to. Firstly you need a DataParameter<T> for the data you wish to keep synchronized. This should be stored as a static final field in your entity class, obtained by calling EntityDataManager.createKey() and passing the entity class and a serializer for that type of data. The available serializer implementations can be found as static constants within the DataSerializers class. Warning You should only create data parameters for your own entities, within that entity\u2019s class . Adding parameters to entities you do not control can cause the IDs used to send that data over the network to become desynchronized, causing difficult to debug crashes. Then, override registerData() and call this.dataManager.register() for each of your data parameters, passing the parameter and an initial value to use. Remember to always call super.registerData() first! You can then get and set these values via your entity\u2019s dataManager instance. Changes made will be synchronized to the client automatically.","title":"Entities"},{"location":"networking/entities/#entities","text":"In addition to regular network messages, there are various other systems provided to handle synchronizing entity data.","title":"Entities"},{"location":"networking/entities/#spawn-data","text":"In general, the spawning of modded entities is handled seperately, by Forge. Note This means that simply extending a vanilla entity class may not inherit all its behaviour here. You may need to implement certain vanilla behaviours yourself. You can add extra data to the spawn packet Forge sends by implementing the following interface.","title":"Spawn Data"},{"location":"networking/entities/#ientityadditionalspawndata","text":"If your entity has data that is needed on the client, but doesn\u2019t change over time, then it can be added to the entity spawn packet using this interface. writeSpawnData() and readSpawnData() control how the data should be en/decoded to/from the network buffer.","title":"IEntityAdditionalSpawnData"},{"location":"networking/entities/#dynamic-data","text":"","title":"Dynamic Data"},{"location":"networking/entities/#data-parameters","text":"This is the main vanilla system for synchronizing entity data from the server to the client. As such, a number of vanilla examples are available to refer to. Firstly you need a DataParameter<T> for the data you wish to keep synchronized. This should be stored as a static final field in your entity class, obtained by calling EntityDataManager.createKey() and passing the entity class and a serializer for that type of data. The available serializer implementations can be found as static constants within the DataSerializers class. Warning You should only create data parameters for your own entities, within that entity\u2019s class . Adding parameters to entities you do not control can cause the IDs used to send that data over the network to become desynchronized, causing difficult to debug crashes. Then, override registerData() and call this.dataManager.register() for each of your data parameters, passing the parameter and an initial value to use. Remember to always call super.registerData() first! You can then get and set these values via your entity\u2019s dataManager instance. Changes made will be synchronized to the client automatically.","title":"Data Parameters"},{"location":"networking/overview/","text":"Overview There are two primary goals in network communication: Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates X,Y,Z just grew Giving the client a way to tell the server that something has changed about the player the player pressed a key The most common way to accomplish these goals is to pass messages between the client and the server. These messages will usually be structured, containing data in a particular arrangement, for easy sending and receiving.","title":"Overview"},{"location":"networking/overview/#overview","text":"There are two primary goals in network communication: Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates X,Y,Z just grew Giving the client a way to tell the server that something has changed about the player the player pressed a key The most common way to accomplish these goals is to pass messages between the client and the server. These messages will usually be structured, containing data in a particular arrangement, for easy sending and receiving.","title":"Overview"},{"location":"networking/simpleimpl/","text":"SimpleImpl SimpleImpl is the name given to the packet system that revolves around the SimpleChannel class. Using this system is by far the easiest way to send custom data between clients and the server. Getting Started First you need to create your SimpleChannel object. We recommend that you do this in a separate class, possibly something like ModidPacketHandler . Create your SimpleChannel as a static field in this class, like so: private static final String PROTOCOL_VERSION = \"1\"; public static final SimpleChannel INSTANCE = NetworkRegistry.newSimpleChannel( new ResourceLocation(\"mymodid\", \"main\"), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals ); The first argument is a name for the channel. The second argument is a Supplier<String> returning the current network protocol version. The third and fourth arguments respectively are Predicate<String> checking whether an incoming connection protocol version is network-compatible with the client or server, respectively. Here, we simply compare with the PROTOCOL_VERSION field directly, meaning that the client and server PROTOCOL_VERSION s must always match or FML will deny login. Registering Packets Next, we must declare the types of messages that we would like to send and receive. This is done using the INSTANCE.registerMessage method, which takes 5 parameters. The first parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a local variable to hold the ID, and then call registerMessage using id++ . This will guarantee 100% unique IDs. The second parameter is the actual packet class MSG . The third parameter is a BiConsumer<MSG, PacketBuffer> responsible for encoding the message into the provided PacketBuffer The fourth parameter is a Function<PacketBuffer, MSG> responsible for decoding the message from the provided PacketBuffer The final parameter is a BiConsumer<MSG, Supplier<NetworkEvent.Context>> responsible for handling the message itself The last three parameters can be method references to either static or instance methods in Java. Remember that an instance method MSG.encode(PacketBuffer) still satisfies BiConsumer<MSG, PacketBuffer> , the MSG simply becomes the implicit first argument. Handling Packets There are a couple things to highlight in a packet handler. A packet handler has both the message object and the network context available to it. The context allows access to the player that sent the packet (if on the server), and a way to enqueue threadsafe work. public static void handle(MyMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> { // Work that needs to be threadsafe (most work) EntityPlayerMP sender = ctx.get().getSender(); // the client that sent this packet // do stuff }); ctx.get().setPacketHandled(true); } Note the presence of setPacketHandled , which used to tell the network system that the packet has successfully completed handling. Warning As of Minecraft 1.8 packets are by default handled on the network thread. That means that your handler can not interact with most game objects directly. Forge provides a convenient way to make your code execute on the main thread instead using IThreadListener.addScheduledTask . Simply call ctx.get().enqueueWork(Runnable) , which will call the given Runnable on the main thread at the next opportunity. Warning Be defensive when handling packets on the server. A client could attempt to exploit the packet handling by sending unexpected data. A common problem is vulnerability to arbitrary chunk generation . This typically happens when the server is trusting a block position sent by a client to access blocks and tile entities. When accessing blocks and tile entities in unloaded areas of the world, the server will either generate or load this area from disk, then promply write it to disk. This can be exploited to cause catastrophic damage to a server\u2019s performance and storage space without leaving a trace. To avoid this problem, a general rule of thumb is to only access blocks and tile entities if world.isBlockLoaded(pos) is true. Sending Packets Sending to the Server There is but one way to send a packet to the server. This is because there is only ever one server the client can be connected to at once. To do so, we must again use that SimpleChannel that was defined earlier. Simply call INSTANCE.sendToServer(new MyMessage()) . The message will be sent to the handler for its type, if one exists. Sending to Clients Packets can be sent directly to a client using the SimpleChannel : HANDLER.sendTo(MSG, entityPlayerMP.connection.getNetworkManager(), NetworkDirection.PLAY_TO_CLIENT) . However, this can be quite inconvenient. Forge has some convenience functions that can be used: // Sending to one player INSTANCE.send(PacketDistributor.PLAYER.with(playerMP), new MyMessage()); // Send to all players tracking this chunk INSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(chunk), new MyMessage()); // Sending to all connected players INSTANCE.send(PacketDistributor.ALL.noArg(), new MyMessage()); There are additional PacketDistributor types available, check the documentation on the PacketDistributor class for more details.","title":"SimpleImpl"},{"location":"networking/simpleimpl/#simpleimpl","text":"SimpleImpl is the name given to the packet system that revolves around the SimpleChannel class. Using this system is by far the easiest way to send custom data between clients and the server.","title":"SimpleImpl"},{"location":"networking/simpleimpl/#getting-started","text":"First you need to create your SimpleChannel object. We recommend that you do this in a separate class, possibly something like ModidPacketHandler . Create your SimpleChannel as a static field in this class, like so: private static final String PROTOCOL_VERSION = \"1\"; public static final SimpleChannel INSTANCE = NetworkRegistry.newSimpleChannel( new ResourceLocation(\"mymodid\", \"main\"), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals ); The first argument is a name for the channel. The second argument is a Supplier<String> returning the current network protocol version. The third and fourth arguments respectively are Predicate<String> checking whether an incoming connection protocol version is network-compatible with the client or server, respectively. Here, we simply compare with the PROTOCOL_VERSION field directly, meaning that the client and server PROTOCOL_VERSION s must always match or FML will deny login.","title":"Getting Started"},{"location":"networking/simpleimpl/#registering-packets","text":"Next, we must declare the types of messages that we would like to send and receive. This is done using the INSTANCE.registerMessage method, which takes 5 parameters. The first parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a local variable to hold the ID, and then call registerMessage using id++ . This will guarantee 100% unique IDs. The second parameter is the actual packet class MSG . The third parameter is a BiConsumer<MSG, PacketBuffer> responsible for encoding the message into the provided PacketBuffer The fourth parameter is a Function<PacketBuffer, MSG> responsible for decoding the message from the provided PacketBuffer The final parameter is a BiConsumer<MSG, Supplier<NetworkEvent.Context>> responsible for handling the message itself The last three parameters can be method references to either static or instance methods in Java. Remember that an instance method MSG.encode(PacketBuffer) still satisfies BiConsumer<MSG, PacketBuffer> , the MSG simply becomes the implicit first argument.","title":"Registering Packets"},{"location":"networking/simpleimpl/#handling-packets","text":"There are a couple things to highlight in a packet handler. A packet handler has both the message object and the network context available to it. The context allows access to the player that sent the packet (if on the server), and a way to enqueue threadsafe work. public static void handle(MyMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> { // Work that needs to be threadsafe (most work) EntityPlayerMP sender = ctx.get().getSender(); // the client that sent this packet // do stuff }); ctx.get().setPacketHandled(true); } Note the presence of setPacketHandled , which used to tell the network system that the packet has successfully completed handling. Warning As of Minecraft 1.8 packets are by default handled on the network thread. That means that your handler can not interact with most game objects directly. Forge provides a convenient way to make your code execute on the main thread instead using IThreadListener.addScheduledTask . Simply call ctx.get().enqueueWork(Runnable) , which will call the given Runnable on the main thread at the next opportunity. Warning Be defensive when handling packets on the server. A client could attempt to exploit the packet handling by sending unexpected data. A common problem is vulnerability to arbitrary chunk generation . This typically happens when the server is trusting a block position sent by a client to access blocks and tile entities. When accessing blocks and tile entities in unloaded areas of the world, the server will either generate or load this area from disk, then promply write it to disk. This can be exploited to cause catastrophic damage to a server\u2019s performance and storage space without leaving a trace. To avoid this problem, a general rule of thumb is to only access blocks and tile entities if world.isBlockLoaded(pos) is true.","title":"Handling Packets"},{"location":"networking/simpleimpl/#sending-packets","text":"","title":"Sending Packets"},{"location":"networking/simpleimpl/#sending-to-the-server","text":"There is but one way to send a packet to the server. This is because there is only ever one server the client can be connected to at once. To do so, we must again use that SimpleChannel that was defined earlier. Simply call INSTANCE.sendToServer(new MyMessage()) . The message will be sent to the handler for its type, if one exists.","title":"Sending to the Server"},{"location":"networking/simpleimpl/#sending-to-clients","text":"Packets can be sent directly to a client using the SimpleChannel : HANDLER.sendTo(MSG, entityPlayerMP.connection.getNetworkManager(), NetworkDirection.PLAY_TO_CLIENT) . However, this can be quite inconvenient. Forge has some convenience functions that can be used: // Sending to one player INSTANCE.send(PacketDistributor.PLAYER.with(playerMP), new MyMessage()); // Send to all players tracking this chunk INSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(chunk), new MyMessage()); // Sending to all connected players INSTANCE.send(PacketDistributor.ALL.noArg(), new MyMessage()); There are additional PacketDistributor types available, check the documentation on the PacketDistributor class for more details.","title":"Sending to Clients"},{"location":"rendering/teisr/","text":"TileEntityItemStackRenderer Note The features used here only exist in forge versions >= 14.23.2.2638. TileEntityItemStackRenderer is a method to use OpenGL to render on items. This system is much simpler than the old TESRItemStack system, which required a TileEntity, and did not allow access to the ItemStack. Using TileEntityItemStackRenderer TileEntityItemStackRenderer allows you to render your item using public void renderByItem(ItemStack itemStackIn) . There is an overload that takes partialTicks as a parameter, but it is never called in vanilla. In order to use a TEISR, the Item must first satisfy the condition that its model returns true for IBakedModel#isBuiltInRenderer . Once that returns true, the Item\u2019s TEISR will be accessed for rendering. If it does not have one, it will use the default TileEntityItemStackRenderer.instance . To set the TEISR for an Item, use Item#setTileEntityItemStackRenderer . Each Item can only ever provide one TEISR, and the getter is final so that mods do not return new instances each frame. That\u2019s it, no additional setup is necessary to use a TEISR. If you need to access the TransformType for rendering, you can store the one passed through IBakedModel#handlePerspective , and use it during rendering. This method will always be called before TileEntityItemStackRenderer#renderByItem .","title":"TileEntityItemStackRenderer"},{"location":"rendering/teisr/#tileentityitemstackrenderer","text":"Note The features used here only exist in forge versions >= 14.23.2.2638. TileEntityItemStackRenderer is a method to use OpenGL to render on items. This system is much simpler than the old TESRItemStack system, which required a TileEntity, and did not allow access to the ItemStack.","title":"TileEntityItemStackRenderer"},{"location":"rendering/teisr/#using-tileentityitemstackrenderer","text":"TileEntityItemStackRenderer allows you to render your item using public void renderByItem(ItemStack itemStackIn) . There is an overload that takes partialTicks as a parameter, but it is never called in vanilla. In order to use a TEISR, the Item must first satisfy the condition that its model returns true for IBakedModel#isBuiltInRenderer . Once that returns true, the Item\u2019s TEISR will be accessed for rendering. If it does not have one, it will use the default TileEntityItemStackRenderer.instance . To set the TEISR for an Item, use Item#setTileEntityItemStackRenderer . Each Item can only ever provide one TEISR, and the getter is final so that mods do not return new instances each frame. That\u2019s it, no additional setup is necessary to use a TEISR. If you need to access the TransformType for rendering, you can store the one passed through IBakedModel#handlePerspective , and use it during rendering. This method will always be called before TileEntityItemStackRenderer#renderByItem .","title":"Using TileEntityItemStackRenderer"},{"location":"tileentities/tesr/","text":"TileEntityRenderer A TileEntityRenderer or TER (previously TileEntitySpecialRenderer or TESR ) is used to render blocks in a way that cannot be represented with a static baked model (JSON, OBJ, B3D, others). A tile entity renderer requires the block to have a TileEntity. By default OpenGL (via GlStateManager ) is used to handle rendering in a TER. See the OpenGL documentation to learn more. It is recommended to use a TileEntityRendererFast instead whenever possible. Creating a TER To create a TER, create a class that inherits from TileEntityRenderer . It takes a generic argument specifying the block\u2019s TileEntity class. The generic argument is used in the TER\u2019s render method. Only one TER exists for a given tile entity. Therefore, values that are specific to a single instance in the world should be stored in the tile entity being passed to the renderer rather than in the TER itself. For example, an integer that increments every frame, if stored in the TER, will increment every frame for every tile entity of this type in the world. render This method is called every frame in order to render the tile entity. Parameters tileentity : This is the instance of the tile entity being rendered. x , y , z : The position at which the tile entity should be rendered. partialTicks : The amount of time, in fractions of a tick, that has passed since the last full tick. destroyStage : The destroy stage for the block if it is being broken. Registering a TER In order to register a TESR, call ClientRegistry#bindTileEntitySpecialRenderer passing the tile entity class to be renderer with this TER and the instance of the TER to use to render all TEs of this class. TileEntityRendererFast A TER can opt-in to being a \u201cfast\u201d renderer by extending the TileEntityRendererFast class instead of TileEntityRenderer and returning true from IForgeTileEntity#hasFastRenderer . Instead of implementing render , renderTileEntityFast must be implemented. A fast TER can offer performance improvements over a traditional TER and should be used wherever possible. This is due to the fact that all fast TER instances are batched together and only issue one combined draw call for all fast TERs per frame to the GPU. This advantage comes at the cost of making direct OpenGL access via GlStateManager or the GLXX classes impossible. Instead a fast TER must only add vertices to the provided VertexBuffer , which represents the combined vertex data for all fast TERs. This allows rendering IBakedModel s. An example can be found in Forge\u2019s TileEntityRendererAnimation .","title":"Renderer"},{"location":"tileentities/tesr/#tileentityrenderer","text":"A TileEntityRenderer or TER (previously TileEntitySpecialRenderer or TESR ) is used to render blocks in a way that cannot be represented with a static baked model (JSON, OBJ, B3D, others). A tile entity renderer requires the block to have a TileEntity. By default OpenGL (via GlStateManager ) is used to handle rendering in a TER. See the OpenGL documentation to learn more. It is recommended to use a TileEntityRendererFast instead whenever possible.","title":"TileEntityRenderer"},{"location":"tileentities/tesr/#creating-a-ter","text":"To create a TER, create a class that inherits from TileEntityRenderer . It takes a generic argument specifying the block\u2019s TileEntity class. The generic argument is used in the TER\u2019s render method. Only one TER exists for a given tile entity. Therefore, values that are specific to a single instance in the world should be stored in the tile entity being passed to the renderer rather than in the TER itself. For example, an integer that increments every frame, if stored in the TER, will increment every frame for every tile entity of this type in the world.","title":"Creating a TER"},{"location":"tileentities/tesr/#render","text":"This method is called every frame in order to render the tile entity.","title":"render"},{"location":"tileentities/tesr/#parameters","text":"tileentity : This is the instance of the tile entity being rendered. x , y , z : The position at which the tile entity should be rendered. partialTicks : The amount of time, in fractions of a tick, that has passed since the last full tick. destroyStage : The destroy stage for the block if it is being broken.","title":"Parameters"},{"location":"tileentities/tesr/#registering-a-ter","text":"In order to register a TESR, call ClientRegistry#bindTileEntitySpecialRenderer passing the tile entity class to be renderer with this TER and the instance of the TER to use to render all TEs of this class.","title":"Registering a TER"},{"location":"tileentities/tesr/#tileentityrendererfast","text":"A TER can opt-in to being a \u201cfast\u201d renderer by extending the TileEntityRendererFast class instead of TileEntityRenderer and returning true from IForgeTileEntity#hasFastRenderer . Instead of implementing render , renderTileEntityFast must be implemented. A fast TER can offer performance improvements over a traditional TER and should be used wherever possible. This is due to the fact that all fast TER instances are batched together and only issue one combined draw call for all fast TERs per frame to the GPU. This advantage comes at the cost of making direct OpenGL access via GlStateManager or the GLXX classes impossible. Instead a fast TER must only add vertices to the provided VertexBuffer , which represents the combined vertex data for all fast TERs. This allows rendering IBakedModel s. An example can be found in Forge\u2019s TileEntityRendererAnimation .","title":"TileEntityRendererFast"},{"location":"tileentities/tileentity/","text":"TileEntities Tile Entities are like simplified Entities, that are bound to a Block. They are used to store dynamic data, execute tick based tasks and for dynamic rendering. Some examples from vanilla Minecraft would be: handling of inventories (chests), smelting logic on furnaces, or area effects for beacons. More advanced examples exist in mods, such as quarries, sorting machines, pipes, and displays. Note TileEntities aren\u2019t a solution for everything and they can cause lag when used wrongly. When possible, try to avoid them. Creating a TileEntity In order to create a TileEntity you need to extend the TileEntity class. To register it, listen for the appropriate registry event and create a TileEntityType : @SubscribeEvent public static void registerTE(RegistryEvent.Register<TileEntityType<?>> evt) { TileEntityType<?> type = TileEntityType.Builder.create(<factory>).build(null) type.setRegistryName(\"mymod\", \"myte\"); evt.getRegistry().register(type); } Attaching a TileEntity to a Block To attach your new TileEntity to a Block you need to override 2 (two) methods within the Block class. IForgeBlock#hasTileEntity(IBlockstate state) IForgeBlock#createTileEntity(World world, IBlockState state) Using the parameters you can choose if the block should have a TileEntity or not. Usually you will return true in the first method and a new instance of your TileEntity in the second method. Storing Data within your TileEntity In order to save data, override the following two methods TileEntity#write(NBTTagCompound nbt) TileEntity#read(NBTTagCompound nbt) These methods are called whenever the Chunk containing the TileEntity gets loaded from/saved to NBT. Use them to read and write to the fields in your tile entity class. Note Whenever your data changes you need to call TileEntity#markDirty() , otherwise the Chunk containing your TileEntity might be skipped while the world is saved. Important It is important that you call the super methods! The tag names id , x , y , z , ForgeData and ForgeCaps are reserved by the super methods. Ticking TileEntities If you need a ticking TileEntity , for example to keep track of the progress during a smelting process, you need to add the net.minecraft.util.ITickable interface to your TileEntity . Now you can implement all your calculations within ITickable#update() Note This method is called each tick, therefore you should avoid having complicated calculations in here. If possible, you should make more complex calculations just every X ticks. (The amount of ticks in a second may be lower then 20 (twenty) but won\u2019t be higher) Synchronizing the Data to the Client There are 3 (three) ways of syncing data to the client. Synchronizing on chunk load, synchronizing on block updates and synchronizing with a custom network message. Synchronizing on chunk load For this you need to override TileEntity#getUpdateTag() IForgeTileEntity#handleUpdateTag(NBTTagCompound nbt) Again, this is pretty simple, the first method collects the data that should be send to the client, while the second one processes that data. If your TileEntity doesn\u2019t contain much data you might be able to use the methods out of the Storing Data within your TileEntity section. Important Synchronizing excessive/useless data for TileEntities can lead to network congestion. You should optimize your network usage by sending only the information the client needs when the client needs it. For instance, it is more often than not unnecessary to send the inventory of a tile entity in the update tag, as this can be synchronized via its GUI. Synchronizing on block update This method is a bit more complicated, but again you just need to override 2 methods. Here is a tiny example implementation of it @Override public SPacketUpdateTileEntity getUpdatePacket(){ NBTTagCompound nbtTag = new NBTTagCompound(); //Write your data into the nbtTag return new SPacketUpdateTileEntity(getPos(), 1, nbtTag); } @Override public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity pkt){ NBTTagCompound tag = pkt.getNbtCompound(); //Handle your Data } The Constructor of SPacketUpdateTileEntity takes: The position of your TileEntity . An ID, though it isn\u2019t really used besides by Vanilla, therefore you can just put a -1 in there. An NBTTagCompound which should contain your data. Now, to send the packet, an update notification must be given on the server. World#notifyBlockUpdate(BlockPos pos, IBlockState oldState, IBlockState newState, int flags) The pos should be your TileEntitiy\u2019s position. For oldState and newState you can pass the current BlockState at that position. The flags are a bitmask and should contain 2, which will sync the changes to the client. Synchronizing using a custom network message This way of synchronizing is probably the most complicated one, but is usually also the most optimized one, as you can make sure that only the data you need to be synchronized is actually synchronized. You should first check out the Networking section and especially SimpleImpl before attempting this. Once you\u2019ve created your custom network message, you can send it to all users that have the TileEntity loaded with: SimpleNetworkWrapper#sendToAllTracking(IMessage, NetworkRegistry.TargetPoint) Warning It is important that you do safety checks, the TileEntity might already be destroyed/replaced when the message arrives at the player! You should also check if the chunk is loaded ( World#isBlockLoaded(BlockPos) )","title":"Home"},{"location":"tileentities/tileentity/#tileentities","text":"Tile Entities are like simplified Entities, that are bound to a Block. They are used to store dynamic data, execute tick based tasks and for dynamic rendering. Some examples from vanilla Minecraft would be: handling of inventories (chests), smelting logic on furnaces, or area effects for beacons. More advanced examples exist in mods, such as quarries, sorting machines, pipes, and displays. Note TileEntities aren\u2019t a solution for everything and they can cause lag when used wrongly. When possible, try to avoid them.","title":"TileEntities"},{"location":"tileentities/tileentity/#creating-a-tileentity","text":"In order to create a TileEntity you need to extend the TileEntity class. To register it, listen for the appropriate registry event and create a TileEntityType : @SubscribeEvent public static void registerTE(RegistryEvent.Register<TileEntityType<?>> evt) { TileEntityType<?> type = TileEntityType.Builder.create(<factory>).build(null) type.setRegistryName(\"mymod\", \"myte\"); evt.getRegistry().register(type); }","title":"Creating a TileEntity"},{"location":"tileentities/tileentity/#attaching-a-tileentity-to-a-block","text":"To attach your new TileEntity to a Block you need to override 2 (two) methods within the Block class. IForgeBlock#hasTileEntity(IBlockstate state) IForgeBlock#createTileEntity(World world, IBlockState state) Using the parameters you can choose if the block should have a TileEntity or not. Usually you will return true in the first method and a new instance of your TileEntity in the second method.","title":"Attaching a TileEntity to a Block"},{"location":"tileentities/tileentity/#storing-data-within-your-tileentity","text":"In order to save data, override the following two methods TileEntity#write(NBTTagCompound nbt) TileEntity#read(NBTTagCompound nbt) These methods are called whenever the Chunk containing the TileEntity gets loaded from/saved to NBT. Use them to read and write to the fields in your tile entity class. Note Whenever your data changes you need to call TileEntity#markDirty() , otherwise the Chunk containing your TileEntity might be skipped while the world is saved. Important It is important that you call the super methods! The tag names id , x , y , z , ForgeData and ForgeCaps are reserved by the super methods.","title":"Storing Data within your TileEntity"},{"location":"tileentities/tileentity/#ticking-tileentities","text":"If you need a ticking TileEntity , for example to keep track of the progress during a smelting process, you need to add the net.minecraft.util.ITickable interface to your TileEntity . Now you can implement all your calculations within ITickable#update() Note This method is called each tick, therefore you should avoid having complicated calculations in here. If possible, you should make more complex calculations just every X ticks. (The amount of ticks in a second may be lower then 20 (twenty) but won\u2019t be higher)","title":"Ticking TileEntities"},{"location":"tileentities/tileentity/#synchronizing-the-data-to-the-client","text":"There are 3 (three) ways of syncing data to the client. Synchronizing on chunk load, synchronizing on block updates and synchronizing with a custom network message.","title":"Synchronizing the Data to the Client"},{"location":"tileentities/tileentity/#synchronizing-on-chunk-load","text":"For this you need to override TileEntity#getUpdateTag() IForgeTileEntity#handleUpdateTag(NBTTagCompound nbt) Again, this is pretty simple, the first method collects the data that should be send to the client, while the second one processes that data. If your TileEntity doesn\u2019t contain much data you might be able to use the methods out of the Storing Data within your TileEntity section. Important Synchronizing excessive/useless data for TileEntities can lead to network congestion. You should optimize your network usage by sending only the information the client needs when the client needs it. For instance, it is more often than not unnecessary to send the inventory of a tile entity in the update tag, as this can be synchronized via its GUI.","title":"Synchronizing on chunk load"},{"location":"tileentities/tileentity/#synchronizing-on-block-update","text":"This method is a bit more complicated, but again you just need to override 2 methods. Here is a tiny example implementation of it @Override public SPacketUpdateTileEntity getUpdatePacket(){ NBTTagCompound nbtTag = new NBTTagCompound(); //Write your data into the nbtTag return new SPacketUpdateTileEntity(getPos(), 1, nbtTag); } @Override public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity pkt){ NBTTagCompound tag = pkt.getNbtCompound(); //Handle your Data } The Constructor of SPacketUpdateTileEntity takes: The position of your TileEntity . An ID, though it isn\u2019t really used besides by Vanilla, therefore you can just put a -1 in there. An NBTTagCompound which should contain your data. Now, to send the packet, an update notification must be given on the server. World#notifyBlockUpdate(BlockPos pos, IBlockState oldState, IBlockState newState, int flags) The pos should be your TileEntitiy\u2019s position. For oldState and newState you can pass the current BlockState at that position. The flags are a bitmask and should contain 2, which will sync the changes to the client.","title":"Synchronizing on block update"},{"location":"tileentities/tileentity/#synchronizing-using-a-custom-network-message","text":"This way of synchronizing is probably the most complicated one, but is usually also the most optimized one, as you can make sure that only the data you need to be synchronized is actually synchronized. You should first check out the Networking section and especially SimpleImpl before attempting this. Once you\u2019ve created your custom network message, you can send it to all users that have the TileEntity loaded with: SimpleNetworkWrapper#sendToAllTracking(IMessage, NetworkRegistry.TargetPoint) Warning It is important that you do safety checks, the TileEntity might already be destroyed/replaced when the message arrives at the player! You should also check if the chunk is loaded ( World#isBlockLoaded(BlockPos) )","title":"Synchronizing using a custom network message"},{"location":"utilities/permissionapi/","text":"PermissionAPI The PermissionAPI is a very basic implementation of a permission system. Its default implementation doesn\u2019t add an advanced permission handling (like we know it for example from PEX), but instead it has 3 permission levels, (ALL = all players, OP = operators, NONE = neither normal players nor operators). This behaviour can be changed by mods which implement their own PermissionHandler. How to use the PermissionAPI For basic support you just need to call PermissionAPI.hasPermission(EntityPlayer player, String node) , though by default this is going to return always false, as the default implementation uses the permission level NONE So if we want that all players, or just OP\u2019s to be able to use this we also need to register our permission node. Achieving this is as simple as checking for permissions: PermissionAPI.registerNode(String node, DefaultPermissionLevel level, String description) , though this has to be done in Init or Later. Note The PermissionAPI isn\u2019t restricted to be used for commands, you could also use it for other things, like restricting access to a GUI. Also, you need to check if your ICommandSender is a player if you use it in combination with commands! DefaultPermissionLevel The DefaultPermissionLevel has 3 Values: * ALL =all players got this permission * OP = only operators got this permission * NONE = neither normal players nor operators got this permission Permission node While there are technically no rules for the permission nodes, the best practice is to be of the form modid.subgroup.permission_id It is recommended to use this naming scheme as other implementations may have stricter rules. Making your own implementation of the PermissionHandler By default the PermissionHandler is very basic, which is usually enough for most users, but you might want more control over the permissions for things like a big server. This can be achieved by creating a custom PermissionHandler . How it works and what is capable of, is totally up to you, for example you could make a simple implementation just saving a file per player. Or you could make it as advanced as PEX, having database support and many other functions. Note Not every mod that wants to use the PermissionAPI should change the PermissionHandler as there can be only 1 at the same time! First off, how you implement your own PermissionHandler is completely up to you, you can use files, a database or whatever you want. All you need to do is create your own implementation of the interface IPermissionHandler . After that is done, you also need to register it using: PermissionAPI.setPermissionHandler(IPermissionHandler handler) Note You\u2019ve got to set the Handler during PreInit! It is also recommended to check if it wasn\u2019t already replaced by another mod.","title":"PermissionAPI"},{"location":"utilities/permissionapi/#permissionapi","text":"The PermissionAPI is a very basic implementation of a permission system. Its default implementation doesn\u2019t add an advanced permission handling (like we know it for example from PEX), but instead it has 3 permission levels, (ALL = all players, OP = operators, NONE = neither normal players nor operators). This behaviour can be changed by mods which implement their own PermissionHandler.","title":"PermissionAPI"},{"location":"utilities/permissionapi/#how-to-use-the-permissionapi","text":"For basic support you just need to call PermissionAPI.hasPermission(EntityPlayer player, String node) , though by default this is going to return always false, as the default implementation uses the permission level NONE So if we want that all players, or just OP\u2019s to be able to use this we also need to register our permission node. Achieving this is as simple as checking for permissions: PermissionAPI.registerNode(String node, DefaultPermissionLevel level, String description) , though this has to be done in Init or Later. Note The PermissionAPI isn\u2019t restricted to be used for commands, you could also use it for other things, like restricting access to a GUI. Also, you need to check if your ICommandSender is a player if you use it in combination with commands!","title":"How to use the PermissionAPI"},{"location":"utilities/permissionapi/#defaultpermissionlevel","text":"The DefaultPermissionLevel has 3 Values: * ALL =all players got this permission * OP = only operators got this permission * NONE = neither normal players nor operators got this permission","title":"DefaultPermissionLevel"},{"location":"utilities/permissionapi/#permission-node","text":"While there are technically no rules for the permission nodes, the best practice is to be of the form modid.subgroup.permission_id It is recommended to use this naming scheme as other implementations may have stricter rules.","title":"Permission node"},{"location":"utilities/permissionapi/#making-your-own-implementation-of-the-permissionhandler","text":"By default the PermissionHandler is very basic, which is usually enough for most users, but you might want more control over the permissions for things like a big server. This can be achieved by creating a custom PermissionHandler . How it works and what is capable of, is totally up to you, for example you could make a simple implementation just saving a file per player. Or you could make it as advanced as PEX, having database support and many other functions. Note Not every mod that wants to use the PermissionAPI should change the PermissionHandler as there can be only 1 at the same time! First off, how you implement your own PermissionHandler is completely up to you, you can use files, a database or whatever you want. All you need to do is create your own implementation of the interface IPermissionHandler . After that is done, you also need to register it using: PermissionAPI.setPermissionHandler(IPermissionHandler handler) Note You\u2019ve got to set the Handler during PreInit! It is also recommended to check if it wasn\u2019t already replaced by another mod.","title":"Making your own implementation of the PermissionHandler"},{"location":"utilities/recipes/","text":"Recipes With the update to Minecraft 1.12, Mojang introduced a new data-driven recipe system based on JSON files. Since then it has been adopted by Forge as well and will be expanded in Minecraft 1.13 into datapacks. Loading Recipes Forge will load all recipes which can be found within the ./assets/<modid>/recipes/ folder. You can call these files whatever you want, thought the vanilla convention is to name them after the output item. This name is also used as the registration key, but does not affect the operation of the recipe. Note Recipe files cannot begin with an underscore as this is reserved for constants files. The JSON file extension is required. The Recipe file A basic recipe file might look like the following example: { \"type\": \"minecraft:crafting_shaped\", \"pattern\": [ \"xxa\", \"x x\", \"xxx\" ], \"key\": { \"x\": { \"type\": \"forge:ore_dict\", \"ore\": \"gemDiamond\" }, \"a\": { \"item\": \"mymod:myfirstitem\", \"data\": 1 } }, \"result\": { \"item\": \"mymod:myitem\", \"count\": 9, \"data\": 2 } } Note When you first obtain an ingredient to a vanilla recipe it will automatically unlock the recipe in the recipe book. To achieve the same effect, you have to use the Advancement system and create a new Advancement for each of your ingredients. The advancement has to exist. This doesn\u2019t mean it has to be visible in the advancement tree. Type The type of a recipe with the type field. You can think of this as the definition of which crafting layout is to be used, for example minecraft:crafting_shaped or minecraft:crafting_shapeless . If you want, you can define your own types as well which requires the use of a _factories.json file. Groups Optionally you can add a group to your recipes to be displayed within the recipe helper interface. All recipes with the same group String will be shown in the same group. For example, this can be used to have all door recipes shown in the recipe helper interface as a single entry, even though there are different types of doors. Types of crafting recipes Within this section we will take a closer look on the differences between defining a shaped and a shapeless crafting recipe. Shaped crafting Shaped recipes require the pattern and key keywords. A pattern defines the slot an item must appear in using placeholder characters. You can choose whatever character you want to be a placeholder for an item. Keys on the other hand define what items are to be used instead of the placeholders. A key is defined by a placeholder character and the item. Additional the type forge:ore_dict may be added. This defines the item beeing part of the OreDictionary and can for example be used when it doesn\u2019t matter which copper ore is used to produce a copper ingot. In this case the ore tag has to be used instead of the item tag to define the item. There are many more of these types which can be used here and you can even register your own. The data tag is a optional and used to define the metadata of a block or item. Important Any item which uses setHasSubtypes(true) requires the use of the data field. When it is not used within the ingredients or keys, it will mean any metadata of this item will be accepted, for example: Not defining the data of a sword means even a half broken sword will be accepted for the crafting recipe! Shapeless crafting A shapeless recipe doesn\u2019t make use of the pattern and key keywords. To define a shapeless recipe, you have to use the ingredients list. It defines which items have to be used for the crafting process and can also make use of the additional type forge:ore_dict and it\u2019s functionality as described above. There are many more of these types which can be used here and you can even register your own. It is even possible to define multiple instances of the same item which means multiple of these items have to be in place for the crafting recipe to take place. Note While there is no limit on how many ingredients your recipe requires the vanilla crafting table does only allow 9 items to be placed for each crafting recipe. The following example shows how an ingredient list looks like within JSON. \"ingredients\": [ { \"type\": \"forge:ore_dict\", \"ore\": \"gemDiamond\" }, { \"item\": \"minecraft:nether_star\" } ], Smelting To define a recipe for the furnace, you have to use GameRegistry.addSmelting(input, output, exp); as the smelting recipes are currently not JSON based. Recipe Elements Patterns A pattern will be defined with the pattern list. Each string represents one row in the crafting grid and each placeholder character within the String represents a column. As seen in the example above a space means that no item needs to be inserted at that position. Keys A key set is used in combination with patterns and contains keys whose name is the same as the placeholder character in the pattern list which it represents. One key may be defined to represent multiply items as it is the case for the wooden button. This means that the player can use one of the defined items for the crafting recipe, for example different types of wood. \"key\": { \"#\": [ { \"item\": \"minecraft:planks\", \"data\": 0 }, { \"item\": \"minecraft:planks\", \"data\": 1 } ] } Results Every recipe has to have a result tag to define the output item. When crafting something, you can get out more than one item. This is achieved by defining the count number. If this is left out, meaning it doesn\u2019t exist within the result block, it defaults to 1. Negative values are not allowed here as an Itemstack cannot be smaller than 0. There is no option to use the count number anywhere else than for the result. The data field is a optional and used to define the metadata of a block or item. It defaults to 0 when it doesn\u2019t exist. Note Any item which uses setHasSubtypes(true) requires the data field. In this case, it is not optional! Factories Factories can be used to allow defining recipes and ingredients of a custom type (class). To create your own factory, create a _factories.json . Within this file a type has to be defined, for example: recipes , ingredients or conditions . These types represent IRecipeFactory , IIngredientFactory , and IConditionFactory , respectively. The entry \u201ckey\u201d must be a name which can be later used in your recipes, and the \u201cvalue\u201d is the fully qualified class name is a class you have to create which implements one of the above recipes. The class must have an empty constructor. For example: { \"<type>\": { \"<name>\": \"<fully qualified classname for the specified type>\" } } Note There is no need to create a new _factories.json for each type you want to specify, they can all be defined in a single file. Conditional Recipes Conditional recipes can be created by making use of the factory system described above. For this you use the conditions type with the IConditionFactory from above and can later add the conditions type to your recipes: { \"conditions\": [ { \"type\": \"<modid>:<name>\" } ] } These conditions only apply to the recipe as a whole and not to ingredients. As an example, you might want to check if a mod is loaded using the already existing condition forge:mod_loaded , and \"modid\": \"<mod to check>\" . Note Conditions will only be checked once at startup! Constants It is possible to define constant values for your recipes. These values have to be defined within a _constants.json and can be used within any recipe of your mod by just writing #<name> . For filled buckets, you should use fluid instead of data . For example, this constant defines #SADDLE which represents the vanilla saddle item. [ { \"name\": \"SADDLE\", \"ingredient\": { \"item\": \"minecraft:saddle\", \"data\": 0 } } ]","title":"Recipes"},{"location":"utilities/recipes/#recipes","text":"With the update to Minecraft 1.12, Mojang introduced a new data-driven recipe system based on JSON files. Since then it has been adopted by Forge as well and will be expanded in Minecraft 1.13 into datapacks.","title":"Recipes"},{"location":"utilities/recipes/#loading-recipes","text":"Forge will load all recipes which can be found within the ./assets/<modid>/recipes/ folder. You can call these files whatever you want, thought the vanilla convention is to name them after the output item. This name is also used as the registration key, but does not affect the operation of the recipe. Note Recipe files cannot begin with an underscore as this is reserved for constants files. The JSON file extension is required.","title":"Loading Recipes"},{"location":"utilities/recipes/#the-recipe-file","text":"A basic recipe file might look like the following example: { \"type\": \"minecraft:crafting_shaped\", \"pattern\": [ \"xxa\", \"x x\", \"xxx\" ], \"key\": { \"x\": { \"type\": \"forge:ore_dict\", \"ore\": \"gemDiamond\" }, \"a\": { \"item\": \"mymod:myfirstitem\", \"data\": 1 } }, \"result\": { \"item\": \"mymod:myitem\", \"count\": 9, \"data\": 2 } } Note When you first obtain an ingredient to a vanilla recipe it will automatically unlock the recipe in the recipe book. To achieve the same effect, you have to use the Advancement system and create a new Advancement for each of your ingredients. The advancement has to exist. This doesn\u2019t mean it has to be visible in the advancement tree.","title":"The Recipe file"},{"location":"utilities/recipes/#type","text":"The type of a recipe with the type field. You can think of this as the definition of which crafting layout is to be used, for example minecraft:crafting_shaped or minecraft:crafting_shapeless . If you want, you can define your own types as well which requires the use of a _factories.json file.","title":"Type"},{"location":"utilities/recipes/#groups","text":"Optionally you can add a group to your recipes to be displayed within the recipe helper interface. All recipes with the same group String will be shown in the same group. For example, this can be used to have all door recipes shown in the recipe helper interface as a single entry, even though there are different types of doors.","title":"Groups"},{"location":"utilities/recipes/#types-of-crafting-recipes","text":"Within this section we will take a closer look on the differences between defining a shaped and a shapeless crafting recipe.","title":"Types of crafting recipes"},{"location":"utilities/recipes/#shaped-crafting","text":"Shaped recipes require the pattern and key keywords. A pattern defines the slot an item must appear in using placeholder characters. You can choose whatever character you want to be a placeholder for an item. Keys on the other hand define what items are to be used instead of the placeholders. A key is defined by a placeholder character and the item. Additional the type forge:ore_dict may be added. This defines the item beeing part of the OreDictionary and can for example be used when it doesn\u2019t matter which copper ore is used to produce a copper ingot. In this case the ore tag has to be used instead of the item tag to define the item. There are many more of these types which can be used here and you can even register your own. The data tag is a optional and used to define the metadata of a block or item. Important Any item which uses setHasSubtypes(true) requires the use of the data field. When it is not used within the ingredients or keys, it will mean any metadata of this item will be accepted, for example: Not defining the data of a sword means even a half broken sword will be accepted for the crafting recipe!","title":"Shaped crafting"},{"location":"utilities/recipes/#shapeless-crafting","text":"A shapeless recipe doesn\u2019t make use of the pattern and key keywords. To define a shapeless recipe, you have to use the ingredients list. It defines which items have to be used for the crafting process and can also make use of the additional type forge:ore_dict and it\u2019s functionality as described above. There are many more of these types which can be used here and you can even register your own. It is even possible to define multiple instances of the same item which means multiple of these items have to be in place for the crafting recipe to take place. Note While there is no limit on how many ingredients your recipe requires the vanilla crafting table does only allow 9 items to be placed for each crafting recipe. The following example shows how an ingredient list looks like within JSON. \"ingredients\": [ { \"type\": \"forge:ore_dict\", \"ore\": \"gemDiamond\" }, { \"item\": \"minecraft:nether_star\" } ],","title":"Shapeless crafting"},{"location":"utilities/recipes/#smelting","text":"To define a recipe for the furnace, you have to use GameRegistry.addSmelting(input, output, exp); as the smelting recipes are currently not JSON based.","title":"Smelting"},{"location":"utilities/recipes/#recipe-elements","text":"","title":"Recipe Elements"},{"location":"utilities/recipes/#patterns","text":"A pattern will be defined with the pattern list. Each string represents one row in the crafting grid and each placeholder character within the String represents a column. As seen in the example above a space means that no item needs to be inserted at that position.","title":"Patterns"},{"location":"utilities/recipes/#keys","text":"A key set is used in combination with patterns and contains keys whose name is the same as the placeholder character in the pattern list which it represents. One key may be defined to represent multiply items as it is the case for the wooden button. This means that the player can use one of the defined items for the crafting recipe, for example different types of wood. \"key\": { \"#\": [ { \"item\": \"minecraft:planks\", \"data\": 0 }, { \"item\": \"minecraft:planks\", \"data\": 1 } ] }","title":"Keys"},{"location":"utilities/recipes/#results","text":"Every recipe has to have a result tag to define the output item. When crafting something, you can get out more than one item. This is achieved by defining the count number. If this is left out, meaning it doesn\u2019t exist within the result block, it defaults to 1. Negative values are not allowed here as an Itemstack cannot be smaller than 0. There is no option to use the count number anywhere else than for the result. The data field is a optional and used to define the metadata of a block or item. It defaults to 0 when it doesn\u2019t exist. Note Any item which uses setHasSubtypes(true) requires the data field. In this case, it is not optional!","title":"Results"},{"location":"utilities/recipes/#factories","text":"Factories can be used to allow defining recipes and ingredients of a custom type (class). To create your own factory, create a _factories.json . Within this file a type has to be defined, for example: recipes , ingredients or conditions . These types represent IRecipeFactory , IIngredientFactory , and IConditionFactory , respectively. The entry \u201ckey\u201d must be a name which can be later used in your recipes, and the \u201cvalue\u201d is the fully qualified class name is a class you have to create which implements one of the above recipes. The class must have an empty constructor. For example: { \"<type>\": { \"<name>\": \"<fully qualified classname for the specified type>\" } } Note There is no need to create a new _factories.json for each type you want to specify, they can all be defined in a single file.","title":"Factories"},{"location":"utilities/recipes/#conditional-recipes","text":"Conditional recipes can be created by making use of the factory system described above. For this you use the conditions type with the IConditionFactory from above and can later add the conditions type to your recipes: { \"conditions\": [ { \"type\": \"<modid>:<name>\" } ] } These conditions only apply to the recipe as a whole and not to ingredients. As an example, you might want to check if a mod is loaded using the already existing condition forge:mod_loaded , and \"modid\": \"<mod to check>\" . Note Conditions will only be checked once at startup!","title":"Conditional Recipes"},{"location":"utilities/recipes/#constants","text":"It is possible to define constant values for your recipes. These values have to be defined within a _constants.json and can be used within any recipe of your mod by just writing #<name> . For filled buckets, you should use fluid instead of data . For example, this constant defines #SADDLE which represents the vanilla saddle item. [ { \"name\": \"SADDLE\", \"ingredient\": { \"item\": \"minecraft:saddle\", \"data\": 0 } } ]","title":"Constants"},{"location":"utilities/tags/","text":"Tags Tags are generalized sets of objects in the game, used for grouping related things together and providing fast membership checks. Declaring Your Own Groupings Tags are declared in your mod\u2019s datapack. For example, /data/modid/tags/blocks/foo/tagname.json will declare a Tag<Block> with ID modid:foo/tagname . Similarly, you may append to or override tags declared in other domains, such as Vanilla, by declaring your own JSONs. For example, to add your own mod\u2019s saplings to the Vanilla sapling tag, you would specify it in /data/minecraft/tags/blocks/saplings.json , and Vanilla will merge everything into one tag at reload, if the replace option is false. If replace is true, then all entries before the json specifying replace will be removed. See the Vanilla wiki for a description of the base syntax. Forge provides two extensions on the Vanilla syntax: * You may declare an optional array of the same format as the values array, but any values listed here that are not present will not cause the tag loading to error. This is useful to provide integration for mods that may or may not be present at runtime. * You may declare a remove array of the same format as the values array. Any values listed here will be removed from the tag. This acts as a finer grained version of the Vanilla replace option. Using Tags In Code Block, Item, and Fluid tags are automatically sent from the server to any remote clients on login and reload. Function tags are not synced. BlockTags.getCollection() and ItemTags.getCollection() will retrieve the current TagCollection , from which you can retrieve a Tag object by its ID. With a Tag object in hand, membership can be tested with tag.contains(thing) , or all the objects in the tag queried with tag.getAllElements() . As an example: ResourceLocation myTagId = new ResourceLocation(\"mymod\", \"myitemgroup\"); Item unknownItem = stack.getItem(); boolean isInGroup = ItemTags.getCollection().getOrCreateTag(myTagId).contains(unknownItem); // alternatively, can use getTag and perform a null check !!! note: The TagCollection returned by getCollection() (and the Tag s within it) may expire if a reload happens, so you should always query the collection anew every time you need it. The static Tag fields in BlockTags and ItemTags avoid this by introducing a wrapper that handles this expiring. Alternatively, a resource reload listener can be used to refresh any cached tags. Conventions There are several conventions that will help facilitate compatibility in the ecosystem: * If there is a Vanilla tag that fits your block or item, add it to that tag. See the list of Vanilla tags . * If there is a Forge tag that fits your block or item, add it to that tag. The list of tags declared by Forge can be seen on GitHub. * If there is a group of something you feel should be shared by the community, consider PR-ing it to Forge instead of making your own tag * Tag naming conventions should follow Vanilla conventions. In particular, item and block groupings are plural instead of singular. E.g. minecraft:logs , minecraft:saplings . * Item tags should be sorted into subdirectories according to the type of item, e.g. forge:ingots/iron , forge:nuggets/brass , etc. Migration from OreDictionary For recipes, tags can be used directly in the vanilla recipe format (see below) For matching items in code, see the section above. If you are declaring a new type of item grouping, follow a couple naming conventions: Use domain:type/material . When the name is a common one that all modders should adopt, use the forge domain. For example, brass ingots should be registered under the forge:ingots/brass tag, and cobalt nuggets under the forge:nuggets/cobalt tag. Using Tags in Recipes and Advancements Tags are directly supported by Vanilla, see the respective Vanilla wiki pages for recipes and advancements for usage details.","title":"Tags"},{"location":"utilities/tags/#tags","text":"Tags are generalized sets of objects in the game, used for grouping related things together and providing fast membership checks.","title":"Tags"},{"location":"utilities/tags/#declaring-your-own-groupings","text":"Tags are declared in your mod\u2019s datapack. For example, /data/modid/tags/blocks/foo/tagname.json will declare a Tag<Block> with ID modid:foo/tagname . Similarly, you may append to or override tags declared in other domains, such as Vanilla, by declaring your own JSONs. For example, to add your own mod\u2019s saplings to the Vanilla sapling tag, you would specify it in /data/minecraft/tags/blocks/saplings.json , and Vanilla will merge everything into one tag at reload, if the replace option is false. If replace is true, then all entries before the json specifying replace will be removed. See the Vanilla wiki for a description of the base syntax. Forge provides two extensions on the Vanilla syntax: * You may declare an optional array of the same format as the values array, but any values listed here that are not present will not cause the tag loading to error. This is useful to provide integration for mods that may or may not be present at runtime. * You may declare a remove array of the same format as the values array. Any values listed here will be removed from the tag. This acts as a finer grained version of the Vanilla replace option.","title":"Declaring Your Own Groupings"},{"location":"utilities/tags/#using-tags-in-code","text":"Block, Item, and Fluid tags are automatically sent from the server to any remote clients on login and reload. Function tags are not synced. BlockTags.getCollection() and ItemTags.getCollection() will retrieve the current TagCollection , from which you can retrieve a Tag object by its ID. With a Tag object in hand, membership can be tested with tag.contains(thing) , or all the objects in the tag queried with tag.getAllElements() . As an example: ResourceLocation myTagId = new ResourceLocation(\"mymod\", \"myitemgroup\"); Item unknownItem = stack.getItem(); boolean isInGroup = ItemTags.getCollection().getOrCreateTag(myTagId).contains(unknownItem); // alternatively, can use getTag and perform a null check !!! note: The TagCollection returned by getCollection() (and the Tag s within it) may expire if a reload happens, so you should always query the collection anew every time you need it. The static Tag fields in BlockTags and ItemTags avoid this by introducing a wrapper that handles this expiring. Alternatively, a resource reload listener can be used to refresh any cached tags.","title":"Using Tags In Code"},{"location":"utilities/tags/#conventions","text":"There are several conventions that will help facilitate compatibility in the ecosystem: * If there is a Vanilla tag that fits your block or item, add it to that tag. See the list of Vanilla tags . * If there is a Forge tag that fits your block or item, add it to that tag. The list of tags declared by Forge can be seen on GitHub. * If there is a group of something you feel should be shared by the community, consider PR-ing it to Forge instead of making your own tag * Tag naming conventions should follow Vanilla conventions. In particular, item and block groupings are plural instead of singular. E.g. minecraft:logs , minecraft:saplings . * Item tags should be sorted into subdirectories according to the type of item, e.g. forge:ingots/iron , forge:nuggets/brass , etc.","title":"Conventions"},{"location":"utilities/tags/#migration-from-oredictionary","text":"For recipes, tags can be used directly in the vanilla recipe format (see below) For matching items in code, see the section above. If you are declaring a new type of item grouping, follow a couple naming conventions: Use domain:type/material . When the name is a common one that all modders should adopt, use the forge domain. For example, brass ingots should be registered under the forge:ingots/brass tag, and cobalt nuggets under the forge:nuggets/cobalt tag.","title":"Migration from OreDictionary"},{"location":"utilities/tags/#using-tags-in-recipes-and-advancements","text":"Tags are directly supported by Vanilla, see the respective Vanilla wiki pages for recipes and advancements for usage details.","title":"Using Tags in Recipes and Advancements"}]}