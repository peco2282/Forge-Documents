{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MinecraftForge Documentation This is the official documentation for MinecraftForge , the Minecraft modding API. This documentation is only for Forge, this is not a Java tutorial . Contribute to the docs at GitHub .","title":"Home"},{"location":"#minecraftforge-documentation","text":"This is the official documentation for MinecraftForge , the Minecraft modding API. This documentation is only for Forge, this is not a Java tutorial . Contribute to the docs at GitHub .","title":"MinecraftForge Documentation"},{"location":"styleguide/","text":"Style Guide Guide For Contributing to This Documentation This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to build a mod using Forge. Please don\u2019t try to turn this documentation into a tutorial on Java Development - it is intended for people who understand how a Java class works, and other fundamental structures of Java. Formatting Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path.","title":"Style Guide"},{"location":"styleguide/#style-guide","text":"","title":"Style Guide"},{"location":"styleguide/#guide-for-contributing-to-this-documentation","text":"This documentation is meant to be explanatory. Please explain how to do things, and break it down into reasonable chunks. We have a wiki elsewhere that can capture more comprehensive code examples. Our audience is anyone who wants to understand how to build a mod using Forge. Please don\u2019t try to turn this documentation into a tutorial on Java Development - it is intended for people who understand how a Java class works, and other fundamental structures of Java.","title":"Guide For Contributing to This Documentation"},{"location":"styleguide/#formatting","text":"Important Please use two spaces to indent, not tabs. Titles should be capitalized in the standard titling format. For example, Guide For Contributing to This Documentation Building and Testing Your Mod Essentially, capitalize everything but unimportant words. Spelling, grammar, and syntax should follow those of American English. Also, prefer using separate words over contractions (e.g. \u201care not\u201d instead of \u201caren\u2019t\u201d). Please use equals and dash underlines, instead of # and ## . For h3 and lower, ### etc. is fine. The source of this file contains an example for equals and dash underlining. Equals underlines create h1 text, and dash underlines create h2 text. When referencing fields and methods outside of code block snippets, they should use a # separator (e.g. ClassName#methodName ). Inner classes should use a $ separator (e.g. ClassName$InnerClassName ). All links should have their location specified at the bottom of the page. Any internal links should reference the page via their relative path.","title":"Formatting"},{"location":"advanced/accesstransformers/","text":"Access Transformers Access Transformers (ATs for short) allow for widening the visibility and modifying the final flags of classes, methods, and fields. They allow modders to access and modify otherwise inaccessible members in classes outside their control. The specification document can be viewed on the Minecraft Forge GitHub. Adding ATs Adding an Access Transformer to your mod project is as simple as adding a single line into your build.gradle : // This block is where your mappings version is also specified minecraft { accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') } After adding or modifying the Access Transformer, the gradle project must be refreshed for the transformations to take effect. During development, the AT file can be anywhere specified by the line above. However, when loading in a non-development environment, Forge will only search for the exact path of META-INF/accesstransformer.cfg in your JAR file. Comments All text after a # until the end of the line will be treated as a comment and will not be parsed. Access Modifiers Access modifiers specify to what new member visibility the given target will be transformed to. In decreasing order of visibility: public - visible to all classes inside and outside its package protected - visible only to classes inside the package and subclasses default - visible only to classes inside the package private - visible only to inside the class A special modifier +f and -f can be appended to the aforementioned modifiers to either add or remove respectively the final modifier, which prevents subclassing, method overriding, or field modification when applied. Warning Directives only modify the method they directly reference; any overriding methods will not be access-transformed. It is advised to ensure transformed methods do not have non-transformed overrides that restrict the visibility, which will result in the JVM throwing an error. Examples of methods that can be safely transformed are private methods, final methods (or methods in final classes), and static methods. Targets and Directives Information When using Access Transformers on Minecraft classes, the SRG name must be used for fields and methods. Classes To target classes: <access modifier> <fully qualified class name> Inner classes are denoted by combining the fully qualified name of the outer class and the name of the inner class with a $ as separator. Fields To target fields: <access modifier> <fully qualified class name> <field name> Methods Targeting methods require a special syntax to denote the method parameters and return type: <access modifier> <fully qualified class name> <method name>(<parameter types>)<return type> Specifying Types Also called \u201cdescriptors\u201d: see the Java Virtual Machine Specification, SE 8, sections 4.3.2 and 4.3.3 for more technical details. B - byte , a signed byte C - char , a Unicode character code point in UTF-16 D - double , a double-precision floating-point value F - float , a single-precision floating-point value I - integer , a 32-bit integer J - long , a 64-bit integer S - short , a signed short Z - boolean , a true or false value [ - references one dimension of an array Example: [[S refers to short[][] L<class name>; - references a reference type Example: Ljava/lang/String; refers to java.lang.String reference type (note the use of slashes instead of periods) ( - references a method descriptor, parameters should be supplied here or nothing if no parameters are present Example: <method>(I)Z refers to a method that requires an integer argument and returns a boolean V - indicates a method returns no value, can only be used at the end of a method descriptor Example: <method>()V refers to a method that has no arguments and returns nothing Examples # Makes public the ScreenConstructor class in MenuScreens public net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor # Makes protected and removes the final modifier from 'random' in MinecraftServer protected-f net.minecraft.server.MinecraftServer f_129758_ #random # Makes public the 'makeExecutor' method in Util, # accepting a String and returns an ExecutorService public net.minecraft.Util m_137477_(Ljava/lang/String;)Ljava/util/concurrent/ExecutorService; #makeExecutor # Makes public the 'leastMostToIntArray' method in SerializableUUID, # accepting two longs and returning an int[] public net.minecraft.core.SerializableUUID m_123274_(JJ)[I #leastMostToIntArray","title":"Access Transformers"},{"location":"advanced/accesstransformers/#access-transformers","text":"Access Transformers (ATs for short) allow for widening the visibility and modifying the final flags of classes, methods, and fields. They allow modders to access and modify otherwise inaccessible members in classes outside their control. The specification document can be viewed on the Minecraft Forge GitHub.","title":"Access Transformers"},{"location":"advanced/accesstransformers/#adding-ats","text":"Adding an Access Transformer to your mod project is as simple as adding a single line into your build.gradle : // This block is where your mappings version is also specified minecraft { accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg') } After adding or modifying the Access Transformer, the gradle project must be refreshed for the transformations to take effect. During development, the AT file can be anywhere specified by the line above. However, when loading in a non-development environment, Forge will only search for the exact path of META-INF/accesstransformer.cfg in your JAR file.","title":"Adding ATs"},{"location":"advanced/accesstransformers/#comments","text":"All text after a # until the end of the line will be treated as a comment and will not be parsed.","title":"Comments"},{"location":"advanced/accesstransformers/#access-modifiers","text":"Access modifiers specify to what new member visibility the given target will be transformed to. In decreasing order of visibility: public - visible to all classes inside and outside its package protected - visible only to classes inside the package and subclasses default - visible only to classes inside the package private - visible only to inside the class A special modifier +f and -f can be appended to the aforementioned modifiers to either add or remove respectively the final modifier, which prevents subclassing, method overriding, or field modification when applied. Warning Directives only modify the method they directly reference; any overriding methods will not be access-transformed. It is advised to ensure transformed methods do not have non-transformed overrides that restrict the visibility, which will result in the JVM throwing an error. Examples of methods that can be safely transformed are private methods, final methods (or methods in final classes), and static methods.","title":"Access Modifiers"},{"location":"advanced/accesstransformers/#targets-and-directives","text":"Information When using Access Transformers on Minecraft classes, the SRG name must be used for fields and methods.","title":"Targets and Directives"},{"location":"advanced/accesstransformers/#classes","text":"To target classes: <access modifier> <fully qualified class name> Inner classes are denoted by combining the fully qualified name of the outer class and the name of the inner class with a $ as separator.","title":"Classes"},{"location":"advanced/accesstransformers/#fields","text":"To target fields: <access modifier> <fully qualified class name> <field name>","title":"Fields"},{"location":"advanced/accesstransformers/#methods","text":"Targeting methods require a special syntax to denote the method parameters and return type: <access modifier> <fully qualified class name> <method name>(<parameter types>)<return type>","title":"Methods"},{"location":"advanced/accesstransformers/#specifying-types","text":"Also called \u201cdescriptors\u201d: see the Java Virtual Machine Specification, SE 8, sections 4.3.2 and 4.3.3 for more technical details. B - byte , a signed byte C - char , a Unicode character code point in UTF-16 D - double , a double-precision floating-point value F - float , a single-precision floating-point value I - integer , a 32-bit integer J - long , a 64-bit integer S - short , a signed short Z - boolean , a true or false value [ - references one dimension of an array Example: [[S refers to short[][] L<class name>; - references a reference type Example: Ljava/lang/String; refers to java.lang.String reference type (note the use of slashes instead of periods) ( - references a method descriptor, parameters should be supplied here or nothing if no parameters are present Example: <method>(I)Z refers to a method that requires an integer argument and returns a boolean V - indicates a method returns no value, can only be used at the end of a method descriptor Example: <method>()V refers to a method that has no arguments and returns nothing","title":"Specifying Types"},{"location":"advanced/accesstransformers/#examples","text":"# Makes public the ScreenConstructor class in MenuScreens public net.minecraft.client.gui.screens.MenuScreens$ScreenConstructor # Makes protected and removes the final modifier from 'random' in MinecraftServer protected-f net.minecraft.server.MinecraftServer f_129758_ #random # Makes public the 'makeExecutor' method in Util, # accepting a String and returns an ExecutorService public net.minecraft.Util m_137477_(Ljava/lang/String;)Ljava/util/concurrent/ExecutorService; #makeExecutor # Makes public the 'leastMostToIntArray' method in SerializableUUID, # accepting two longs and returning an int[] public net.minecraft.core.SerializableUUID m_123274_(JJ)[I #leastMostToIntArray","title":"Examples"},{"location":"animation/armature/","text":"Armature Files Armature Files define joints and clips for animating a model. File Structure An example armature file, taken from the forge debug mod { \"joints\": { \"stick\": {\"2\": [1.0]}, \"cube\": {\"3\": [1.0]} }, \"clips\": { \"default\": { \"loop\": true, \"joint_clips\": { \"stick\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] } ], \"cube\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] }, { \"variable\": \"axis_z\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 1 ] }, { \"variable\": \"origin_x\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.15625 ] }, { \"variable\": \"origin_y\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.40625 ] }, { \"variable\": \"angle\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 120, 240, 0, 120, 240] } ] }, \"events\": {} } } } The file is organized in two sections, joints and clips. Joints Each joint defines an object that animates together as a single unit in the animation. With Vanilla JSON models, this means that multiple elements can belong to the same joint. The format is like this: { \"joints\": { <joint>, ... } } --- <joint> ::= { <string>: { // joint name <joint_definition>, ... } } <joint_definition> ::= { \"<index_model>\": [ <float> ] // index_model, joint_weight (only one value expected in array) } joint_name is the name of the joint index_model is a 0-indexed number (where 0 is the first element defined in the model) denoting a model element this joint controls. Must be a string (see example) joint_weight is a weight (0-1) of how much this joint will contribute to the element\u2019s final transformation if the element is used in multiple joints. Note For simpler animations, the weight can usually just be set to 1.0, but if you want multiple joints in a clip to animate differently, this is one way to accomplish that. Not all elements need to have a joint, only the ones you are animating. If an element occurs in multiple joint, the final transform is a weighted average of the transforms for each joint. Clips Clips are essentially instructions on how to use a value to animate some collection of joints. They also include events to fire at certain points. They are formatted like this: { \"clips\": { \"clip_name\": { \"loop\": <true/false>, \"joint_clips\": { <joint_clip_list>, ... }, \"events\": { <event> ... } } } } ------- <joint_clip_list> ::= { \"joint_name\": [ <joint_clip>, ... ] } <joint_clip> ::= { \"variable\": <variable>, \"type\": \"uniform\", \"interpolation\": <interpolation>, \"samples\": [ float, ... ] } loop: if true, the animation will wrap around when the parameter value goes above 1, if not it\u2019ll just clamp at the final state. Joint Clips Each joint_clip is a set of variables to change for a joint. The type attribute is currently ignored, but must be \"uniform\" . samples defines what value the animation will take on (think of keyframes in traditional animation), and its interpretation depends on the value of interpolation . interpolation , which is how to convert the list of samples into a (possibly) continuous animation can be one of the following: nearest - if value < 0.5 use the first sample, else the second sample. Useful for static variables if only given one value. linear - linearly interpolate between samples. Time between samples is 1 / number of samples. variable can be one of the following: offset_x , offset_y , offset_z - translation scale - uniform scaling scale_x , scale_y , scale_x - scaling on certain axes axis_x , axis_y , axis_z - rotation axes angle - rotation angle origin_x , origin_y , origin_z - rotation origin Events Each clip can fire events, formatted like this: <event> :: { <event_time>: \"event_text\" } For more information about events and what event_text means, see the page on ASMs . event_time is a value (usually between 0 and 1 inclusive) denoting when to fire the event. When the parameter controlling this clip reaches a point equal to or greater than the event_time , the event is fired.","title":"Armature"},{"location":"animation/armature/#armature-files","text":"Armature Files define joints and clips for animating a model.","title":"Armature Files"},{"location":"animation/armature/#file-structure","text":"An example armature file, taken from the forge debug mod { \"joints\": { \"stick\": {\"2\": [1.0]}, \"cube\": {\"3\": [1.0]} }, \"clips\": { \"default\": { \"loop\": true, \"joint_clips\": { \"stick\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] } ], \"cube\": [ { \"variable\": \"offset_x\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 0.6875, 0] }, { \"variable\": \"axis_z\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 1 ] }, { \"variable\": \"origin_x\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.15625 ] }, { \"variable\": \"origin_y\", \"type\": \"uniform\", \"interpolation\": \"nearest\", \"samples\": [ 0.40625 ] }, { \"variable\": \"angle\", \"type\": \"uniform\", \"interpolation\": \"linear\", \"samples\": [0, 120, 240, 0, 120, 240] } ] }, \"events\": {} } } } The file is organized in two sections, joints and clips.","title":"File Structure"},{"location":"animation/armature/#joints","text":"Each joint defines an object that animates together as a single unit in the animation. With Vanilla JSON models, this means that multiple elements can belong to the same joint. The format is like this: { \"joints\": { <joint>, ... } } --- <joint> ::= { <string>: { // joint name <joint_definition>, ... } } <joint_definition> ::= { \"<index_model>\": [ <float> ] // index_model, joint_weight (only one value expected in array) } joint_name is the name of the joint index_model is a 0-indexed number (where 0 is the first element defined in the model) denoting a model element this joint controls. Must be a string (see example) joint_weight is a weight (0-1) of how much this joint will contribute to the element\u2019s final transformation if the element is used in multiple joints. Note For simpler animations, the weight can usually just be set to 1.0, but if you want multiple joints in a clip to animate differently, this is one way to accomplish that. Not all elements need to have a joint, only the ones you are animating. If an element occurs in multiple joint, the final transform is a weighted average of the transforms for each joint.","title":"Joints"},{"location":"animation/armature/#clips","text":"Clips are essentially instructions on how to use a value to animate some collection of joints. They also include events to fire at certain points. They are formatted like this: { \"clips\": { \"clip_name\": { \"loop\": <true/false>, \"joint_clips\": { <joint_clip_list>, ... }, \"events\": { <event> ... } } } } ------- <joint_clip_list> ::= { \"joint_name\": [ <joint_clip>, ... ] } <joint_clip> ::= { \"variable\": <variable>, \"type\": \"uniform\", \"interpolation\": <interpolation>, \"samples\": [ float, ... ] } loop: if true, the animation will wrap around when the parameter value goes above 1, if not it\u2019ll just clamp at the final state.","title":"Clips"},{"location":"animation/armature/#joint-clips","text":"Each joint_clip is a set of variables to change for a joint. The type attribute is currently ignored, but must be \"uniform\" . samples defines what value the animation will take on (think of keyframes in traditional animation), and its interpretation depends on the value of interpolation . interpolation , which is how to convert the list of samples into a (possibly) continuous animation can be one of the following: nearest - if value < 0.5 use the first sample, else the second sample. Useful for static variables if only given one value. linear - linearly interpolate between samples. Time between samples is 1 / number of samples. variable can be one of the following: offset_x , offset_y , offset_z - translation scale - uniform scaling scale_x , scale_y , scale_x - scaling on certain axes axis_x , axis_y , axis_z - rotation axes angle - rotation angle origin_x , origin_y , origin_z - rotation origin","title":"Joint Clips"},{"location":"animation/armature/#events","text":"Each clip can fire events, formatted like this: <event> :: { <event_time>: \"event_text\" } For more information about events and what event_text means, see the page on ASMs . event_time is a value (usually between 0 and 1 inclusive) denoting when to fire the event. When the parameter controlling this clip reaches a point equal to or greater than the event_time , the event is fired.","title":"Events"},{"location":"animation/asm/","text":"Animation State Machine Files Animation State Machine (ASM) Files are the meat of the animation API. These define how the animation is carried out and how to use the clips defined in the armature file. Concepts The ASM contains parameters , clips , states , and transitions . States The Animation State Machine can be in many different states . You define which states there are in the states section. Transitions Transistions define which states are allowed to go to other states, for example allowing a closed state to go to an open state. Note Transitions do not define animations that are played between states, however. If you want to do that you must create an additional state that plays an animation then uses an event to go to the next state. Parameters Note Parameters are called TimeValues in the code, hence the naming convention of SomethingValue. All parameters take an input, usually the current game time in seconds as a float (factoring in partial ticks) and outputs another time. This output is then used as the input to a clip, telling it the current progress of the animation. Each parameter can either be defined in the ASM or when you load the ASM in the code. Load-time parameters are usually of the type VariableValue , which returns a value changeable in-code, ignoring its input. Other types allow you to do math on the input ( SimpleExprValue ), return a constant ( ConstValue ), refer to other parameters ( ParameterValue ), return the input unmodified ( IdentityValue ) and perform composition of two parameters ( CompositionValue ). Clips Note Clips can either be ASM-clips, ones that are defined in the ASM, or armature-clips, ones that are defined in the armature file. For the rest of this page, \u201cclips\u201d will refer to ASM-clips unless otherwise stated. A clip takes in an input, usually the time, and does something to the model with it. Different types of clips do different things, the simplest being animating an armature-clip ( ModelClip ). You can also override the input to another ASM-clip ( TimeClip ), trigger an event while animating another clip if the input is positive ( TriggerClip ), smoothly blend between two clips ( SlerpClip ), refer to another clip in the ASM ( ClipReference ) or do nothing ( IdentityClip ). Events Various things can trigger events in the ASM. Events in the ASM are represented using only text. Some events are special, with text that is formatted like this: !event_type:event_value . Right now there is only one kind of event_type , namely transition . This tries to transition to whatever state is defined in the event_value . Anything else is a normal event and can be used from the pastEvents callback, but more information about that is on the implementing page. Code API Warning The ASM code API can only be used client side . When storing ASMs in code, use the side-agnostic IAnimationStateMachine interface. ASMs can be loaded by calling ModelLoaderRegistry.loadASM . It takes two parameters, the first being a ResourceLocation denoting where the ASM is stored, and second an ImmutableMap of load-time defined parameters. An example: @Nullable private final IAnimationStateMachine asm; private final VariableValue cycle = new VariableValue(4); public Spin() { asm = proxy.loadASM(new ResourceLocation(MODID, \"asms/block/rotatest.json\"), ImmutableMap.of(\"cycle_length\", cycle)); } Here, an ASM is loaded (from a sided proxy to avoid crashing on server) with one extra parameter, named cycle_length . This parameter is of the type VariableValue , so we can set it from within our code. Using an ASM instance, you can get the current state with .currentState() and transition to another state with .transition(nextState) VariableValue parameters can have their value set by calling .setValue , but you can not read this value back. There is no need to inform the ASM of this change, it happens automatically. File Format The ASMs are stored in json files. The location does not matter, but they are usually placed in an asms folder. First, a simple example: { \"parameters\": { \"anim_cycle\": [\"/\", \"#cycle_length\"] }, \"clips\": { \"default\": [\"apply\", \"forgedebugmodelanimation:block/rotatest@default\", \"#anim_cycle\" ] }, \"states\": [ \"default\" ], \"transitions\": {}, \"start_state\": \"default\" } As stated above, the files have parameters, clips, states and transitions, as well as the starting state of the ASM. All of these tags are required, even if they are empty. Parameters { \"name\": <parameter_definition> } Different types of parameters have different formats for <parameter_definition> , and the simple ones are: IdentityValue : the string #identity , ParameterValue : the parameter to reference, prefixed with # , e.g. #my_awesome_parameter ConstValue : a number to use as the constant to return Mathematical expression ( SimpleExprValue ) Format: [ regex(\"[+\\\\-*/mMrRfF]+\"), <parameter_definition>, ... ] Examples: [ \"+\", 4 ] [ \"/+\", 5, 1] [ \"++\", 2, \"#other\" ] [ \"++\", \"#other\", [ \"compose\", \"#cycle\", 3] ] Explanation The SimpleExprValue takes its input and applies operations to it. The first parameter is the sequence of operations to apply, and the rest represent the operands to those operations. The input to each operation is either the input to this entire parameter (for the first operation) or the result of the previous operation. Operations (case-sensitive): Operator Meaning + output = input + arg - output = input - arg * output = input * arg / output = input / arg m output = min(input, arg) M output = max(input, arg) r output = floor(input / arg) * arg R output = ceil(input / arg) * arg f output = input - floor(input / arg) * arg F output = ceil(input / arg) * arg - input Example explanations: input + 4 (input / 5) + 1 input + 2 + value of parameter other input + value of parameter other + value of parameter cycle given input 3 Function composition ( CompositionValue ) Format: [ \"compose\", <parameter_definition>, <parameter_definition> ] Examples: [ \"compose\", \"#cycle\", 3] [ \"compose\", \"#test\", \"#other\"] [ \"compose\", [ \"+\", 3], \"#other\"] [ \"compose\", [ \"compose\", \"#other2\", \"#other3\"], \"#other\"] Explanation CompositionValue takes two parameter definitions as inputs, and does value1(value2(input)) . In other words, it chains the two inputs, calling the second one with the given input, and the first one with the output of the second one. Example explanations: value of parameter cycle when given input 3 value of parameter test when given the output of parameter other when called with the current input 3 + the output of other with the current input other2(other3(other(input))) because value1 = other2(other3(input)) and value2 = other(input) Clips { \"name\": <clip_definition> } As with parameters, different kinds of clips have different formats for <clip_definition> , but the simple ones are: IdentityClip : the string #identity ClipReference : the clip name prefixed with # , e.g. #my_amazing_clip ModelClip : a model resource location + @ + the name of the armature-clip, e.g. mymod:block/test@default or mymod:block/test#facing=east@moving Overriding input ( TimeClip ) Format: [ \"apply\", <clip_definition>, <parameter_definition> ] Examples: [\"apply\", \"mymod:block/animated_thing@moving\", \"#cycle_time\"] [\"apply\", [ \"apply\", \"mymod:block/animated_thing@moving\", [ \"+\", 3 ] ], \"#cycle\"] Explanation The TimeClip takes another clip and applies it using a custom parameter instead of the current time. Usually used to apply a ModelClip with a parameter instead of the current time. Example explanations: apply the armature-clip for model mymod:block/animated_thing named moving with the output of the parameter cycle_time apply the armature-clip for model mymod:block/animated_thing named moving with 3 + the output of the parameter cycle Triggering an event ( TriggerClip ) Format: [ \"trigger_positive\", <clip_definition>, <parameter_definition>, \"<event_text>\"] Examples [ \"trigger_positive\", \"#default\", \"#end_cycle\", \"!transition:moving\" ] [ \"trigger_positive\", \"mymod:block/animated_thing@moving\", \"#end_cycle\", \"boop\" ] Explanation The TriggerClip visually acts as a TimeClip , but also fires the event in event_text when the parameter_description goes positive. At the same time, it applies the clip in clip_definition with the same parameter_description . Example explanations apply the clip with name default given the input of parameter end_cycle , and when end_cycle is positive transition to the moving state apply the armature-clip mymod:block/animated_thing@moving with parameter end_cycle , and when end_cycle is positive fire event \"boop\" Blend between two clips ( SlerpClip ) Format: [ \"slerp\", <clip_definition>, <clip_definition>, <parameter_definition>, <parameter_definition> ] Examples [ \"slerp\", \"#closed\", \"#open\", \"#identity\", \"#progress\" ] [ \"slerp\", [ \"apply\", \"#move\", \"#mover\"], \"#end\", \"#identity\", \"#progress\" ] Explanation The SlerpClip performs a spherical linear blend between two separate clips. In other words, it will morph one clip into another smoothly. The two clip_definition s are the clips to blend from and to respectively. The first parameter_definition is the \u201cinput\u201d. Both the from and to clips are passed the output of this parameter with the current animation time. The second parameter_definition is the \u201cprogress\u201d, a value between 0 and 1 to denote how far into the blend we are. Combining this clip with trigger_positive and transition special events can allow for simple transitions between two solid states. Example explanations blend the closed clip to the open clip, giving both clips the unaltered time as input and blend progress #progress . blend the result of the move clip when given the input parameter mover to the end clip with the unaltered time as the input with blend progress #progress . States The states section of the file is simply a list of all possible states. For example \"states\": [ \"open\", \"closed\", \"opening\", \"closing\", \"dancing\" ] defines 5 states: open, closed, opening, closing and dancing. Transitions The transitions section defines which states can go to what other states. A state can go to 0, 1, or many other states. To define a state as going to no other states, omit it from the section. To define a state as going to only one other state, create a key with the value of the state it can go to, for example \"open\": \"opening\" . To define a state as going to many other states, do the same as if it were going to only one other state but make the value a list of all possible receiving states instead, for example: \"open\": [\"closed\", \"opening\"] . A more full example: \"transitions\": { \"open\": \"closing\", \"closed\": [ \"dancing\", \"opening\" ], \"closing\": \"closed\", \"opening\": \"open\", \"dancing\": \"closed\" } This example means that: the open state can go to the closing state the closed state can go to either the dancing or opening state the closing state can go to the closed state the opening state can go to the open state the dancing state can go to the closed state","title":"Asm"},{"location":"animation/asm/#animation-state-machine-files","text":"Animation State Machine (ASM) Files are the meat of the animation API. These define how the animation is carried out and how to use the clips defined in the armature file.","title":"Animation State Machine Files"},{"location":"animation/asm/#concepts","text":"The ASM contains parameters , clips , states , and transitions .","title":"Concepts"},{"location":"animation/asm/#states","text":"The Animation State Machine can be in many different states . You define which states there are in the states section.","title":"States"},{"location":"animation/asm/#transitions","text":"Transistions define which states are allowed to go to other states, for example allowing a closed state to go to an open state. Note Transitions do not define animations that are played between states, however. If you want to do that you must create an additional state that plays an animation then uses an event to go to the next state.","title":"Transitions"},{"location":"animation/asm/#parameters","text":"Note Parameters are called TimeValues in the code, hence the naming convention of SomethingValue. All parameters take an input, usually the current game time in seconds as a float (factoring in partial ticks) and outputs another time. This output is then used as the input to a clip, telling it the current progress of the animation. Each parameter can either be defined in the ASM or when you load the ASM in the code. Load-time parameters are usually of the type VariableValue , which returns a value changeable in-code, ignoring its input. Other types allow you to do math on the input ( SimpleExprValue ), return a constant ( ConstValue ), refer to other parameters ( ParameterValue ), return the input unmodified ( IdentityValue ) and perform composition of two parameters ( CompositionValue ).","title":"Parameters"},{"location":"animation/asm/#clips","text":"Note Clips can either be ASM-clips, ones that are defined in the ASM, or armature-clips, ones that are defined in the armature file. For the rest of this page, \u201cclips\u201d will refer to ASM-clips unless otherwise stated. A clip takes in an input, usually the time, and does something to the model with it. Different types of clips do different things, the simplest being animating an armature-clip ( ModelClip ). You can also override the input to another ASM-clip ( TimeClip ), trigger an event while animating another clip if the input is positive ( TriggerClip ), smoothly blend between two clips ( SlerpClip ), refer to another clip in the ASM ( ClipReference ) or do nothing ( IdentityClip ).","title":"Clips"},{"location":"animation/asm/#events","text":"Various things can trigger events in the ASM. Events in the ASM are represented using only text. Some events are special, with text that is formatted like this: !event_type:event_value . Right now there is only one kind of event_type , namely transition . This tries to transition to whatever state is defined in the event_value . Anything else is a normal event and can be used from the pastEvents callback, but more information about that is on the implementing page.","title":"Events"},{"location":"animation/asm/#code-api","text":"Warning The ASM code API can only be used client side . When storing ASMs in code, use the side-agnostic IAnimationStateMachine interface. ASMs can be loaded by calling ModelLoaderRegistry.loadASM . It takes two parameters, the first being a ResourceLocation denoting where the ASM is stored, and second an ImmutableMap of load-time defined parameters. An example: @Nullable private final IAnimationStateMachine asm; private final VariableValue cycle = new VariableValue(4); public Spin() { asm = proxy.loadASM(new ResourceLocation(MODID, \"asms/block/rotatest.json\"), ImmutableMap.of(\"cycle_length\", cycle)); } Here, an ASM is loaded (from a sided proxy to avoid crashing on server) with one extra parameter, named cycle_length . This parameter is of the type VariableValue , so we can set it from within our code. Using an ASM instance, you can get the current state with .currentState() and transition to another state with .transition(nextState) VariableValue parameters can have their value set by calling .setValue , but you can not read this value back. There is no need to inform the ASM of this change, it happens automatically.","title":"Code API"},{"location":"animation/asm/#file-format","text":"The ASMs are stored in json files. The location does not matter, but they are usually placed in an asms folder. First, a simple example: { \"parameters\": { \"anim_cycle\": [\"/\", \"#cycle_length\"] }, \"clips\": { \"default\": [\"apply\", \"forgedebugmodelanimation:block/rotatest@default\", \"#anim_cycle\" ] }, \"states\": [ \"default\" ], \"transitions\": {}, \"start_state\": \"default\" } As stated above, the files have parameters, clips, states and transitions, as well as the starting state of the ASM. All of these tags are required, even if they are empty.","title":"File Format"},{"location":"animation/asm/#parameters_1","text":"{ \"name\": <parameter_definition> } Different types of parameters have different formats for <parameter_definition> , and the simple ones are: IdentityValue : the string #identity , ParameterValue : the parameter to reference, prefixed with # , e.g. #my_awesome_parameter ConstValue : a number to use as the constant to return","title":"Parameters"},{"location":"animation/asm/#mathematical-expression-simpleexprvalue","text":"Format: [ regex(\"[+\\\\-*/mMrRfF]+\"), <parameter_definition>, ... ]","title":"Mathematical expression (SimpleExprValue)"},{"location":"animation/asm/#examples","text":"[ \"+\", 4 ] [ \"/+\", 5, 1] [ \"++\", 2, \"#other\" ] [ \"++\", \"#other\", [ \"compose\", \"#cycle\", 3] ]","title":"Examples:"},{"location":"animation/asm/#explanation","text":"The SimpleExprValue takes its input and applies operations to it. The first parameter is the sequence of operations to apply, and the rest represent the operands to those operations. The input to each operation is either the input to this entire parameter (for the first operation) or the result of the previous operation.","title":"Explanation"},{"location":"animation/asm/#operations-case-sensitive","text":"Operator Meaning + output = input + arg - output = input - arg * output = input * arg / output = input / arg m output = min(input, arg) M output = max(input, arg) r output = floor(input / arg) * arg R output = ceil(input / arg) * arg f output = input - floor(input / arg) * arg F output = ceil(input / arg) * arg - input","title":"Operations (case-sensitive):"},{"location":"animation/asm/#example-explanations","text":"input + 4 (input / 5) + 1 input + 2 + value of parameter other input + value of parameter other + value of parameter cycle given input 3","title":"Example explanations:"},{"location":"animation/asm/#function-composition-compositionvalue","text":"Format: [ \"compose\", <parameter_definition>, <parameter_definition> ]","title":"Function composition (CompositionValue)"},{"location":"animation/asm/#examples_1","text":"[ \"compose\", \"#cycle\", 3] [ \"compose\", \"#test\", \"#other\"] [ \"compose\", [ \"+\", 3], \"#other\"] [ \"compose\", [ \"compose\", \"#other2\", \"#other3\"], \"#other\"]","title":"Examples:"},{"location":"animation/asm/#explanation_1","text":"CompositionValue takes two parameter definitions as inputs, and does value1(value2(input)) . In other words, it chains the two inputs, calling the second one with the given input, and the first one with the output of the second one.","title":"Explanation"},{"location":"animation/asm/#example-explanations_1","text":"value of parameter cycle when given input 3 value of parameter test when given the output of parameter other when called with the current input 3 + the output of other with the current input other2(other3(other(input))) because value1 = other2(other3(input)) and value2 = other(input)","title":"Example explanations:"},{"location":"animation/asm/#clips_1","text":"{ \"name\": <clip_definition> } As with parameters, different kinds of clips have different formats for <clip_definition> , but the simple ones are: IdentityClip : the string #identity ClipReference : the clip name prefixed with # , e.g. #my_amazing_clip ModelClip : a model resource location + @ + the name of the armature-clip, e.g. mymod:block/test@default or mymod:block/test#facing=east@moving","title":"Clips"},{"location":"animation/asm/#overriding-input-timeclip","text":"Format: [ \"apply\", <clip_definition>, <parameter_definition> ]","title":"Overriding input (TimeClip)"},{"location":"animation/asm/#examples_2","text":"[\"apply\", \"mymod:block/animated_thing@moving\", \"#cycle_time\"] [\"apply\", [ \"apply\", \"mymod:block/animated_thing@moving\", [ \"+\", 3 ] ], \"#cycle\"]","title":"Examples:"},{"location":"animation/asm/#explanation_2","text":"The TimeClip takes another clip and applies it using a custom parameter instead of the current time. Usually used to apply a ModelClip with a parameter instead of the current time.","title":"Explanation"},{"location":"animation/asm/#example-explanations_2","text":"apply the armature-clip for model mymod:block/animated_thing named moving with the output of the parameter cycle_time apply the armature-clip for model mymod:block/animated_thing named moving with 3 + the output of the parameter cycle","title":"Example explanations:"},{"location":"animation/asm/#triggering-an-event-triggerclip","text":"Format: [ \"trigger_positive\", <clip_definition>, <parameter_definition>, \"<event_text>\"]","title":"Triggering an event (TriggerClip)"},{"location":"animation/asm/#examples_3","text":"[ \"trigger_positive\", \"#default\", \"#end_cycle\", \"!transition:moving\" ] [ \"trigger_positive\", \"mymod:block/animated_thing@moving\", \"#end_cycle\", \"boop\" ]","title":"Examples"},{"location":"animation/asm/#explanation_3","text":"The TriggerClip visually acts as a TimeClip , but also fires the event in event_text when the parameter_description goes positive. At the same time, it applies the clip in clip_definition with the same parameter_description .","title":"Explanation"},{"location":"animation/asm/#example-explanations_3","text":"apply the clip with name default given the input of parameter end_cycle , and when end_cycle is positive transition to the moving state apply the armature-clip mymod:block/animated_thing@moving with parameter end_cycle , and when end_cycle is positive fire event \"boop\"","title":"Example explanations"},{"location":"animation/asm/#blend-between-two-clips-slerpclip","text":"Format: [ \"slerp\", <clip_definition>, <clip_definition>, <parameter_definition>, <parameter_definition> ]","title":"Blend between two clips (SlerpClip)"},{"location":"animation/asm/#examples_4","text":"[ \"slerp\", \"#closed\", \"#open\", \"#identity\", \"#progress\" ] [ \"slerp\", [ \"apply\", \"#move\", \"#mover\"], \"#end\", \"#identity\", \"#progress\" ]","title":"Examples"},{"location":"animation/asm/#explanation_4","text":"The SlerpClip performs a spherical linear blend between two separate clips. In other words, it will morph one clip into another smoothly. The two clip_definition s are the clips to blend from and to respectively. The first parameter_definition is the \u201cinput\u201d. Both the from and to clips are passed the output of this parameter with the current animation time. The second parameter_definition is the \u201cprogress\u201d, a value between 0 and 1 to denote how far into the blend we are. Combining this clip with trigger_positive and transition special events can allow for simple transitions between two solid states.","title":"Explanation"},{"location":"animation/asm/#example-explanations_4","text":"blend the closed clip to the open clip, giving both clips the unaltered time as input and blend progress #progress . blend the result of the move clip when given the input parameter mover to the end clip with the unaltered time as the input with blend progress #progress .","title":"Example explanations"},{"location":"animation/asm/#states_1","text":"The states section of the file is simply a list of all possible states. For example \"states\": [ \"open\", \"closed\", \"opening\", \"closing\", \"dancing\" ] defines 5 states: open, closed, opening, closing and dancing.","title":"States"},{"location":"animation/asm/#transitions_1","text":"The transitions section defines which states can go to what other states. A state can go to 0, 1, or many other states. To define a state as going to no other states, omit it from the section. To define a state as going to only one other state, create a key with the value of the state it can go to, for example \"open\": \"opening\" . To define a state as going to many other states, do the same as if it were going to only one other state but make the value a list of all possible receiving states instead, for example: \"open\": [\"closed\", \"opening\"] . A more full example: \"transitions\": { \"open\": \"closing\", \"closed\": [ \"dancing\", \"opening\" ], \"closing\": \"closed\", \"opening\": \"open\", \"dancing\": \"closed\" } This example means that: the open state can go to the closing state the closed state can go to either the dancing or opening state the closing state can go to the closed state the opening state can go to the open state the dancing state can go to the closed state","title":"Transitions"},{"location":"animation/implementing/","text":"Using the API Depending on what you want to animate with the API, code-side implementation is a bit different. Documentation on the ASM API itself (for controlling the animation) is found on the ASM page because it is independent of what you are animating. Blocks Animations for blocks are done with the TileEntityRendererAnimation , which is a TileEntityRenderer . Because of this, having a TileEntity for your block is necessary. Your TileEntity must provide the ANIMATION_CAPABILITY , which is received by calling its .cast method with your ASM. Your block must also render in the ENTITYBLOCK_ANIMATED render layer if you do not provide a StaticProperty in the block\u2019s blockstate. The StaticProperty is a property you can add to your block\u2019s blockstate by adding Properties.StaticProperty to the list of your block\u2019s properties inside of fillStateContainer() . When rendering the block, the TileEntityRendererAnimation checks if the property\u2019s value is true; if so, block rendering continues as normal. Otherwise the TileEntityRendererAnimation animates the block model assigned to the static=false variant in the blockstate json. All parts of the model that can be static should probably be rendered in the static state, as that is its purpose. The handleEvents() callback is located in the TileEntityRendererAnimation , so you have to either subclass or overload it inline when you register the tileentity. Here\u2019s an example of registering the TESR: ClientRegistry.bindTileEntitySpecialRenderer(Chest.class, new TileEntityRendererAnimation<Chest>() { @Override public void handleEvents(Chest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }); In this example, we\u2019ve overridden the handleEvents() callback when we registered the TER because the implementation is simple, but you could easily subclass TileEntityRendererAnimation to achieve the same effect. The handleEvents() callback for blocks takes two arguments: the tile entity being rendered, and an iterable of the events. The call to chest.handleEvents() calls a method located in the fictional Chest TileEntity, as the ASM is not accessible inside of the handleEvents() method. Items Animations for items are done entirely using the capability system. Your item must provide the ANIMATION_CAPABILITY through an ICapabilityProvider . You can create an instance of this capability using its .cast method with your ASM, which is usually stored on the ICapabilityProvider object itself. An example of this is below: private static class ItemAnimationHolder implements ICapabilityProvider { private final VariableValue cycleLength = new VariableValue(4); private final IAnimationStateMachine asm = proxy.load(new ResourceLocation(MODID.toLowerCase(), \"asms/block/engine.json\"), ImmutableMap.<String, ITimeValue>of( \"cycle_length\", cycleLength )); @Override public boolean hasCapability(@Nonnull Capability<?> capability, @Nullable EnumFacing facing) { return capability == CapabilityAnimation.ANIMATION_CAPABILITY; } @Override @Nullable public <T> T getCapability(@Nonnull Capability<T> capability, @Nullable EnumFacing facing) { if(capability == CapabilityAnimation.ANIMATION_CAPABILITY) { return CapabilityAnimation.ANIMATION_CAPABILITY.cast(asm); } return null; } } There is no way to receive events on an item in the current implementation. Entities In order to animate an entity with the animation API, your entity\u2019s renderer must take an AnimationModelBase as its model. This model\u2019s constructor takes two parameters, the location of the actual model to animate (as in the path to the JSON or B3D file, not a blockstate reference) and a VertexLighter . The VertexLighter object can be created with new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors()) . The entity must also provide the ANIMATION_CAPABILITY , which can be created with its .cast method by passing the ASM. The handleEvents() callback is located inside the AnimationModelBase class, if you want to use the events you must subclass AnimationModelBase . The callback takes three parameters: the entity being rendered, the current time in partial ticks, and an iterable of the events that have occurred. An example of creating the renderer is shown below: ResourceLocation location = new ModelResourceLocation(new ResourceLocation(MODID, blockName), \"entity\"); return new RenderLiving<EntityChest>(manager, new net.minecraftforge.client.model.animation.AnimationModelBase<EntityChest>(location, new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors())) { @Override public void handleEvents(EntityChest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }, 0.5f) { // ... getEntityTexture() ... };","title":"Implementing"},{"location":"animation/implementing/#using-the-api","text":"Depending on what you want to animate with the API, code-side implementation is a bit different. Documentation on the ASM API itself (for controlling the animation) is found on the ASM page because it is independent of what you are animating.","title":"Using the API"},{"location":"animation/implementing/#blocks","text":"Animations for blocks are done with the TileEntityRendererAnimation , which is a TileEntityRenderer . Because of this, having a TileEntity for your block is necessary. Your TileEntity must provide the ANIMATION_CAPABILITY , which is received by calling its .cast method with your ASM. Your block must also render in the ENTITYBLOCK_ANIMATED render layer if you do not provide a StaticProperty in the block\u2019s blockstate. The StaticProperty is a property you can add to your block\u2019s blockstate by adding Properties.StaticProperty to the list of your block\u2019s properties inside of fillStateContainer() . When rendering the block, the TileEntityRendererAnimation checks if the property\u2019s value is true; if so, block rendering continues as normal. Otherwise the TileEntityRendererAnimation animates the block model assigned to the static=false variant in the blockstate json. All parts of the model that can be static should probably be rendered in the static state, as that is its purpose. The handleEvents() callback is located in the TileEntityRendererAnimation , so you have to either subclass or overload it inline when you register the tileentity. Here\u2019s an example of registering the TESR: ClientRegistry.bindTileEntitySpecialRenderer(Chest.class, new TileEntityRendererAnimation<Chest>() { @Override public void handleEvents(Chest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }); In this example, we\u2019ve overridden the handleEvents() callback when we registered the TER because the implementation is simple, but you could easily subclass TileEntityRendererAnimation to achieve the same effect. The handleEvents() callback for blocks takes two arguments: the tile entity being rendered, and an iterable of the events. The call to chest.handleEvents() calls a method located in the fictional Chest TileEntity, as the ASM is not accessible inside of the handleEvents() method.","title":"Blocks"},{"location":"animation/implementing/#items","text":"Animations for items are done entirely using the capability system. Your item must provide the ANIMATION_CAPABILITY through an ICapabilityProvider . You can create an instance of this capability using its .cast method with your ASM, which is usually stored on the ICapabilityProvider object itself. An example of this is below: private static class ItemAnimationHolder implements ICapabilityProvider { private final VariableValue cycleLength = new VariableValue(4); private final IAnimationStateMachine asm = proxy.load(new ResourceLocation(MODID.toLowerCase(), \"asms/block/engine.json\"), ImmutableMap.<String, ITimeValue>of( \"cycle_length\", cycleLength )); @Override public boolean hasCapability(@Nonnull Capability<?> capability, @Nullable EnumFacing facing) { return capability == CapabilityAnimation.ANIMATION_CAPABILITY; } @Override @Nullable public <T> T getCapability(@Nonnull Capability<T> capability, @Nullable EnumFacing facing) { if(capability == CapabilityAnimation.ANIMATION_CAPABILITY) { return CapabilityAnimation.ANIMATION_CAPABILITY.cast(asm); } return null; } } There is no way to receive events on an item in the current implementation.","title":"Items"},{"location":"animation/implementing/#entities","text":"In order to animate an entity with the animation API, your entity\u2019s renderer must take an AnimationModelBase as its model. This model\u2019s constructor takes two parameters, the location of the actual model to animate (as in the path to the JSON or B3D file, not a blockstate reference) and a VertexLighter . The VertexLighter object can be created with new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors()) . The entity must also provide the ANIMATION_CAPABILITY , which can be created with its .cast method by passing the ASM. The handleEvents() callback is located inside the AnimationModelBase class, if you want to use the events you must subclass AnimationModelBase . The callback takes three parameters: the entity being rendered, the current time in partial ticks, and an iterable of the events that have occurred. An example of creating the renderer is shown below: ResourceLocation location = new ModelResourceLocation(new ResourceLocation(MODID, blockName), \"entity\"); return new RenderLiving<EntityChest>(manager, new net.minecraftforge.client.model.animation.AnimationModelBase<EntityChest>(location, new VertexLighterSmoothAo(Minecraft.getMinecraft().getBlockColors())) { @Override public void handleEvents(EntityChest chest, float time, Iterable<Event> pastEvents) { chest.handleEvents(time, pastEvents); } }, 0.5f) { // ... getEntityTexture() ... };","title":"Entities"},{"location":"animation/intro/","text":"Intro to the Animation API The Forge Animation API lets you animate JSON (and B3D) models. Before you start reading this, you should know how vanilla JSON models are created, and should have read the documentation on blockstates. Note Although you can use B3D models with the Animation API, most of this documentation will assume you are using JSON files. (TODO) See the page on using B3D models for more information The Animation API is made up of two main components: armature files and animation state machine (ASM) files. Armature files define joints and clips for JSON files. Joints are names for cubes in the model file with weights (see the page on armatures for more info), while clips are a set of transformations to apply to joints over time (think of a clip from a movie for example). ASM files define the various states an animation can be in, as well as what transitions exist between those states. They also define the parameters for an animation (functions which return a floating point number), which are generally used as inputs to clips, but can also trigger events. Events are essentially a way to receive in-code notifications when the animation reaches a certain point or to trigger transitions. Filesystem Structure Conventions ASM Files are normally stored in the asms/block for blocks or asms/item for items and so on. You specify where to load them from, so their location is really up to you. Armature files must be stored in the armatures folder. They are looked up by taking the path to your model file, removing models/ and taking whats left and prepending armatures/ , so a model in models/block/test.json becomes armatures/block/test.json .","title":"Intro"},{"location":"animation/intro/#intro-to-the-animation-api","text":"The Forge Animation API lets you animate JSON (and B3D) models. Before you start reading this, you should know how vanilla JSON models are created, and should have read the documentation on blockstates. Note Although you can use B3D models with the Animation API, most of this documentation will assume you are using JSON files. (TODO) See the page on using B3D models for more information The Animation API is made up of two main components: armature files and animation state machine (ASM) files. Armature files define joints and clips for JSON files. Joints are names for cubes in the model file with weights (see the page on armatures for more info), while clips are a set of transformations to apply to joints over time (think of a clip from a movie for example). ASM files define the various states an animation can be in, as well as what transitions exist between those states. They also define the parameters for an animation (functions which return a floating point number), which are generally used as inputs to clips, but can also trigger events. Events are essentially a way to receive in-code notifications when the animation reaches a certain point or to trigger transitions.","title":"Intro to the Animation API"},{"location":"animation/intro/#filesystem-structure-conventions","text":"ASM Files are normally stored in the asms/block for blocks or asms/item for items and so on. You specify where to load them from, so their location is really up to you. Armature files must be stored in the armatures folder. They are looked up by taking the path to your model file, removing models/ and taking whats left and prepending armatures/ , so a model in models/block/test.json becomes armatures/block/test.json .","title":"Filesystem Structure Conventions"},{"location":"blockentities/ber/","text":"BlockEntityRenderer A BlockEntityRenderer or BER is used to render blocks in a way that cannot be represented with a static baked model (JSON, OBJ, B3D, others). A block entity renderer requires the block to have a BlockEntity . Creating a BER To create a BER, create a class that inherits from BlockEntityRenderer . It takes a generic argument specifying the block\u2019s BlockEntity class. The generic argument is used in the BER\u2019s render method. Only one BER exists for a given BlockEntityType . Therefore, values that are specific to a single instance in the level should be stored in the block entity being passed to the renderer rather than in the BER itself. For example, an integer that increments every frame, if stored in the BER, will increment every frame for every block entity of this type in the level. render This method is called every frame in order to render the block entity. Parameters blockEntity : This is the instance of the block entity being rendered. partialTicks : The amount of time, in fractions of a tick, that has passed since the last full tick. poseStack : A stack holding four-dimensional matrix entries offset to the current position of the block entity. bufferSource : A rendering buffer able to access a vertex consumer. combinedLight : An integer of the current light value on the block entity. combinedOverlay : An integer set to the current overlay of the block entity, usually OverlayTexture#NO_OVERLAY or 655,360. Registering a BER In order to register a BER, you must subscribe to the EntityRenderersEvent$RegisterRenderers event on the mod event bus and call #registerBlockEntityRenderer .","title":"Renderer"},{"location":"blockentities/ber/#blockentityrenderer","text":"A BlockEntityRenderer or BER is used to render blocks in a way that cannot be represented with a static baked model (JSON, OBJ, B3D, others). A block entity renderer requires the block to have a BlockEntity .","title":"BlockEntityRenderer"},{"location":"blockentities/ber/#creating-a-ber","text":"To create a BER, create a class that inherits from BlockEntityRenderer . It takes a generic argument specifying the block\u2019s BlockEntity class. The generic argument is used in the BER\u2019s render method. Only one BER exists for a given BlockEntityType . Therefore, values that are specific to a single instance in the level should be stored in the block entity being passed to the renderer rather than in the BER itself. For example, an integer that increments every frame, if stored in the BER, will increment every frame for every block entity of this type in the level.","title":"Creating a BER"},{"location":"blockentities/ber/#render","text":"This method is called every frame in order to render the block entity.","title":"render"},{"location":"blockentities/ber/#parameters","text":"blockEntity : This is the instance of the block entity being rendered. partialTicks : The amount of time, in fractions of a tick, that has passed since the last full tick. poseStack : A stack holding four-dimensional matrix entries offset to the current position of the block entity. bufferSource : A rendering buffer able to access a vertex consumer. combinedLight : An integer of the current light value on the block entity. combinedOverlay : An integer set to the current overlay of the block entity, usually OverlayTexture#NO_OVERLAY or 655,360.","title":"Parameters"},{"location":"blockentities/ber/#registering-a-ber","text":"In order to register a BER, you must subscribe to the EntityRenderersEvent$RegisterRenderers event on the mod event bus and call #registerBlockEntityRenderer .","title":"Registering a BER"},{"location":"blockentities/blockentity/","text":"BlockEntities BlockEntities are like simplified Entities that are bound to a Block. They are used to store dynamic data, execute tick based tasks, and dynamic rendering. Some examples from vanilla Minecraft would be handling of inventories on chests, smelting logic on furnaces, or area effects on beacons. More advanced examples exist in mods, such as quarries, sorting machines, pipes, and displays. Note BlockEntities aren\u2019t a solution for everything and they can cause lag when used wrongly. When possible, try to avoid them. Creating a BlockEntity In order to create a BlockEntity , you need to extend the BlockEntity class. To register it, listen for the appropriate registry event and create a BlockEntityType : @SubscribeEvent public static void registerTE(RegistryEvent.Register<BlockEntityType<?>> evt) { BlockEntityType<?> type = BlockEntityType.Builder.of(supplier, validBlocks).build(null); type.setRegistryName(\"mymod\", \"mybe\"); evt.getRegistry().register(type); } In this example, supplier is a BlockEntityType$BlockEntitySupplier that creates a new instance of your BlockEntity. A method reference or a lambda is commonly used. The variable validBlocks is one or more blocks ( BlockEntityType$Builder#of is varargs) that the block entity can exist for. Attaching a BlockEntity to a Block To attach your new BlockEntity to a Block , the EntityBlock interface must be implemented on your Block subclass. The method EntityBlock#newBlockEntity(BlockPos, BlockState) must be implemented and return a new instance of your BlockEntity . Storing Data within your BlockEntity In order to save data, override the following two methods: BlockEntity#save(CompoundTag tag) BlockEntity#load(CompoundTag tag) These methods are called whenever the LevelChunk containing the BlockEntity gets loaded from/saved to a tag. Use them to read and write to the fields in your block entity class. Note Whenever your data changes, you need to call BlockEntity#setChanged ; otherwise, the LevelChunk containing your BlockEntity might be skipped while the level is saved. Important It is important that you call the super methods! The tag names id , x , y , z , ForgeData and ForgeCaps are reserved by the super methods. Ticking BlockEntities If you need a ticking BlockEntity , for example to keep track of the progress during a smelting process, another method must be implemented and overridden within EntityBlock : EntityBlock#getTicker(Level, BlockState, BlockEntityType) . This can implement different tickers depending on which logical side the user is on, or just implement one general ticker. In either case, a BlockEntityTicker must be returned. Since this is a functional interface, it can just take in a method representing the ticker instead: // Inside some Block subclass @Nullable @Override public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> type) { return type == MyBlockEntityTypes.MYBE.get() ? MyBlockEntity::tick : null; } // Inside MyBlockEntity public static void tick(Level level, BlockPos pos, BlockState state, T blockEntity) { // Do stuff } Note This method is called each tick; therefore, you should avoid having complicated calculations in here. If possible, you should make more complex calculations every X ticks. (The amount of ticks in a second may be lower then 20 (twenty) but won\u2019t be higher) Synchronizing the Data to the Client There are three ways of syncing data to the client: synchronizing on chunk load, on block updates, and with a custom network message. Synchronizing on LevelChunk Load For this you need to override BlockEntity#getUpdateTag() IForgeBlockEntity#handleUpdateTag(CompoundTag tag) Again, this is pretty simple, the first method collects the data that should be sent to the client, while the second one processes that data. If your BlockEntity doesn\u2019t contain much data, you might be able to use the methods out of the Storing Data within your BlockEntity section. Important Synchronizing excessive/useless data for block entities can lead to network congestion. You should optimize your network usage by sending only the information the client needs when the client needs it. For instance, it is more often than not unnecessary to send the inventory of a block entity in the update tag, as this can be synchronized via its AbstractContainerMenu . Synchronizing on Block Update This method is a bit more complicated, but again you just need to override two methods. Here is a tiny example implementation of it: @Override public ClientboundBlockEntityDataPacket getUpdatePacket(){ CompoundTag tag = new CompoundTag(); //Write your data into the tag return new ClientboundBlockEntityDataPacket(getBlockPos(), -1, tag); } @Override public void onDataPacket(Connection connection, ClientboundBlockEntityDataPacket pkt){ CompoundTag tag = pkt.getTag(); //Handle your Data } The Constructor of ClientboundBlockEntityDataPacket takes: The position of your BlockEntity . An id, though it isn\u2019t really used besides by Vanilla; therefore, you can just put a -1 in there. A CompoundTag which should contain your data. Now, to send the packet, an update notification must be given on the server. Level#sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) The pos should be your BlockEntity \u2018s position. For oldState and newState , you can pass the current BlockState at that position. flags is a bitmask that should contain 2 , which will sync the changes to the client. See Constants$BlockFlags for more info as well as the rest of the flags. The flag 2 is equivalent to Constants$BlockFlags#BLOCK_UPDATE . Synchronizing Using a Custom Network Message This way of synchronizing is probably the most complicated but is usually the most optimized, as you can make sure that only the data you need to be synchronized is actually synchronized. You should first check out the Networking section and especially SimpleImpl before attempting this. Once you\u2019ve created your custom network message, you can send it to all users that have the BlockEntity loaded with SimpleChannel#send(PacketDistributor$PacketTarget, MSG) . Warning It is important that you do safety checks, the BlockEntity might already be destroyed/replaced when the message arrives at the player! You should also check if the chunk is loaded ( Level#hasChunkAt(BlockPos) ).","title":"Home"},{"location":"blockentities/blockentity/#blockentities","text":"BlockEntities are like simplified Entities that are bound to a Block. They are used to store dynamic data, execute tick based tasks, and dynamic rendering. Some examples from vanilla Minecraft would be handling of inventories on chests, smelting logic on furnaces, or area effects on beacons. More advanced examples exist in mods, such as quarries, sorting machines, pipes, and displays. Note BlockEntities aren\u2019t a solution for everything and they can cause lag when used wrongly. When possible, try to avoid them.","title":"BlockEntities"},{"location":"blockentities/blockentity/#creating-a-blockentity","text":"In order to create a BlockEntity , you need to extend the BlockEntity class. To register it, listen for the appropriate registry event and create a BlockEntityType : @SubscribeEvent public static void registerTE(RegistryEvent.Register<BlockEntityType<?>> evt) { BlockEntityType<?> type = BlockEntityType.Builder.of(supplier, validBlocks).build(null); type.setRegistryName(\"mymod\", \"mybe\"); evt.getRegistry().register(type); } In this example, supplier is a BlockEntityType$BlockEntitySupplier that creates a new instance of your BlockEntity. A method reference or a lambda is commonly used. The variable validBlocks is one or more blocks ( BlockEntityType$Builder#of is varargs) that the block entity can exist for.","title":"Creating a BlockEntity"},{"location":"blockentities/blockentity/#attaching-a-blockentity-to-a-block","text":"To attach your new BlockEntity to a Block , the EntityBlock interface must be implemented on your Block subclass. The method EntityBlock#newBlockEntity(BlockPos, BlockState) must be implemented and return a new instance of your BlockEntity .","title":"Attaching a BlockEntity to a Block"},{"location":"blockentities/blockentity/#storing-data-within-your-blockentity","text":"In order to save data, override the following two methods: BlockEntity#save(CompoundTag tag) BlockEntity#load(CompoundTag tag) These methods are called whenever the LevelChunk containing the BlockEntity gets loaded from/saved to a tag. Use them to read and write to the fields in your block entity class. Note Whenever your data changes, you need to call BlockEntity#setChanged ; otherwise, the LevelChunk containing your BlockEntity might be skipped while the level is saved. Important It is important that you call the super methods! The tag names id , x , y , z , ForgeData and ForgeCaps are reserved by the super methods.","title":"Storing Data within your BlockEntity"},{"location":"blockentities/blockentity/#ticking-blockentities","text":"If you need a ticking BlockEntity , for example to keep track of the progress during a smelting process, another method must be implemented and overridden within EntityBlock : EntityBlock#getTicker(Level, BlockState, BlockEntityType) . This can implement different tickers depending on which logical side the user is on, or just implement one general ticker. In either case, a BlockEntityTicker must be returned. Since this is a functional interface, it can just take in a method representing the ticker instead: // Inside some Block subclass @Nullable @Override public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> type) { return type == MyBlockEntityTypes.MYBE.get() ? MyBlockEntity::tick : null; } // Inside MyBlockEntity public static void tick(Level level, BlockPos pos, BlockState state, T blockEntity) { // Do stuff } Note This method is called each tick; therefore, you should avoid having complicated calculations in here. If possible, you should make more complex calculations every X ticks. (The amount of ticks in a second may be lower then 20 (twenty) but won\u2019t be higher)","title":"Ticking BlockEntities"},{"location":"blockentities/blockentity/#synchronizing-the-data-to-the-client","text":"There are three ways of syncing data to the client: synchronizing on chunk load, on block updates, and with a custom network message.","title":"Synchronizing the Data to the Client"},{"location":"blockentities/blockentity/#synchronizing-on-levelchunk-load","text":"For this you need to override BlockEntity#getUpdateTag() IForgeBlockEntity#handleUpdateTag(CompoundTag tag) Again, this is pretty simple, the first method collects the data that should be sent to the client, while the second one processes that data. If your BlockEntity doesn\u2019t contain much data, you might be able to use the methods out of the Storing Data within your BlockEntity section. Important Synchronizing excessive/useless data for block entities can lead to network congestion. You should optimize your network usage by sending only the information the client needs when the client needs it. For instance, it is more often than not unnecessary to send the inventory of a block entity in the update tag, as this can be synchronized via its AbstractContainerMenu .","title":"Synchronizing on LevelChunk Load"},{"location":"blockentities/blockentity/#synchronizing-on-block-update","text":"This method is a bit more complicated, but again you just need to override two methods. Here is a tiny example implementation of it: @Override public ClientboundBlockEntityDataPacket getUpdatePacket(){ CompoundTag tag = new CompoundTag(); //Write your data into the tag return new ClientboundBlockEntityDataPacket(getBlockPos(), -1, tag); } @Override public void onDataPacket(Connection connection, ClientboundBlockEntityDataPacket pkt){ CompoundTag tag = pkt.getTag(); //Handle your Data } The Constructor of ClientboundBlockEntityDataPacket takes: The position of your BlockEntity . An id, though it isn\u2019t really used besides by Vanilla; therefore, you can just put a -1 in there. A CompoundTag which should contain your data. Now, to send the packet, an update notification must be given on the server. Level#sendBlockUpdated(BlockPos pos, BlockState oldState, BlockState newState, int flags) The pos should be your BlockEntity \u2018s position. For oldState and newState , you can pass the current BlockState at that position. flags is a bitmask that should contain 2 , which will sync the changes to the client. See Constants$BlockFlags for more info as well as the rest of the flags. The flag 2 is equivalent to Constants$BlockFlags#BLOCK_UPDATE .","title":"Synchronizing on Block Update"},{"location":"blockentities/blockentity/#synchronizing-using-a-custom-network-message","text":"This way of synchronizing is probably the most complicated but is usually the most optimized, as you can make sure that only the data you need to be synchronized is actually synchronized. You should first check out the Networking section and especially SimpleImpl before attempting this. Once you\u2019ve created your custom network message, you can send it to all users that have the BlockEntity loaded with SimpleChannel#send(PacketDistributor$PacketTarget, MSG) . Warning It is important that you do safety checks, the BlockEntity might already be destroyed/replaced when the message arrives at the player! You should also check if the chunk is loaded ( Level#hasChunkAt(BlockPos) ).","title":"Synchronizing Using a Custom Network Message"},{"location":"blocks/blocks/","text":"Blocks Blocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them. Creating a Block Basic Blocks For simple blocks, which need no special functionality (think cobblestone, wooden planks, etc.), a custom class is not necessary. You can create a block by instantiating the Block class with a BlockBehaviour$Properties object. This BlockBehaviour$Properties object can be made using BlockBehaviour$Properties#of , and it can be customized by calling its methods. For instance: strength - The hardness controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable a hardness of -1.0 should be used, see the definition of Blocks#BEDROCK as an example. The resistance controls the explosion resistance of the block. For reference, stone has a resistance of 6.0, and dirt 0.5. sound - Controls the sound the block makes when it is punched, broken, or placed. Requires a SoundType argument, see the sounds page for more details. lightLevel - Controls the light emission of the block. Takes a function with a BlockState parameter that returns a value from zero to fifteen. friction - Controls how slippery the block is. For reference, ice has a slipperiness of 0.98. All these methods are chainable which means you can call them in series. See the Blocks class for examples of this. Note Blocks have no setter for their CreativeModeTab . This has been moved to the BlockItem and is now its responsibility. Furthermore, there is no setter for translation key as it is now generated from the registry name. Advanced Blocks Of course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the Block class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks. Registering a Block Blocks must be registered to function. Important A block in the level and a \u201cblock\u201d in an inventory are very different things. A block in the level is represented by an BlockState , and its behavior defined by an instance of Block . Meanwhile, an item in an inventory is an ItemStack , controlled by an Item . As a bridge between the different worlds of Block and Item , there exists the class BlockItem . BlockItem is a subclass of Item that has a field block that holds a reference to the Block it represents. BlockItem defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a Block without an BlockItem . (E.g. minecraft:water exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.) When a block is registered, only a block is registered. The block does not automatically have an BlockItem . To create a basic BlockItem for a block, one should set the registry name of the BlockItem to that of its Block . Custom subclasses of BlockItem may be used as well. Once an BlockItem has been registered for a block, Block#asItem can be used to retrieve it. Block#asItem will return Items#AIR if there is no BlockItem for the Block , so if you are not certain that there is an BlockItem for the Block you are using, check for if Block#asItem returns Items#AIR . Optionally Registering Blocks In the past there have been several mods that have allowed users to disable blocks/items in a configuration file. However, you shouldn\u2019t do this. There is no limit on the amount of blocks that can be register, so register all blocks in your mod! If you want a block to be disabled through a configuration file, you should disable the crafting recipe. Further Reading For information about block properties, such as those used for vanilla blocks like fences, walls, and many more, see the section on blockstates .","title":"Home"},{"location":"blocks/blocks/#blocks","text":"Blocks are, obviously, essential to the Minecraft world. They make up all of the terrain, structures, and machines. Chances are if you are interested in making a mod, then you will want to add some blocks. This page will guide you through the creation of blocks, and some of the things you can do with them.","title":"Blocks"},{"location":"blocks/blocks/#creating-a-block","text":"","title":"Creating a Block"},{"location":"blocks/blocks/#basic-blocks","text":"For simple blocks, which need no special functionality (think cobblestone, wooden planks, etc.), a custom class is not necessary. You can create a block by instantiating the Block class with a BlockBehaviour$Properties object. This BlockBehaviour$Properties object can be made using BlockBehaviour$Properties#of , and it can be customized by calling its methods. For instance: strength - The hardness controls the time it takes to break the block. It is an arbitrary value. For reference, stone has a hardness of 1.5, and dirt 0.5. If the block should be unbreakable a hardness of -1.0 should be used, see the definition of Blocks#BEDROCK as an example. The resistance controls the explosion resistance of the block. For reference, stone has a resistance of 6.0, and dirt 0.5. sound - Controls the sound the block makes when it is punched, broken, or placed. Requires a SoundType argument, see the sounds page for more details. lightLevel - Controls the light emission of the block. Takes a function with a BlockState parameter that returns a value from zero to fifteen. friction - Controls how slippery the block is. For reference, ice has a slipperiness of 0.98. All these methods are chainable which means you can call them in series. See the Blocks class for examples of this. Note Blocks have no setter for their CreativeModeTab . This has been moved to the BlockItem and is now its responsibility. Furthermore, there is no setter for translation key as it is now generated from the registry name.","title":"Basic Blocks"},{"location":"blocks/blocks/#advanced-blocks","text":"Of course, the above only allows for extremely basic blocks. If you want to add functionality, like player interaction, a custom class is required. However, the Block class has many methods and unfortunately not every single one can be documented here. See the rest of the pages in this section for things you can do with blocks.","title":"Advanced Blocks"},{"location":"blocks/blocks/#registering-a-block","text":"Blocks must be registered to function. Important A block in the level and a \u201cblock\u201d in an inventory are very different things. A block in the level is represented by an BlockState , and its behavior defined by an instance of Block . Meanwhile, an item in an inventory is an ItemStack , controlled by an Item . As a bridge between the different worlds of Block and Item , there exists the class BlockItem . BlockItem is a subclass of Item that has a field block that holds a reference to the Block it represents. BlockItem defines some of the behavior of a \u201cblock\u201d as an item, like how a right click places the block. It\u2019s possible to have a Block without an BlockItem . (E.g. minecraft:water exists a block, but not an item. It is therefore impossible to hold it in an inventory as one.) When a block is registered, only a block is registered. The block does not automatically have an BlockItem . To create a basic BlockItem for a block, one should set the registry name of the BlockItem to that of its Block . Custom subclasses of BlockItem may be used as well. Once an BlockItem has been registered for a block, Block#asItem can be used to retrieve it. Block#asItem will return Items#AIR if there is no BlockItem for the Block , so if you are not certain that there is an BlockItem for the Block you are using, check for if Block#asItem returns Items#AIR .","title":"Registering a Block"},{"location":"blocks/blocks/#optionally-registering-blocks","text":"In the past there have been several mods that have allowed users to disable blocks/items in a configuration file. However, you shouldn\u2019t do this. There is no limit on the amount of blocks that can be register, so register all blocks in your mod! If you want a block to be disabled through a configuration file, you should disable the crafting recipe.","title":"Optionally Registering Blocks"},{"location":"blocks/blocks/#further-reading","text":"For information about block properties, such as those used for vanilla blocks like fences, walls, and many more, see the section on blockstates .","title":"Further Reading"},{"location":"blocks/interaction/","text":"Block Interaction There are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining. This page will cover the basics of the most common types of interaction with blocks. Player Right Click Since left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is the most common method of interaction. And thankfully, it is also one of the simplest to handle. use public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) This is the method that controls right click behavior. Parameters Type Name Description BlockState state The state of the block that was clicked Level level The level that the block was clicked in BlockPos pos The position of the block that was clicked Player player The player who did the clicking InteractionHand hand The hand with which the player clicked BlockHitResult hit Where on the block\u2019s bounds it was hit Return Value InteractionResult is the result right clicking, see example usages below. InteractionResult#SUCCESS means the right click action was successful. InteractionResult#CONSUME means that the right click action was consumed. InteractionResult#PASS is the default behavior, for when the block has no right click behavior, and allows something else to handle the right click. InteractionResult#FAIL means that the action failed. Enum Value Example Usage SUCCESS Eating a slice of cake. CONSUME Tuning a noteblock. PASS When right-clicking dirt. Or any other basic block. FAIL When attempting to place a minecart on a block other than rails. Important Returning InteractionResult#CONSUME from this method on the client will prevent it being called on the server. It is common practice to just check level#isClientSide and return InteractionResult#SUCCESS , and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest. Usage examples The uses for activation are literally endless. However, there are some common ones which deserve their own section. Screen s One of the most common things to do on block activation is opening a Screen . Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more. Activation Another common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers. Important use is called on both the client and the server, so be sure to keep the sidedness of your code in mind. Many things, like opening AbstractContainerMenu s and modifying the level, should only be done on the server-side. Block Placement setPlacedBy public void setPlacedBy(Level level, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack stack) Called by BlockItem s after a block is set in the level, to allow post-place logic. Parameters: Type Name Description Level level The level that the block was placed in BlockPos pos The position where the block was placed BlockState state The state of the block that was placed LivingEntity placer The entity who placed the block ItemStack stack The item block that was placed Player Break/Destroy attack public void attack(BlockState state, Level level, BlockPos pos, Player player) Called on a block when it is clicked by a player. Note This method is for when the player left-clicks on a block. Don\u2019t get this confused with use , which is called when the player right-clicks . Parameters: Type Name Description BlockState state The state of the block that was clicked Level level The level that the block was clicked in BlockPos pos The position of the block that was clicked Player player The player who did the clicking Usage example This method is perfect for adding custom events when a player clicks on a block. By default, this method does nothing. NoteBlock overrides this method so when left-clicked, it plays a sound. RedstoneOreBlock on left-click emits a faint light and spawns particles around itself. playerWillDestroy public void playerWillDestroy(Level level, BlockPos pos, BlockState state, Player player) Called before the Block is set to air in the level. Called regardless of if the player\u2019s tool can actually collect this block. Parameters: Type Name Description Level level The level that the block was destroyed BlockPos pos The position of the block that was destroyed BlockState state The state of the block that was destroyed Player player The player who harvested the block Usage example This method is perfect for adding custom events as a result of a player destroying a block This method has important behavior in the Block class so be sure to call the super method. super.playerWillDestroy(level, pos, state, player); The TNTBlock overrides this method to cause it\u2019s explosion when a player destroys it if its unstable property is true . This method is used by extended pistons; since an extended piston is made up of two blocks. (the extended head and the base) The PistonHeadBlock makes use of this method to destroy the base block when the PistonHeadBlock is destroyed. Entity Collision entityInside public void entityInside(BlockState state, Level level, BlockPos pos, Entity entity) This method is called whenever an entity collides with the block. Parameters: Type Name Description BlockState state The state of the block that was collided with Level level The level where the collided block is located BlockPos pos The position of the block that was collided with Entity entity The entity who collided with the block Usage examples An example use of this method is by the CampfireBlock which uses this method to light those on fire that collide with the campfire.","title":"Interaction"},{"location":"blocks/interaction/#block-interaction","text":"There are many different ways players (and other things) can interact with blocks, such as right clicking, left clicking, colliding, walking on, and of course mining. This page will cover the basics of the most common types of interaction with blocks.","title":"Block Interaction"},{"location":"blocks/interaction/#player-right-click","text":"Since left clicking, or \u201cpunching\u201d, a block does not generally result in any unique behavior, it is probably fair to say right clicking, or \u201cactivation\u201d, is the most common method of interaction. And thankfully, it is also one of the simplest to handle.","title":"Player Right Click"},{"location":"blocks/interaction/#use","text":"public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit) This is the method that controls right click behavior.","title":"use"},{"location":"blocks/interaction/#parameters","text":"Type Name Description BlockState state The state of the block that was clicked Level level The level that the block was clicked in BlockPos pos The position of the block that was clicked Player player The player who did the clicking InteractionHand hand The hand with which the player clicked BlockHitResult hit Where on the block\u2019s bounds it was hit","title":"Parameters"},{"location":"blocks/interaction/#return-value","text":"InteractionResult is the result right clicking, see example usages below. InteractionResult#SUCCESS means the right click action was successful. InteractionResult#CONSUME means that the right click action was consumed. InteractionResult#PASS is the default behavior, for when the block has no right click behavior, and allows something else to handle the right click. InteractionResult#FAIL means that the action failed. Enum Value Example Usage SUCCESS Eating a slice of cake. CONSUME Tuning a noteblock. PASS When right-clicking dirt. Or any other basic block. FAIL When attempting to place a minecart on a block other than rails. Important Returning InteractionResult#CONSUME from this method on the client will prevent it being called on the server. It is common practice to just check level#isClientSide and return InteractionResult#SUCCESS , and otherwise go on to normal activation logic. Vanilla has many examples of this, such as the chest.","title":"Return Value"},{"location":"blocks/interaction/#usage-examples","text":"The uses for activation are literally endless. However, there are some common ones which deserve their own section.","title":"Usage examples"},{"location":"blocks/interaction/#screens","text":"One of the most common things to do on block activation is opening a Screen . Many blocks in vanilla behave this way, such as chests, hoppers, furnaces, and many more.","title":"Screens"},{"location":"blocks/interaction/#activation","text":"Another common use for activation is, well, activation. This can be something like \u201cturning on\u201d a block, or triggering it to perform some action. For instance, a block could light up when activated. A vanilla example would be buttons or levers. Important use is called on both the client and the server, so be sure to keep the sidedness of your code in mind. Many things, like opening AbstractContainerMenu s and modifying the level, should only be done on the server-side.","title":"Activation"},{"location":"blocks/interaction/#block-placement","text":"","title":"Block Placement"},{"location":"blocks/interaction/#setplacedby","text":"public void setPlacedBy(Level level, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack stack) Called by BlockItem s after a block is set in the level, to allow post-place logic.","title":"setPlacedBy"},{"location":"blocks/interaction/#parameters_1","text":"Type Name Description Level level The level that the block was placed in BlockPos pos The position where the block was placed BlockState state The state of the block that was placed LivingEntity placer The entity who placed the block ItemStack stack The item block that was placed","title":"Parameters:"},{"location":"blocks/interaction/#player-breakdestroy","text":"","title":"Player Break/Destroy"},{"location":"blocks/interaction/#attack","text":"public void attack(BlockState state, Level level, BlockPos pos, Player player) Called on a block when it is clicked by a player. Note This method is for when the player left-clicks on a block. Don\u2019t get this confused with use , which is called when the player right-clicks .","title":"attack"},{"location":"blocks/interaction/#parameters_2","text":"Type Name Description BlockState state The state of the block that was clicked Level level The level that the block was clicked in BlockPos pos The position of the block that was clicked Player player The player who did the clicking","title":"Parameters:"},{"location":"blocks/interaction/#usage-example","text":"This method is perfect for adding custom events when a player clicks on a block. By default, this method does nothing. NoteBlock overrides this method so when left-clicked, it plays a sound. RedstoneOreBlock on left-click emits a faint light and spawns particles around itself.","title":"Usage example"},{"location":"blocks/interaction/#playerwilldestroy","text":"public void playerWillDestroy(Level level, BlockPos pos, BlockState state, Player player) Called before the Block is set to air in the level. Called regardless of if the player\u2019s tool can actually collect this block.","title":"playerWillDestroy"},{"location":"blocks/interaction/#parameters_3","text":"Type Name Description Level level The level that the block was destroyed BlockPos pos The position of the block that was destroyed BlockState state The state of the block that was destroyed Player player The player who harvested the block","title":"Parameters:"},{"location":"blocks/interaction/#usage-example_1","text":"This method is perfect for adding custom events as a result of a player destroying a block This method has important behavior in the Block class so be sure to call the super method. super.playerWillDestroy(level, pos, state, player); The TNTBlock overrides this method to cause it\u2019s explosion when a player destroys it if its unstable property is true . This method is used by extended pistons; since an extended piston is made up of two blocks. (the extended head and the base) The PistonHeadBlock makes use of this method to destroy the base block when the PistonHeadBlock is destroyed.","title":"Usage example"},{"location":"blocks/interaction/#entity-collision","text":"","title":"Entity Collision"},{"location":"blocks/interaction/#entityinside","text":"public void entityInside(BlockState state, Level level, BlockPos pos, Entity entity) This method is called whenever an entity collides with the block.","title":"entityInside"},{"location":"blocks/interaction/#parameters_4","text":"Type Name Description BlockState state The state of the block that was collided with Level level The level where the collided block is located BlockPos pos The position of the block that was collided with Entity entity The entity who collided with the block","title":"Parameters:"},{"location":"blocks/interaction/#usage-examples_1","text":"An example use of this method is by the CampfireBlock which uses this method to light those on fire that collide with the campfire.","title":"Usage examples"},{"location":"blocks/states/","text":"Block States Legacy Behavior In Minecraft 1.7 and previous versions, blocks which need to store placement or state data that did not have BlockEntities used metadata . Metadata was an extra number stored with the block, allowing different rotations, facings, or even completely separate behaviors within a block. However, the metadata system was confusing and limited, since it was stored as only a number alongside the block ID, and had no meaning except what was commented in the code. For example, to implement a block that can face a direction and be on either the upper or lower half of a block space (such as a stair): switch (meta) { case 0: { ... } // south and on the lower half of the block case 1: { ... } // south on the upper side of the block case 2: { ... } // north and on the lower half of the block case 3: { ... } // north and on the upper half of the block ... etc. ... } Because the numbers carry no meaning by themselves, no one could know what they represent unless they had access to the source code and comments. Introduction of States In Minecraft 1.8 and above, the metadata system, along with the block ID system, was deprecated and eventually replaced with the block state system . The block state system abstracts out the details of the block\u2019s properties from the other behaviors of the block. Each property of a block is described by an instance of Property<?> . Examples of block properties include instruments ( EnumProperty<NoteBlockInstrument> ), facing ( DirectionProperty ), poweredness ( Property<Boolean> ), etc. Each property has the value of the type T parametrized by Property<T> . A unique triple can be constructed from the Block , the set of Property<?> , and the set of values for those properties. This unique triple is called a BlockState . The previous system of meaningless metadata values were replaced by a system of block properties, which are easier to interpret and deal with. Previously, a stone button which is facing east and is powered or held down is represented by \u201c minecraft:stone_button with metadata 9 . Now, this is represented by \u201c minecraft:stone_button[facing=east,powered=true] \u201d. Proper Usage of Block States The BlockState system is a flexible and powerful system, but it also has limitations. BlockState s are immutable, and all combinations of their properties are generated on startup of the game. This means that having a BlockState with many properties and possible values will slow down the loading of the game, and befuddle anyone trying to make sense of your block logic. Not all blocks and situations require the usage of BlockState ; only the most basic properties of a block should be put into a BlockState , and any other situation is better off with having a BlockEntity or being a separate Block . Always consider if you actually need to use blockstates for your purposes. Note A good rule of thumb is: if it has a different name, it should be a separate block . An example is making chair blocks: the direction of the chair should be a property , while the different types of wood should be separated into different blocks. An \u201cOak Chair\u201d facing east ( oak_chair[facing=east] ) is different from a \u201cSpruce Chair\u201d facing west ( spruce_chair[facing=west] ). Implementing Block States In your Block class, create or reference static final Property<?> objects for every property that your Block has. You are free to make your own Property<?> implementations, but the means to do that are not covered in this article. The vanilla code provides several convenience implementations: IntegerProperty Implements Property<Integer> . Defines a property that holds an integer value. Created by calling IntegerProperty#create(String propertyName, int minimum, int maximum) . BooleanProperty Implements Property<Boolean> . Defines a property that holds a true or false value. Created by calling BooleanProperty#create(String propertyName) . EnumProperty<E extends Enum<E>> Implements Property<E> . Defines a property that can take on the values of an Enum class. Created by calling EnumProperty#create(String propertyName, Class<E> enumClass) . It is also possible to use only a subset of the Enum values (e.g. 4 out of 16 DyeColor s). See the overloads of EnumProperty#create . DirectionProperty This is a convenience implementation of EnumProperty<Direction> Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, call DirectionProperty.create(\"<name>\", Direction.Plane.HORIZONTAL) ; to get the X directions, DirectionProperty.create(\"<name>\", Direction.Axis.X) . The class BlockStateProperties contains shared vanilla properties which should be used or referenced whenever possible, in place of creating your own properties. When you have your desired Property<> objects, override Block#createBlockStateDefinition(StateDefinition$Builder) in your Block class. In that method, call StateDefinition$Builder#add(...); with the parameters as every Property<?> you wish the block to have. Every block will also have a \u201cdefault\u201d state that is automatically chosen for you. You can change this \u201cdefault\u201d state by calling the Block#registerDefaultState(BlockState) method from your constructor. When your block is placed it will become this \u201cdefault\u201d state. An example from DoorBlock : this.registerDefaultState( this.stateDefinition.any() .setValue(FACING, Direction.NORTH) .setValue(OPEN, false) .setValue(HINGE, DoorHingeSide.LEFT) .setValue(POWERED, false) .setValue(HALF, DoubleBlockHalf.LOWER) ); If you wish to change what BlockState is used when placing your block, you can overwrite Block#getStateForPlacement(BlockPlaceContext) . This can be used to, for example, set the direction of your block depending on where the player is standing when they place it. Because BlockState s are immutable, and all combinations of their properties are generated on startup of the game, calling BlockState#setValue(Property<T>, T) will simply go to the Block \u2018s StateHolder and request the BlockState with the set of values you want. Because all possible BlockState s are generated at startup, you are free and encouraged to use the reference equality operator ( == ) to check if two BlockState s are equal. Using BlockState \u2018s You can get the value of a property by calling BlockState#getValue(Property<?>) , passing it the property you want to get the value of. If you want to get a BlockState with a different set of values, simply call BlockState#setValue(Property<T>, T) with the property and its value. You can get and place BlockState \u2018s in the level using Level#setBlockAndUpdate(BlockPos, BlockState) and Level#getBlockState(BlockState) . If you are placing a Block , call Block#defaultBlockState() to get the \u201cdefault\u201d state, and use subsequent calls to BlockState#setValue(Property<T>, T) as stated above to achieve the desired state.","title":"BlockStates"},{"location":"blocks/states/#block-states","text":"","title":"Block States"},{"location":"blocks/states/#legacy-behavior","text":"In Minecraft 1.7 and previous versions, blocks which need to store placement or state data that did not have BlockEntities used metadata . Metadata was an extra number stored with the block, allowing different rotations, facings, or even completely separate behaviors within a block. However, the metadata system was confusing and limited, since it was stored as only a number alongside the block ID, and had no meaning except what was commented in the code. For example, to implement a block that can face a direction and be on either the upper or lower half of a block space (such as a stair): switch (meta) { case 0: { ... } // south and on the lower half of the block case 1: { ... } // south on the upper side of the block case 2: { ... } // north and on the lower half of the block case 3: { ... } // north and on the upper half of the block ... etc. ... } Because the numbers carry no meaning by themselves, no one could know what they represent unless they had access to the source code and comments.","title":"Legacy Behavior"},{"location":"blocks/states/#introduction-of-states","text":"In Minecraft 1.8 and above, the metadata system, along with the block ID system, was deprecated and eventually replaced with the block state system . The block state system abstracts out the details of the block\u2019s properties from the other behaviors of the block. Each property of a block is described by an instance of Property<?> . Examples of block properties include instruments ( EnumProperty<NoteBlockInstrument> ), facing ( DirectionProperty ), poweredness ( Property<Boolean> ), etc. Each property has the value of the type T parametrized by Property<T> . A unique triple can be constructed from the Block , the set of Property<?> , and the set of values for those properties. This unique triple is called a BlockState . The previous system of meaningless metadata values were replaced by a system of block properties, which are easier to interpret and deal with. Previously, a stone button which is facing east and is powered or held down is represented by \u201c minecraft:stone_button with metadata 9 . Now, this is represented by \u201c minecraft:stone_button[facing=east,powered=true] \u201d.","title":"Introduction of States"},{"location":"blocks/states/#proper-usage-of-block-states","text":"The BlockState system is a flexible and powerful system, but it also has limitations. BlockState s are immutable, and all combinations of their properties are generated on startup of the game. This means that having a BlockState with many properties and possible values will slow down the loading of the game, and befuddle anyone trying to make sense of your block logic. Not all blocks and situations require the usage of BlockState ; only the most basic properties of a block should be put into a BlockState , and any other situation is better off with having a BlockEntity or being a separate Block . Always consider if you actually need to use blockstates for your purposes. Note A good rule of thumb is: if it has a different name, it should be a separate block . An example is making chair blocks: the direction of the chair should be a property , while the different types of wood should be separated into different blocks. An \u201cOak Chair\u201d facing east ( oak_chair[facing=east] ) is different from a \u201cSpruce Chair\u201d facing west ( spruce_chair[facing=west] ).","title":"Proper Usage of Block States"},{"location":"blocks/states/#implementing-block-states","text":"In your Block class, create or reference static final Property<?> objects for every property that your Block has. You are free to make your own Property<?> implementations, but the means to do that are not covered in this article. The vanilla code provides several convenience implementations: IntegerProperty Implements Property<Integer> . Defines a property that holds an integer value. Created by calling IntegerProperty#create(String propertyName, int minimum, int maximum) . BooleanProperty Implements Property<Boolean> . Defines a property that holds a true or false value. Created by calling BooleanProperty#create(String propertyName) . EnumProperty<E extends Enum<E>> Implements Property<E> . Defines a property that can take on the values of an Enum class. Created by calling EnumProperty#create(String propertyName, Class<E> enumClass) . It is also possible to use only a subset of the Enum values (e.g. 4 out of 16 DyeColor s). See the overloads of EnumProperty#create . DirectionProperty This is a convenience implementation of EnumProperty<Direction> Several convenience predicates are also provided. For example, to get a property that represents the cardinal directions, call DirectionProperty.create(\"<name>\", Direction.Plane.HORIZONTAL) ; to get the X directions, DirectionProperty.create(\"<name>\", Direction.Axis.X) . The class BlockStateProperties contains shared vanilla properties which should be used or referenced whenever possible, in place of creating your own properties. When you have your desired Property<> objects, override Block#createBlockStateDefinition(StateDefinition$Builder) in your Block class. In that method, call StateDefinition$Builder#add(...); with the parameters as every Property<?> you wish the block to have. Every block will also have a \u201cdefault\u201d state that is automatically chosen for you. You can change this \u201cdefault\u201d state by calling the Block#registerDefaultState(BlockState) method from your constructor. When your block is placed it will become this \u201cdefault\u201d state. An example from DoorBlock : this.registerDefaultState( this.stateDefinition.any() .setValue(FACING, Direction.NORTH) .setValue(OPEN, false) .setValue(HINGE, DoorHingeSide.LEFT) .setValue(POWERED, false) .setValue(HALF, DoubleBlockHalf.LOWER) ); If you wish to change what BlockState is used when placing your block, you can overwrite Block#getStateForPlacement(BlockPlaceContext) . This can be used to, for example, set the direction of your block depending on where the player is standing when they place it. Because BlockState s are immutable, and all combinations of their properties are generated on startup of the game, calling BlockState#setValue(Property<T>, T) will simply go to the Block \u2018s StateHolder and request the BlockState with the set of values you want. Because all possible BlockState s are generated at startup, you are free and encouraged to use the reference equality operator ( == ) to check if two BlockState s are equal.","title":"Implementing Block States"},{"location":"blocks/states/#using-blockstates","text":"You can get the value of a property by calling BlockState#getValue(Property<?>) , passing it the property you want to get the value of. If you want to get a BlockState with a different set of values, simply call BlockState#setValue(Property<T>, T) with the property and its value. You can get and place BlockState \u2018s in the level using Level#setBlockAndUpdate(BlockPos, BlockState) and Level#getBlockState(BlockState) . If you are placing a Block , call Block#defaultBlockState() to get the \u201cdefault\u201d state, and use subsequent calls to BlockState#setValue(Property<T>, T) as stated above to achieve the desired state.","title":"Using BlockState's"},{"location":"concepts/data/","text":"Datapacks In 1.13, Mojang added datapacks to the base game. They allow for the modification of the files for logical servers through the data directory. This includes advancements, loot_tables, structures, recipes, tags, etc. Forge, and your mod, can also have datapacks. Any user can therefore modify all the recipes, loot tables, and other data defined within this directory. Creating a Datapack Datapacks are stored within the data directory within your project\u2019s resources. Your mod can have multiple data domains, since you can add or modify already existing datapacks, like vanilla\u2019s, forge\u2019s, or another mod\u2019s. You can then follow the steps found here to create any datapack. Additional reading: Resource Locations","title":"Data"},{"location":"concepts/data/#datapacks","text":"In 1.13, Mojang added datapacks to the base game. They allow for the modification of the files for logical servers through the data directory. This includes advancements, loot_tables, structures, recipes, tags, etc. Forge, and your mod, can also have datapacks. Any user can therefore modify all the recipes, loot tables, and other data defined within this directory.","title":"Datapacks"},{"location":"concepts/data/#creating-a-datapack","text":"Datapacks are stored within the data directory within your project\u2019s resources. Your mod can have multiple data domains, since you can add or modify already existing datapacks, like vanilla\u2019s, forge\u2019s, or another mod\u2019s. You can then follow the steps found here to create any datapack. Additional reading: Resource Locations","title":"Creating a Datapack"},{"location":"concepts/internationalization/","text":"Internationalization and Localization Internationalization, i18n for short, is a way of designing code so that it requires no changes to be adapted for various languages. Localization is the process of adapting displayed text to the user\u2019s language. I18n is implemented using translation keys . A translation key is a string that identifies a piece of displayable text in no specific language. For example, block.minecraft.dirt is the translation key referring to the name of the Dirt block. This way, displayable text may be referenced with no concern for a specific language. The code requires no changes to be adapted in a new language. Localization will happen in the game\u2019s locale. In a Minecraft client the locale is specified by the language settings. On a dedicated server, the only supported locale is en_us . A list of available locales can be found on the Minecraft Wiki . Language files Language files are located by assets/[namespace]/lang/[locale].json (e.g. all US English translations provided by examplemod would be within assets/examplemod/lang/en_us.json ). The file format is simply a json map from translation keys to values. The file must be encoded in UTF-8. Old .lang files can be converted to json using a converter . { \"item.examplemod.example_item\": \"Example Item Name\", \"block.examplemod.example_block\": \"Example Block Name\", \"commands.examplemod.examplecommand.error\": \"Example Command Errored!\" } Usage with Blocks and Items Block, Item and a few other Minecraft classes have built-in translation keys used to display their names. These translation keys are specified by overriding #getDescriptionId . Item also has #getDescriptionId(ItemStack) which can be overridden to provide different translation keys depending on ItemStack NBT. By default, #getDescriptionId will return block. or item. prepended to the registry name of the block or item, with the colon replaced by a dot. BlockItem s override this method to take their corresponding Block \u2018s translation key by default. For example, an item with ID examplemod:example_item effectively requires the following line in a language file: { \"item.examplemod.example_item\": \"Example Item Name\" } Note The only purpose of a translation key is internationalization. Do not use them for logic. Use registry names instead. Localization methods Warning A common issue is having the server localize for clients. The server can only localize in its own locale, which does not necessarily match the locale of connected clients. To respect the language settings of clients, the server should have clients localize text in their own locale using TranslatableComponent or other methods preserving the language neutral translation keys. net.minecraft.client.resources.language.I18n (client only) This I18n class can only be found on a Minecraft client! It is intended to be used by code that only runs on the client. Attempts to use this on a server will throw exceptions and crash. get(String, Object...) localizes in the client\u2019s locale with formatting. The first parameter is a translation key, and the rest are formatting arguments for String.format(String, Object...) . TranslatableComponent TranslatableComponent is a Component that is localized and formatted lazily. It is very useful when sending messages to players because it will be automatically localized in their own locale. The first parameter of the TranslatableComponent(String, Object...) constructor is a translation key, and the rest are used for formatting. The only supported format specifiers are %s and %1$s , %2$s , %3$s etc. Formatting arguments may be other Components s that will be inserted into the resulting formatted text with all their attributes preserved. TextComponentHelper createComponentTranslation(CommandSource, String, Object...) creates a localized and formatted BaseComponent depending on a receiver. The localization and formatting is done eagerly if the receiver is a vanilla client. If not, the localization and formatting is done lazily with a TranslatableComponent . This is only useful if the server should allow vanilla clients to connect.","title":"Internationalization and Localization"},{"location":"concepts/internationalization/#internationalization-and-localization","text":"Internationalization, i18n for short, is a way of designing code so that it requires no changes to be adapted for various languages. Localization is the process of adapting displayed text to the user\u2019s language. I18n is implemented using translation keys . A translation key is a string that identifies a piece of displayable text in no specific language. For example, block.minecraft.dirt is the translation key referring to the name of the Dirt block. This way, displayable text may be referenced with no concern for a specific language. The code requires no changes to be adapted in a new language. Localization will happen in the game\u2019s locale. In a Minecraft client the locale is specified by the language settings. On a dedicated server, the only supported locale is en_us . A list of available locales can be found on the Minecraft Wiki .","title":"Internationalization and Localization"},{"location":"concepts/internationalization/#language-files","text":"Language files are located by assets/[namespace]/lang/[locale].json (e.g. all US English translations provided by examplemod would be within assets/examplemod/lang/en_us.json ). The file format is simply a json map from translation keys to values. The file must be encoded in UTF-8. Old .lang files can be converted to json using a converter . { \"item.examplemod.example_item\": \"Example Item Name\", \"block.examplemod.example_block\": \"Example Block Name\", \"commands.examplemod.examplecommand.error\": \"Example Command Errored!\" }","title":"Language files"},{"location":"concepts/internationalization/#usage-with-blocks-and-items","text":"Block, Item and a few other Minecraft classes have built-in translation keys used to display their names. These translation keys are specified by overriding #getDescriptionId . Item also has #getDescriptionId(ItemStack) which can be overridden to provide different translation keys depending on ItemStack NBT. By default, #getDescriptionId will return block. or item. prepended to the registry name of the block or item, with the colon replaced by a dot. BlockItem s override this method to take their corresponding Block \u2018s translation key by default. For example, an item with ID examplemod:example_item effectively requires the following line in a language file: { \"item.examplemod.example_item\": \"Example Item Name\" } Note The only purpose of a translation key is internationalization. Do not use them for logic. Use registry names instead.","title":"Usage with Blocks and Items"},{"location":"concepts/internationalization/#localization-methods","text":"Warning A common issue is having the server localize for clients. The server can only localize in its own locale, which does not necessarily match the locale of connected clients. To respect the language settings of clients, the server should have clients localize text in their own locale using TranslatableComponent or other methods preserving the language neutral translation keys.","title":"Localization methods"},{"location":"concepts/internationalization/#netminecraftclientresourceslanguagei18n-client-only","text":"This I18n class can only be found on a Minecraft client! It is intended to be used by code that only runs on the client. Attempts to use this on a server will throw exceptions and crash. get(String, Object...) localizes in the client\u2019s locale with formatting. The first parameter is a translation key, and the rest are formatting arguments for String.format(String, Object...) .","title":"net.minecraft.client.resources.language.I18n (client only)"},{"location":"concepts/internationalization/#translatablecomponent","text":"TranslatableComponent is a Component that is localized and formatted lazily. It is very useful when sending messages to players because it will be automatically localized in their own locale. The first parameter of the TranslatableComponent(String, Object...) constructor is a translation key, and the rest are used for formatting. The only supported format specifiers are %s and %1$s , %2$s , %3$s etc. Formatting arguments may be other Components s that will be inserted into the resulting formatted text with all their attributes preserved.","title":"TranslatableComponent"},{"location":"concepts/internationalization/#textcomponenthelper","text":"createComponentTranslation(CommandSource, String, Object...) creates a localized and formatted BaseComponent depending on a receiver. The localization and formatting is done eagerly if the receiver is a vanilla client. If not, the localization and formatting is done lazily with a TranslatableComponent . This is only useful if the server should allow vanilla clients to connect.","title":"TextComponentHelper"},{"location":"concepts/lifecycle/","text":"Mod Lifecycle During the mod loading process, the various lifecycle events are fired on the mod-specific event bus. Many actions are performed during these events, such as registering objects , preparing for data generation , or communicating with other mods . Event listeners should be registered either using @EventBusSubscriber(bus = Bus.MOD) or in the mod constructor: @Mod.EventBusSubscriber(modid = \"mymod\", bus = Mod.EventBusSubscriber.Bus.MOD) public class MyModEventSubscriber { @SubscribeEvent static void onCommonSetup(FMLCommonSetupEvent event) { ... } } @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().addListener(this::onCommonSetup); } private void onCommonSetup(FMLCommonSetupEvent event) { ... } } Warning Most of the lifecycle events are fired in parallel: all mods will concurrently receive the same event. Mods must take care to be thread-safe, like when calling other mods\u2019 APIs or accessing vanilla systems. Defer code for later execution via ParallelDispatchEvent#enqueueWork . Registry Events The RegistryEvent s are fired after the mod instance construction. There are two: the NewRegistry event and the Register event. These events are fired synchronously during mod loading. The RegistryEvent$NewRegistry event allows modders to register their own custom registries, using the RegistryBuilder class. The RegistryEvent$Register<?> event is for registering objects into the registries. A Register event is fired for each registry. Data Generation If the game is setup to run data generators , then the GatherDataEvent will be the last event to fire. This event is for registering mods\u2019 data providers to their associated data generator. This event is also fired synchronously. Common Setup FMLCommonSetupEvent is for actions that are common to both physical client and server, such as registering capabilities . Sided Setup The sided-setup events are fired on their respective physical sides : FMLClientSetupEvent on the physical client, and FMLDedicatedServerSetupEvent for the dedicated server. This is where physical side-specific initialization should occur, such as registering client-side key bindings. InterModComms This is where messages can be sent to mods for cross-mod compatibility. There are two events: InterModEnqueueEvent and InterModProcessEvent . InterModComms is the class responsible for holding messages for mods. The methods are safe to call during the lifecycle events, as it is backed by a ConcurrentMap . During the InterModEnqueueEvent , use InterModComms#sendTo to send messages to different mods, then during the InterModProcessEvent , call InterModComms#getMessages to get a stream of all received messages. Note There are two other lifecycle events: FMLConstructModEvent , fired directly after mod instance construction but before the RegistryEvent s, and FMLLoadCompleteEvent , fired after the InterModComms events, for when the mod loading process is complete.","title":"Mod Lifecycle"},{"location":"concepts/lifecycle/#mod-lifecycle","text":"During the mod loading process, the various lifecycle events are fired on the mod-specific event bus. Many actions are performed during these events, such as registering objects , preparing for data generation , or communicating with other mods . Event listeners should be registered either using @EventBusSubscriber(bus = Bus.MOD) or in the mod constructor: @Mod.EventBusSubscriber(modid = \"mymod\", bus = Mod.EventBusSubscriber.Bus.MOD) public class MyModEventSubscriber { @SubscribeEvent static void onCommonSetup(FMLCommonSetupEvent event) { ... } } @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().addListener(this::onCommonSetup); } private void onCommonSetup(FMLCommonSetupEvent event) { ... } } Warning Most of the lifecycle events are fired in parallel: all mods will concurrently receive the same event. Mods must take care to be thread-safe, like when calling other mods\u2019 APIs or accessing vanilla systems. Defer code for later execution via ParallelDispatchEvent#enqueueWork .","title":"Mod Lifecycle"},{"location":"concepts/lifecycle/#registry-events","text":"The RegistryEvent s are fired after the mod instance construction. There are two: the NewRegistry event and the Register event. These events are fired synchronously during mod loading. The RegistryEvent$NewRegistry event allows modders to register their own custom registries, using the RegistryBuilder class. The RegistryEvent$Register<?> event is for registering objects into the registries. A Register event is fired for each registry.","title":"Registry Events"},{"location":"concepts/lifecycle/#data-generation","text":"If the game is setup to run data generators , then the GatherDataEvent will be the last event to fire. This event is for registering mods\u2019 data providers to their associated data generator. This event is also fired synchronously.","title":"Data Generation"},{"location":"concepts/lifecycle/#common-setup","text":"FMLCommonSetupEvent is for actions that are common to both physical client and server, such as registering capabilities .","title":"Common Setup"},{"location":"concepts/lifecycle/#sided-setup","text":"The sided-setup events are fired on their respective physical sides : FMLClientSetupEvent on the physical client, and FMLDedicatedServerSetupEvent for the dedicated server. This is where physical side-specific initialization should occur, such as registering client-side key bindings.","title":"Sided Setup"},{"location":"concepts/lifecycle/#intermodcomms","text":"This is where messages can be sent to mods for cross-mod compatibility. There are two events: InterModEnqueueEvent and InterModProcessEvent . InterModComms is the class responsible for holding messages for mods. The methods are safe to call during the lifecycle events, as it is backed by a ConcurrentMap . During the InterModEnqueueEvent , use InterModComms#sendTo to send messages to different mods, then during the InterModProcessEvent , call InterModComms#getMessages to get a stream of all received messages. Note There are two other lifecycle events: FMLConstructModEvent , fired directly after mod instance construction but before the RegistryEvent s, and FMLLoadCompleteEvent , fired after the InterModComms events, for when the mod loading process is complete.","title":"InterModComms"},{"location":"concepts/registries/","text":"Registries Registration is the process of taking the objects of a mod (such as items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects, which will cause unexplainable behaviors and crashes. Most things that require registration in the game are handled by the Forge registries. A registry is an object similar to a map that assigns values to keys. Forge uses registries with ResourceLocation keys to register objects. This allows the ResourceLocation to act as the \u201cregistry name\u201d for objects. The registry name for an object may be accessed with #getRegistryName / #setRegistryName . The setter can only be called once; calling it twice results in an exception. Every type of registrable object has its own registry. To see all registries supported by Forge, see the ForgeRegistries class. All registry names within a registry must be unique. However, names in different registries will not collide. For example, there\u2019s a Block registry, and an Item registry. A Block and an Item may be registered with the same name example:thing without colliding; however, if two different Block s or Item s were registered with the same exact name, the second object will override the first. Methods for Registering There are two proper ways to register objects: the DeferredRegister class, and the RegistryEvent$Register lifecycle event. DeferredRegister DeferredRegister is the newer and documented way to register objects. It allows the use and convenience of static initializers while avoiding the issues associated with it. It simply maintains a list of suppliers for entries and registers the objects from those suppliers during the proper RegistryEvent$Register event. An example of a mod registering a custom block: private static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, MODID); public static final RegistryObject<Block> ROCK_BLOCK = BLOCKS.register(\"rock\", () -> new Block(BlockBehaviour.Properties.of(Material.STONE))); public ExampleMod() { BLOCKS.register(FMLJavaModLoadingContext.get().getModEventBus()); } Register events The RegistryEvent s are the second and more flexible way to register objects. These events are fired after the mod constructors and before the loading of configs. The event used to register objects is RegistryEvent$Register<T> . The type parameter T should be set to the type of the object being registered. Calling #getRegistry will return the registry, upon which objects are registered with #register or #registerAll . Here is an example: (the event handler is registered on the mod event bus ) @SubscribeEvent public void registerBlocks(RegistryEvent.Register<Block> event) { event.getRegistry().registerAll(new Block(...), new Block(...), ...); } Note Some classes cannot by themselves be registered. Instead, *Type classes are registered, and used in the formers\u2019 constructors. For example, BlockEntity has BlockEntityType , and Entity has EntityType . These *Type classes are factories that simply create the containing type on demand. These factories are created through the use of their *Type$Builder classes. An example: ( REGISTER refers to a DeferredRegister<BlockEntityType> ) public static final RegistryObject<BlockEntityType<ExampleBlockEntity>> EXAMPLE_BLOCK_ENTITY = REGISTER.register( \"example_block_entity\", () -> BlockEntityType.Builder.of(ExampleBlockEntity::new, EXAMPLE_BLOCK.get()).build(null) ); Referencing Registered Objects Registered objects should not be stored in fields when they are created and registered. They are to be always newly created and registered whenever their respective RegistryEvent$Register event is fired. This is to allow dynamic loading and unloading of mods in a future version of Forge. Registered objects must always be referenced through a RegistryObject or a field with @ObjectHolder . Using RegistryObjects RegistryObject s can be used to retrieve references to registered objects once they are available. These are used by DeferredRegister to return a reference to the registered objects. Their references are updated after their corresponding registry\u2019s RegistryEvent$Register event is fired, along with the @ObjectHolder annotations. To get a RegistryObject , call RegistryObject#of with a ResourceLocation and the IForgeRegistry of the registrable object. Custom registries can also be used by giving a supplier of the object\u2019s class. Store the RegistryObject in a public static final field, and call #get whenever you need the registered object. An example of using RegistryObject : public static final RegistryObject<Item> BOW = RegistryObject.of(new ResourceLocation(\"minecraft:bow\"), ForgeRegistries.ITEMS); // assume that ManaType is a valid registry, and 'neomagicae:coffeinum' is a valid object within that registry public static final RegistryObject<ManaType> COFFEINUM = RegistryObject.of(new ResourceLocation(\"neomagicae\", \"coffeinum\"), () -> ManaType.class); Using @ObjectHolder Registered objects from registries can be injected into the public static fields by annotating classes or fields with @ObjectHolder and supplying enough information to construct a ResourceLocation to identify a specific object in a specific registry. The rules for @ObjectHolder are as follows: If the class is annotated with @ObjectHolder , its value will be the default namespace for all fields within if not explicitly defined If the class is annotated with @Mod , the modid will be the default namespace for all annotated fields within if not explicitly defined A field is considered for injection if: it has at least the modifiers public static ; one of the following conditions are true: the enclosing class has an @ObjectHolder annotation, and the field is final , and: the name value is the field\u2019s name; and the namespace value is the enclosing class\u2019s namespace An exception is thrown if the namespace value cannot be found and inherited the field is annotated with @ObjectHolder , and: the name value is explicitly defined; and the namespace value is either explicitly defined or the enclosing class\u2019s namespace the field type or one of its supertypes corresponds to a valid registry (e.g. Item or ArrowItem for the Item registry); An exception is thrown if a field does not have a corresponding registry. An exception is thrown if the resulting ResourceLocation is incomplete or invalid (non-valid characters in path) If no other errors or exceptions occur, the field will be injected If all of the above rules do not apply, no action will be taken (and a message may be logged) @ObjectHolder -annotated fields are injected with their values after their corresponding registry\u2019s RegistryEvent$Register event is fired, along with the RegistryObject s. Note If the object does not exist in the registry when it is to be injected, a debug message will be logged and no value will be injected. As these rules are rather complicated, here are some examples: @ObjectHolder(\"minecraft\") // Inheritable resource namespace: \"minecraft\" class AnnotatedHolder { public static final Block diamond_block = null; // No annotation. [public static final] is required. // Block has a corresponding registry: [Block] // Name path is the name of the field: \"diamond_block\" // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:diamond_block\" from the [Block] registry @ObjectHolder(\"ambient.cave\") public static SoundEvent ambient_sound = null; // Annotation present. [public static] is required. // SoundEvent has a corresponding registry: [SoundEvent] // Name path is the value of the annotation: \"ambient.cave\" // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:ambient.cave\" from the [SoundEvent] registry // Assume for the next entry that [ManaType] is a valid registry. @ObjectHolder(\"neomagicae:coffeinum\") public static final ManaType coffeinum = null; // Annotation present. [public static] is required. [final] is optional. // ManaType has a corresponding registry: [ManaType] (custom registry) // Resource location is explicitly defined: \"neomagicae:coffeinum\" // To inject: \"neomagicae:coffeinum\" from the [ManaType] registry public static final Item ENDER_PEARL = null; // No annotation. [public static final] is required. // Item has a corresponding registry: [Item]. // Name path is the name of the field: \"ENDER_PEARL\" -> \"ender_pearl\" // !! ^ Field name is valid, because they are // converted to lowercase automatically. // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:ender_pearl\" from the [Item] registry @ObjectHolder(\"minecraft:arrow\") public static final ArrowItem arrow = null; // Annotation present. [public static] is required. [final] is optional. // ArrowItem does not have a corresponding registry. // ArrowItem's supertype of Item has a corresponding registry: [Item] // Resource location is explicitly defined: \"minecraft:arrow\" // To inject: \"minecraft:arrow\" from the [Item] registry public static Block bedrock = null; // No annotation, so [public static final] is required. // Therefore, the field is ignored. public static final CreativeModeTab group = null; // No annotation. [public static final] is required. // CreativeModeTab does not have a corresponding registry. // No supertypes of CreativeModeTab has a corresponding registry. // Therefore, THIS WILL PRODUCE AN EXCEPTION. } class UnannotatedHolder { // Note the lack of an @ObjectHolder annotation on this class. @ObjectHolder(\"minecraft:flame\") public static final Enchantment flame = null; // Annotation present. [public static] is required. [final] is optional. // Enchantment has corresponding registry: [Enchantment]. // Resource location is explicitly defined: \"minecraft:flame\" // To inject: \"minecraft:flame\" from the [Enchantment] registry public static final Biome ice_flat = null; // No annotation on the enclosing class. // Therefore, the field is ignored. @ObjectHolder(\"minecraft:creeper\") public static Entity creeper = null; // Annotation present. [public static] is required. // Entity does not have a corresponding registry. // No supertypes of Entity has a corresponding registry. // Therefore, THIS WILL PRODUCE AN EXCEPTION. @ObjectHolder(\"levitation\") public static final Potion levitation = null; // Annotation present. [public static] is required. [final] is optional. // Potion has a corresponding registry: [Potion]. // Name path is the value of the annotation: \"levitation\" // Namespace is not explicitly defined. // No annotation in enclosing class. // Therefore, THIS WILL PRODUCE AN EXCEPTION. } Creating Custom Registries Custom registries are created by using RegistryBuilder during the RegistryEvent$NewRegistry event. The class RegistryBuilder takes certain parameters (such as the name, the Class of its values, and various callbacks for different events happening on the registry). Calling RegistryBuilder#create will result in the registry being built, registered to the RegistryManager , and returned to the caller for additional processing. The Class of the value of the registry must implement IForgeRegistryEntry , which defines that #setRegistryName and #getRegistryName can be called on the objects of that class. It is recommended to extend ForgeRegistryEntry , the default implementation instead of implementing the interface directly. When #setRegistryName(String) is called with a string, and that string does not have an explicit namespace, its namespace will be set to the current modid. The Forge registries can be accessed through the ForgeRegistries class. Any other registries can be stored and cached during their associated RegistryEvent$Register .","title":"Registries"},{"location":"concepts/registries/#registries","text":"Registration is the process of taking the objects of a mod (such as items, blocks, sounds, etc.) and making them known to the game. Registering things is important, as without registration the game will simply not know about these objects, which will cause unexplainable behaviors and crashes. Most things that require registration in the game are handled by the Forge registries. A registry is an object similar to a map that assigns values to keys. Forge uses registries with ResourceLocation keys to register objects. This allows the ResourceLocation to act as the \u201cregistry name\u201d for objects. The registry name for an object may be accessed with #getRegistryName / #setRegistryName . The setter can only be called once; calling it twice results in an exception. Every type of registrable object has its own registry. To see all registries supported by Forge, see the ForgeRegistries class. All registry names within a registry must be unique. However, names in different registries will not collide. For example, there\u2019s a Block registry, and an Item registry. A Block and an Item may be registered with the same name example:thing without colliding; however, if two different Block s or Item s were registered with the same exact name, the second object will override the first.","title":"Registries"},{"location":"concepts/registries/#methods-for-registering","text":"There are two proper ways to register objects: the DeferredRegister class, and the RegistryEvent$Register lifecycle event.","title":"Methods for Registering"},{"location":"concepts/registries/#deferredregister","text":"DeferredRegister is the newer and documented way to register objects. It allows the use and convenience of static initializers while avoiding the issues associated with it. It simply maintains a list of suppliers for entries and registers the objects from those suppliers during the proper RegistryEvent$Register event. An example of a mod registering a custom block: private static final DeferredRegister<Block> BLOCKS = DeferredRegister.create(ForgeRegistries.BLOCKS, MODID); public static final RegistryObject<Block> ROCK_BLOCK = BLOCKS.register(\"rock\", () -> new Block(BlockBehaviour.Properties.of(Material.STONE))); public ExampleMod() { BLOCKS.register(FMLJavaModLoadingContext.get().getModEventBus()); }","title":"DeferredRegister"},{"location":"concepts/registries/#register-events","text":"The RegistryEvent s are the second and more flexible way to register objects. These events are fired after the mod constructors and before the loading of configs. The event used to register objects is RegistryEvent$Register<T> . The type parameter T should be set to the type of the object being registered. Calling #getRegistry will return the registry, upon which objects are registered with #register or #registerAll . Here is an example: (the event handler is registered on the mod event bus ) @SubscribeEvent public void registerBlocks(RegistryEvent.Register<Block> event) { event.getRegistry().registerAll(new Block(...), new Block(...), ...); } Note Some classes cannot by themselves be registered. Instead, *Type classes are registered, and used in the formers\u2019 constructors. For example, BlockEntity has BlockEntityType , and Entity has EntityType . These *Type classes are factories that simply create the containing type on demand. These factories are created through the use of their *Type$Builder classes. An example: ( REGISTER refers to a DeferredRegister<BlockEntityType> ) public static final RegistryObject<BlockEntityType<ExampleBlockEntity>> EXAMPLE_BLOCK_ENTITY = REGISTER.register( \"example_block_entity\", () -> BlockEntityType.Builder.of(ExampleBlockEntity::new, EXAMPLE_BLOCK.get()).build(null) );","title":"Register events"},{"location":"concepts/registries/#referencing-registered-objects","text":"Registered objects should not be stored in fields when they are created and registered. They are to be always newly created and registered whenever their respective RegistryEvent$Register event is fired. This is to allow dynamic loading and unloading of mods in a future version of Forge. Registered objects must always be referenced through a RegistryObject or a field with @ObjectHolder .","title":"Referencing Registered Objects"},{"location":"concepts/registries/#using-registryobjects","text":"RegistryObject s can be used to retrieve references to registered objects once they are available. These are used by DeferredRegister to return a reference to the registered objects. Their references are updated after their corresponding registry\u2019s RegistryEvent$Register event is fired, along with the @ObjectHolder annotations. To get a RegistryObject , call RegistryObject#of with a ResourceLocation and the IForgeRegistry of the registrable object. Custom registries can also be used by giving a supplier of the object\u2019s class. Store the RegistryObject in a public static final field, and call #get whenever you need the registered object. An example of using RegistryObject : public static final RegistryObject<Item> BOW = RegistryObject.of(new ResourceLocation(\"minecraft:bow\"), ForgeRegistries.ITEMS); // assume that ManaType is a valid registry, and 'neomagicae:coffeinum' is a valid object within that registry public static final RegistryObject<ManaType> COFFEINUM = RegistryObject.of(new ResourceLocation(\"neomagicae\", \"coffeinum\"), () -> ManaType.class);","title":"Using RegistryObjects"},{"location":"concepts/registries/#using-objectholder","text":"Registered objects from registries can be injected into the public static fields by annotating classes or fields with @ObjectHolder and supplying enough information to construct a ResourceLocation to identify a specific object in a specific registry. The rules for @ObjectHolder are as follows: If the class is annotated with @ObjectHolder , its value will be the default namespace for all fields within if not explicitly defined If the class is annotated with @Mod , the modid will be the default namespace for all annotated fields within if not explicitly defined A field is considered for injection if: it has at least the modifiers public static ; one of the following conditions are true: the enclosing class has an @ObjectHolder annotation, and the field is final , and: the name value is the field\u2019s name; and the namespace value is the enclosing class\u2019s namespace An exception is thrown if the namespace value cannot be found and inherited the field is annotated with @ObjectHolder , and: the name value is explicitly defined; and the namespace value is either explicitly defined or the enclosing class\u2019s namespace the field type or one of its supertypes corresponds to a valid registry (e.g. Item or ArrowItem for the Item registry); An exception is thrown if a field does not have a corresponding registry. An exception is thrown if the resulting ResourceLocation is incomplete or invalid (non-valid characters in path) If no other errors or exceptions occur, the field will be injected If all of the above rules do not apply, no action will be taken (and a message may be logged) @ObjectHolder -annotated fields are injected with their values after their corresponding registry\u2019s RegistryEvent$Register event is fired, along with the RegistryObject s. Note If the object does not exist in the registry when it is to be injected, a debug message will be logged and no value will be injected. As these rules are rather complicated, here are some examples: @ObjectHolder(\"minecraft\") // Inheritable resource namespace: \"minecraft\" class AnnotatedHolder { public static final Block diamond_block = null; // No annotation. [public static final] is required. // Block has a corresponding registry: [Block] // Name path is the name of the field: \"diamond_block\" // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:diamond_block\" from the [Block] registry @ObjectHolder(\"ambient.cave\") public static SoundEvent ambient_sound = null; // Annotation present. [public static] is required. // SoundEvent has a corresponding registry: [SoundEvent] // Name path is the value of the annotation: \"ambient.cave\" // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:ambient.cave\" from the [SoundEvent] registry // Assume for the next entry that [ManaType] is a valid registry. @ObjectHolder(\"neomagicae:coffeinum\") public static final ManaType coffeinum = null; // Annotation present. [public static] is required. [final] is optional. // ManaType has a corresponding registry: [ManaType] (custom registry) // Resource location is explicitly defined: \"neomagicae:coffeinum\" // To inject: \"neomagicae:coffeinum\" from the [ManaType] registry public static final Item ENDER_PEARL = null; // No annotation. [public static final] is required. // Item has a corresponding registry: [Item]. // Name path is the name of the field: \"ENDER_PEARL\" -> \"ender_pearl\" // !! ^ Field name is valid, because they are // converted to lowercase automatically. // Namespace is not explicitly defined. // So, namespace is inherited from class annotation: \"minecraft\" // To inject: \"minecraft:ender_pearl\" from the [Item] registry @ObjectHolder(\"minecraft:arrow\") public static final ArrowItem arrow = null; // Annotation present. [public static] is required. [final] is optional. // ArrowItem does not have a corresponding registry. // ArrowItem's supertype of Item has a corresponding registry: [Item] // Resource location is explicitly defined: \"minecraft:arrow\" // To inject: \"minecraft:arrow\" from the [Item] registry public static Block bedrock = null; // No annotation, so [public static final] is required. // Therefore, the field is ignored. public static final CreativeModeTab group = null; // No annotation. [public static final] is required. // CreativeModeTab does not have a corresponding registry. // No supertypes of CreativeModeTab has a corresponding registry. // Therefore, THIS WILL PRODUCE AN EXCEPTION. } class UnannotatedHolder { // Note the lack of an @ObjectHolder annotation on this class. @ObjectHolder(\"minecraft:flame\") public static final Enchantment flame = null; // Annotation present. [public static] is required. [final] is optional. // Enchantment has corresponding registry: [Enchantment]. // Resource location is explicitly defined: \"minecraft:flame\" // To inject: \"minecraft:flame\" from the [Enchantment] registry public static final Biome ice_flat = null; // No annotation on the enclosing class. // Therefore, the field is ignored. @ObjectHolder(\"minecraft:creeper\") public static Entity creeper = null; // Annotation present. [public static] is required. // Entity does not have a corresponding registry. // No supertypes of Entity has a corresponding registry. // Therefore, THIS WILL PRODUCE AN EXCEPTION. @ObjectHolder(\"levitation\") public static final Potion levitation = null; // Annotation present. [public static] is required. [final] is optional. // Potion has a corresponding registry: [Potion]. // Name path is the value of the annotation: \"levitation\" // Namespace is not explicitly defined. // No annotation in enclosing class. // Therefore, THIS WILL PRODUCE AN EXCEPTION. }","title":"Using @ObjectHolder"},{"location":"concepts/registries/#creating-custom-registries","text":"Custom registries are created by using RegistryBuilder during the RegistryEvent$NewRegistry event. The class RegistryBuilder takes certain parameters (such as the name, the Class of its values, and various callbacks for different events happening on the registry). Calling RegistryBuilder#create will result in the registry being built, registered to the RegistryManager , and returned to the caller for additional processing. The Class of the value of the registry must implement IForgeRegistryEntry , which defines that #setRegistryName and #getRegistryName can be called on the objects of that class. It is recommended to extend ForgeRegistryEntry , the default implementation instead of implementing the interface directly. When #setRegistryName(String) is called with a string, and that string does not have an explicit namespace, its namespace will be set to the current modid. The Forge registries can be accessed through the ForgeRegistries class. Any other registries can be stored and cached during their associated RegistryEvent$Register .","title":"Creating Custom Registries"},{"location":"concepts/resources/","text":"Resources A resource is extra data used by the game, and is stored in a data file, instead of being in the code. Minecraft has two primary resource systems active: one on the logical client used for visuals such as models, textures, and localization called assets , and one on the logical server used for gameplay such as recipes and loot tables called data . Resource packs control the former, while Datapacks control the latter. In the default mod development kit, assets and data directories are located under the src/main/resources directory of the project. When multiple resource packs or data packs are enabled, they are merged. Generally, files from packs at the top of the stack override those below; however, for certain files, such as localization files and tags, data is actually merged contentwise. Mods define resource and data packs in their resources directories, but they are seen as subsets of the \u201cMod Resources\u201d pack. Mod resource packs cannot be disabled, but they can be overridden by other resource packs. Mod datapacks can be disabled with the vanilla /datapack command. All resources should have snake case paths and filenames (lowercase, using \u201c_\u201d for word boundaries), which is enforced in 1.11 and above. ResourceLocation Minecraft identifies resources using ResourceLocation s. A ResourceLocation contains two parts: a namespace and a path. It generally points to the resource at assets/<namespace>/<ctx>/<path> , where ctx is a context-specific path fragment that depends on how the ResourceLocation is being used. When a ResourceLocation is written/read as from a string, it is seen as <namespace>:<path> . If the namespace and the colon are left out, then when the string is read into an ResourceLocation the namespace will always default to \"minecraft\" . A mod should put its resources into a namespace with the same name as its modid (e.g. a mod with id examplemod should place its resources in assets/examplemod and data/examplemod respectively, and ResourceLocation s pointing to those files would look like examplemod:<path> .). This is not a requirement, and in some cases it can be desirable to use a different (or even more than one) namespace. ResourceLocation s are used outside the resource system, too, as they happen to be a great way to uniquely identify objects (e.g. registries ).","title":"Resources"},{"location":"concepts/resources/#resources","text":"A resource is extra data used by the game, and is stored in a data file, instead of being in the code. Minecraft has two primary resource systems active: one on the logical client used for visuals such as models, textures, and localization called assets , and one on the logical server used for gameplay such as recipes and loot tables called data . Resource packs control the former, while Datapacks control the latter. In the default mod development kit, assets and data directories are located under the src/main/resources directory of the project. When multiple resource packs or data packs are enabled, they are merged. Generally, files from packs at the top of the stack override those below; however, for certain files, such as localization files and tags, data is actually merged contentwise. Mods define resource and data packs in their resources directories, but they are seen as subsets of the \u201cMod Resources\u201d pack. Mod resource packs cannot be disabled, but they can be overridden by other resource packs. Mod datapacks can be disabled with the vanilla /datapack command. All resources should have snake case paths and filenames (lowercase, using \u201c_\u201d for word boundaries), which is enforced in 1.11 and above.","title":"Resources"},{"location":"concepts/resources/#resourcelocation","text":"Minecraft identifies resources using ResourceLocation s. A ResourceLocation contains two parts: a namespace and a path. It generally points to the resource at assets/<namespace>/<ctx>/<path> , where ctx is a context-specific path fragment that depends on how the ResourceLocation is being used. When a ResourceLocation is written/read as from a string, it is seen as <namespace>:<path> . If the namespace and the colon are left out, then when the string is read into an ResourceLocation the namespace will always default to \"minecraft\" . A mod should put its resources into a namespace with the same name as its modid (e.g. a mod with id examplemod should place its resources in assets/examplemod and data/examplemod respectively, and ResourceLocation s pointing to those files would look like examplemod:<path> .). This is not a requirement, and in some cases it can be desirable to use a different (or even more than one) namespace. ResourceLocation s are used outside the resource system, too, as they happen to be a great way to uniquely identify objects (e.g. registries ).","title":"ResourceLocation"},{"location":"concepts/sides/","text":"Sides in Minecraft A very important concept to understand when modding Minecraft are the two sides: client and server . There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects. Different Kinds of Sides When we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we are talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right? As it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d: Physical client - The physical client is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client. Physical server - Often known as the dedicated server, the physical server is the entire program that runs whenever you launch any sort of minecraft_server.jar that does not bring up a playable GUI. Logical server - The logical server is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within a physical server, but it also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the Server Thread . Logical client - The logical client is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the Render Thread , though often several other threads are spawned to handle things like audio and chunk render batching. In the MinecraftForge codebase, the physical side is represented by an enum called Dist , while the logical side is represented by an enum called LogicalSide . Performing Side-Specific Operations Level#isClientSide This boolean check will be your most used way to check sides. Querying this field on a Level object establishes the logical side the level belongs to. That is, if this field is true , the level is currently running on the logical client. If the field is false , the level is running on the logical server. It follows that the physical server will always contain false in this field, but we cannot assume that false implies a physical server, since this field can also be false for the logical server inside a physical client (in other words, a single player world). Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring #isClientSide is false . Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the best case, and crashes in the worst case. This check should be used as your go-to default. Aside from DistExecutor , rarely will you need the other ways of determining side and adjusting behavior. DistExecutor Considering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in net.minecraft.client is only present on the physical client, and all code in net.minecraft.server.dedicated is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call Minecraft.getInstance().<doStuff>() in block or block entity classes, which will crash any physical server as soon as the class is loaded. How do we resolve this? Luckily, FML has DistExecutor , which provides various methods to run different methods on different physical sides, or a single method only on one side. Note It is important to understand that FML checks based on the physical side. A single player world (logical server + logical client within a physical client) will always use Dist.CLIENT ! Thread Groups If Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER is true, it is likely the current thread is on the logical server. Otherwise, it is likely on the logical client. This is useful to retrieve the logical side when you do not have access to a Level object to check isClientSide . It guesses which logical side you are on by looking at the group of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking Level#isClientSide . FMLEnvironment#dist and @OnlyIn FMLEnvironment#dist holds the physical side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this is limited, however. Annotating a method or field with the @OnlyIn(Dist) annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified physical side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is NO reason for using this annotation directly. Use DistExecutor or a check on FMLEnvironment#dist instead. Common Mistakes Reaching Across Logical Sides Whenever you want to send information from one logical side to another, you must always use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client. This is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading. This mistake can also be made explicitly by accessing physical client-only classes such as Minecraft from common code that runs or can run on the logical server. This mistake is easy to miss for beginners who debug in a physical client. The code will work there, but it will immediately crash on a physical server. Writing One-Sided Mods In recent versions, Minecraft Forge has removed a \u201csidedness\u201d attribute from the mods.toml. This means that your mods are expected to work whether they are loaded on the physical client or the physical server. So for one-sided mods, you would typically register your event handlers inside a DistExecutor#safeRunWhenOn or DistExecutor#unsafeRunWhenOn instead of directly calling the relevant registration methods in your mod constructor. Basically, if your mod is loaded on the wrong side, it should simply do nothing, listen to no events, and so on. A one-sided mod by nature should not register blocks, items, \u2026 since they would need to be available on the other side, too. Additionally, if your mod is one-sided, it typically does not forbid the user from joining a server that is lacking that mod. Therefore, you should register an IExtensionPoint$DisplayTest extension point to make sure that Forge does not think your mod is required on the server, which would lead to the server being shown as incompatible. For that, put something similar to this into your main mod class constructor: //Make sure the mod being absent on the other network side does not cause the client to display the server as incompatible ModLoadingContext.get().registerExtensionPoint(IExtensionPoint.DisplayTest.class, () -> new IExtensionPoint.DisplayTest(() -> FMLNetworkConstants.IGNORESERVERONLY, (a, b) -> true)); This tells the client that it should ignore the server version being absent, and the server that it should not tell the client this mod should be present. So this snippet works both for client- and server-only-sided mods.","title":"Sides"},{"location":"concepts/sides/#sides-in-minecraft","text":"A very important concept to understand when modding Minecraft are the two sides: client and server . There are many, many common misconceptions and mistakes regarding siding, which can lead to bugs that might not crash the game, but can rather have unintended and often unpredictable effects.","title":"Sides in Minecraft"},{"location":"concepts/sides/#different-kinds-of-sides","text":"When we say \u201cclient\u201d or \u201cserver\u201d, it usually follows with a fairly intuitive understanding of what part of the game we are talking about. After all, a client is what the user interacts with, and a server is where the user connects for a multiplayer game. Easy, right? As it turns out, there can be some ambiguity even with two such terms. Here we disambiguate the four possible meanings of \u201cclient\u201d and \u201cserver\u201d: Physical client - The physical client is the entire program that runs whenever you launch Minecraft from the launcher. All threads, processes, and services that run during the game\u2019s graphical, interactable lifetime are part of the physical client. Physical server - Often known as the dedicated server, the physical server is the entire program that runs whenever you launch any sort of minecraft_server.jar that does not bring up a playable GUI. Logical server - The logical server is what runs game logic: mob spawning, weather, updating inventories, health, AI, and all other game mechanics. The logical server is present within a physical server, but it also can run inside a physical client together with a logical client, as a single player world. The logical server always runs in a thread named the Server Thread . Logical client - The logical client is what accepts input from the player and relays it to the logical server. In addition, it also receives information from the logical server and makes it available graphically to the player. The logical client runs in the Render Thread , though often several other threads are spawned to handle things like audio and chunk render batching. In the MinecraftForge codebase, the physical side is represented by an enum called Dist , while the logical side is represented by an enum called LogicalSide .","title":"Different Kinds of Sides"},{"location":"concepts/sides/#performing-side-specific-operations","text":"","title":"Performing Side-Specific Operations"},{"location":"concepts/sides/#levelisclientside","text":"This boolean check will be your most used way to check sides. Querying this field on a Level object establishes the logical side the level belongs to. That is, if this field is true , the level is currently running on the logical client. If the field is false , the level is running on the logical server. It follows that the physical server will always contain false in this field, but we cannot assume that false implies a physical server, since this field can also be false for the logical server inside a physical client (in other words, a single player world). Use this check whenever you need to determine if game logic and other mechanics should be run. For example, if you want to damage the player every time they click your block, or have your machine process dirt into diamonds, you should only do so after ensuring #isClientSide is false . Applying game logic to the logical client can cause desynchronization (ghost entities, desynchronized stats, etc.) in the best case, and crashes in the worst case. This check should be used as your go-to default. Aside from DistExecutor , rarely will you need the other ways of determining side and adjusting behavior.","title":"Level#isClientSide"},{"location":"concepts/sides/#distexecutor","text":"Considering the use of a single \u201cuniversal\u201d jar for client and server mods, and the separation of the physical sides into two jars, an important question comes to mind: How do we use code that is only present on one physical side? All code in net.minecraft.client is only present on the physical client, and all code in net.minecraft.server.dedicated is only present on the physical server. If any class you write references those names in any way, they will crash the game when that respective class is loaded in an environment where those names do not exist. A very common mistake in beginners is to call Minecraft.getInstance().<doStuff>() in block or block entity classes, which will crash any physical server as soon as the class is loaded. How do we resolve this? Luckily, FML has DistExecutor , which provides various methods to run different methods on different physical sides, or a single method only on one side. Note It is important to understand that FML checks based on the physical side. A single player world (logical server + logical client within a physical client) will always use Dist.CLIENT !","title":"DistExecutor"},{"location":"concepts/sides/#thread-groups","text":"If Thread.currentThread().getThreadGroup() == SidedThreadGroups.SERVER is true, it is likely the current thread is on the logical server. Otherwise, it is likely on the logical client. This is useful to retrieve the logical side when you do not have access to a Level object to check isClientSide . It guesses which logical side you are on by looking at the group of the currently running thread. Because it is a guess, this method should only be used when other options have been exhausted. In nearly every case, you should prefer checking Level#isClientSide .","title":"Thread Groups"},{"location":"concepts/sides/#fmlenvironmentdist-and-onlyin","text":"FMLEnvironment#dist holds the physical side your code is running on. Since it is determined at startup, it does not rely on guessing to return its result. The number of use cases for this is limited, however. Annotating a method or field with the @OnlyIn(Dist) annotation indicates to the loader that the respective member should be completely stripped out of the definition not on the specified physical side. Usually, these are only seen when browsing through the decompiled Minecraft code, indicating methods that the Mojang obfuscator stripped out. There is NO reason for using this annotation directly. Use DistExecutor or a check on FMLEnvironment#dist instead.","title":"FMLEnvironment#dist and @OnlyIn"},{"location":"concepts/sides/#common-mistakes","text":"","title":"Common Mistakes"},{"location":"concepts/sides/#reaching-across-logical-sides","text":"Whenever you want to send information from one logical side to another, you must always use network packets. It is incredibly tempting, when in a single player scenario, to directly transfer data from the logical server to the logical client. This is actually very commonly inadvertently done through static fields. Since the logical client and logical server share the same JVM in a single player scenario, both threads writing to and reading from static fields will cause all sorts of race conditions and the classical issues associated with threading. This mistake can also be made explicitly by accessing physical client-only classes such as Minecraft from common code that runs or can run on the logical server. This mistake is easy to miss for beginners who debug in a physical client. The code will work there, but it will immediately crash on a physical server.","title":"Reaching Across Logical Sides"},{"location":"concepts/sides/#writing-one-sided-mods","text":"In recent versions, Minecraft Forge has removed a \u201csidedness\u201d attribute from the mods.toml. This means that your mods are expected to work whether they are loaded on the physical client or the physical server. So for one-sided mods, you would typically register your event handlers inside a DistExecutor#safeRunWhenOn or DistExecutor#unsafeRunWhenOn instead of directly calling the relevant registration methods in your mod constructor. Basically, if your mod is loaded on the wrong side, it should simply do nothing, listen to no events, and so on. A one-sided mod by nature should not register blocks, items, \u2026 since they would need to be available on the other side, too. Additionally, if your mod is one-sided, it typically does not forbid the user from joining a server that is lacking that mod. Therefore, you should register an IExtensionPoint$DisplayTest extension point to make sure that Forge does not think your mod is required on the server, which would lead to the server being shown as incompatible. For that, put something similar to this into your main mod class constructor: //Make sure the mod being absent on the other network side does not cause the client to display the server as incompatible ModLoadingContext.get().registerExtensionPoint(IExtensionPoint.DisplayTest.class, () -> new IExtensionPoint.DisplayTest(() -> FMLNetworkConstants.IGNORESERVERONLY, (a, b) -> true)); This tells the client that it should ignore the server version being absent, and the server that it should not tell the client this mod should be present. So this snippet works both for client- and server-only-sided mods.","title":"Writing One-Sided Mods"},{"location":"conventions/loadstages/","text":"Loading Stages The Forge loading process has four main phases. All of these events shown are fired on the mod-specific eventbus, not the global Forge event bus MinecraftForge#EVENT_BUS . Event handlers should be registered : @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().registerListener(this::commonSetup); } private void commonSetup(FMLCommonSetupEvent evt) { ... } } Warning All four of the below events are called for all mods in parallel, meaning they are all a subclass of ParallelDispatchEvent . That is, all mods will concurrently receive common setup, FML will wait for them all to finish, then all mods will concurrently receive sided setup, and so forth. Mods must take care to be thread safe, especially when calling other mods\u2019 APIs and accessing Vanilla systems, which are not thread safe in general. This can be done by calling #enqueueWork on the event parameter. Setup FMLCommonSetupEvent is the first to fire early in the Minecraft starting process. Registry events are fired before this event, so you can expect all registry objects to be valid by the time this runs. Common actions to perform in common setup are: Utilizing the common config data Registering Capabilities Sided Setup FMLClientSetupEvent and FMLDedicatedServerSetupEvent are fired after common setup, and are where physical, side-specific initialization should occur. Common actions to perform here are registering client-side only things such as key bindings. IMC Enqueue Here, mods should send messages to all other mods they are interested in integrating with, using InterModComms#sendTo . IMC Process Here, mods should process all the messages they have received from other mods and set up integrations appropriately. A mod may retrieve the messages that have been sent to it using #getIMCStream located within the event.","title":"Loadstages"},{"location":"conventions/loadstages/#loading-stages","text":"The Forge loading process has four main phases. All of these events shown are fired on the mod-specific eventbus, not the global Forge event bus MinecraftForge#EVENT_BUS . Event handlers should be registered : @Mod(\"mymod\") public class MyMod { public MyMod() { FMLModLoadingContext.get().getModEventBus().registerListener(this::commonSetup); } private void commonSetup(FMLCommonSetupEvent evt) { ... } } Warning All four of the below events are called for all mods in parallel, meaning they are all a subclass of ParallelDispatchEvent . That is, all mods will concurrently receive common setup, FML will wait for them all to finish, then all mods will concurrently receive sided setup, and so forth. Mods must take care to be thread safe, especially when calling other mods\u2019 APIs and accessing Vanilla systems, which are not thread safe in general. This can be done by calling #enqueueWork on the event parameter.","title":"Loading Stages"},{"location":"conventions/loadstages/#setup","text":"FMLCommonSetupEvent is the first to fire early in the Minecraft starting process. Registry events are fired before this event, so you can expect all registry objects to be valid by the time this runs. Common actions to perform in common setup are: Utilizing the common config data Registering Capabilities","title":"Setup"},{"location":"conventions/loadstages/#sided-setup","text":"FMLClientSetupEvent and FMLDedicatedServerSetupEvent are fired after common setup, and are where physical, side-specific initialization should occur. Common actions to perform here are registering client-side only things such as key bindings.","title":"Sided Setup"},{"location":"conventions/loadstages/#imc-enqueue","text":"Here, mods should send messages to all other mods they are interested in integrating with, using InterModComms#sendTo .","title":"IMC Enqueue"},{"location":"conventions/loadstages/#imc-process","text":"Here, mods should process all the messages they have received from other mods and set up integrations appropriately. A mod may retrieve the messages that have been sent to it using #getIMCStream located within the event.","title":"IMC Process"},{"location":"conventions/locations/","text":"Locations Minecraft expects certain parts of your project to be in certain locations, such as textures and JSONs. All locations and items covered in this page are relative to your ./src/main/resources/ folder. mods.toml The mods.toml file is in the ./META-INF/ directory. Blockstates Blockstate definition files are JSONs within ./assets/<modid>/blockstates/ folder. Localizations Localizations are JSONs named after their lowercased language code , such as en_us . They are located in the ./assets/<modid>/lang/ folder. Models Model files are JSONs located within ./assets/<modid>/models/block/ or ./assets/<modid>/models/item/ depending on whether they are for a block or an item, respectively. Textures Textures are PNGs located within ./assets/<modid>/textures/block/ or ./assets/<modid>/textures/item/ depending on whether they are for a block or an item, respectively. Recipes Recipes are JSONs located within ./data/<modid>/recipes/ .","title":"Locations"},{"location":"conventions/locations/#locations","text":"Minecraft expects certain parts of your project to be in certain locations, such as textures and JSONs. All locations and items covered in this page are relative to your ./src/main/resources/ folder.","title":"Locations"},{"location":"conventions/locations/#modstoml","text":"The mods.toml file is in the ./META-INF/ directory.","title":"mods.toml"},{"location":"conventions/locations/#blockstates","text":"Blockstate definition files are JSONs within ./assets/<modid>/blockstates/ folder.","title":"Blockstates"},{"location":"conventions/locations/#localizations","text":"Localizations are JSONs named after their lowercased language code , such as en_us . They are located in the ./assets/<modid>/lang/ folder.","title":"Localizations"},{"location":"conventions/locations/#models","text":"Model files are JSONs located within ./assets/<modid>/models/block/ or ./assets/<modid>/models/item/ depending on whether they are for a block or an item, respectively.","title":"Models"},{"location":"conventions/locations/#textures","text":"Textures are PNGs located within ./assets/<modid>/textures/block/ or ./assets/<modid>/textures/item/ depending on whether they are for a block or an item, respectively.","title":"Textures"},{"location":"conventions/locations/#recipes","text":"Recipes are JSONs located within ./data/<modid>/recipes/ .","title":"Recipes"},{"location":"conventions/versioning/","text":"Versioning In general projects, Semantic Versioning is often used (which has the format MAJOR.MINOR.PATCH ). However, in the case of modding it may be more beneficial to use the format MCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH to be able to differentiate between world-breaking and API-breaking changes of a mod. Examples Here is a list of examples that can increment the various variables. MCVERSION Always matches the Minecraft version the mod is for. MAJORMOD Removing items, blocks, block entities, etc. Changing or removing previously existing mechanics. Updating to a new Minecraft version. MAJORAPI Changing the order or variables of enums. Changing return types of methods. Removing public methods altogether. MINOR Adding items, blocks, block entities, etc. Adding new mechanics. Deprecating public methods. (This is not a MAJORAPI increment since it doesn\u2019t break an API.) PATCH Bugfixes. When incrementing any variable, all lesser variables should reset to 0 . For instance, if MINOR would increment, PATCH would become 0 . If MAJORMOD would increment, all other variables would become 0 . Work In Progress If you are in the initial development stage of your mod (before any official releases), the MAJORMOD and MAJORAPI should always be 0 . Only MINOR and PATCH should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment MAJORMOD to version 1.0.0.0 . For any further development stages, refer to the Prereleases and Release candidates section of this document. Multiple Minecraft Versions If the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the PATCH variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to both build numbers. For example, if the mod is upgraded to version 3.0.0.0 due to a Minecraft version change, the old mod should also be updated to 3.0.0.0 . The old version will become, for example, version 1.7.10-3.0.0.0 , while the new version will become 1.8-3.0.0.0 . If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same. Final Release When dropping support for a Minecraft version, the last build for that version should get the -final suffix. This denotes that the mod will no longer be supported for the denoted MCVERSION and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes. Pre-releases It is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with -betaX , where X is the number of the prerelease. (This guide does not use -pre since, at the time of writing, it is not a valid alias for -beta .) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -beta suffix. Versions before the initial release are simply work-in-progress builds. Release Candidates Release candidates act as prereleases before an actual version change. These versions should be appended with -rcX , where X is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -rc suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.","title":"Versioning"},{"location":"conventions/versioning/#versioning","text":"In general projects, Semantic Versioning is often used (which has the format MAJOR.MINOR.PATCH ). However, in the case of modding it may be more beneficial to use the format MCVERSION-MAJORMOD.MAJORAPI.MINOR.PATCH to be able to differentiate between world-breaking and API-breaking changes of a mod.","title":"Versioning"},{"location":"conventions/versioning/#examples","text":"Here is a list of examples that can increment the various variables. MCVERSION Always matches the Minecraft version the mod is for. MAJORMOD Removing items, blocks, block entities, etc. Changing or removing previously existing mechanics. Updating to a new Minecraft version. MAJORAPI Changing the order or variables of enums. Changing return types of methods. Removing public methods altogether. MINOR Adding items, blocks, block entities, etc. Adding new mechanics. Deprecating public methods. (This is not a MAJORAPI increment since it doesn\u2019t break an API.) PATCH Bugfixes. When incrementing any variable, all lesser variables should reset to 0 . For instance, if MINOR would increment, PATCH would become 0 . If MAJORMOD would increment, all other variables would become 0 .","title":"Examples"},{"location":"conventions/versioning/#work-in-progress","text":"If you are in the initial development stage of your mod (before any official releases), the MAJORMOD and MAJORAPI should always be 0 . Only MINOR and PATCH should be updated every time you build your mod. Once you build an official release (most of the time with a stable API), you should increment MAJORMOD to version 1.0.0.0 . For any further development stages, refer to the Prereleases and Release candidates section of this document.","title":"Work In Progress"},{"location":"conventions/versioning/#multiple-minecraft-versions","text":"If the mod upgrades to a new version of Minecraft, and the old version will only receive bug fixes, the PATCH variable should be updated based on the version before the upgrade. If the mod is still in active development in both the old and the new version of Minecraft, it is advised to append the version to both build numbers. For example, if the mod is upgraded to version 3.0.0.0 due to a Minecraft version change, the old mod should also be updated to 3.0.0.0 . The old version will become, for example, version 1.7.10-3.0.0.0 , while the new version will become 1.8-3.0.0.0 . If there are no changes at all when building for a newer Minecraft version, all variables except for the Minecraft version should stay the same.","title":"Multiple Minecraft Versions"},{"location":"conventions/versioning/#final-release","text":"When dropping support for a Minecraft version, the last build for that version should get the -final suffix. This denotes that the mod will no longer be supported for the denoted MCVERSION and that players should upgrade to a newer version of the mod to continue receiving updates and bug fixes.","title":"Final Release"},{"location":"conventions/versioning/#pre-releases","text":"It is also possible to prerelease work-in-progress features, which means new features are released that are not quite done yet. These can be seen as a sort of \u201cbeta\u201d. These versions should be appended with -betaX , where X is the number of the prerelease. (This guide does not use -pre since, at the time of writing, it is not a valid alias for -beta .) Note that already released versions and versions before the initial release can not go into prerelease; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -beta suffix. Versions before the initial release are simply work-in-progress builds.","title":"Pre-releases"},{"location":"conventions/versioning/#release-candidates","text":"Release candidates act as prereleases before an actual version change. These versions should be appended with -rcX , where X is the number of the release candidate which should, in theory, only be increased for bugfixes. Already released versions can not receive release candidates; variables (mostly MINOR , but MAJORAPI and MAJORMOD can also prerelease) should be updated accordingly before adding the -rc suffix. When releasing a release candidate as stable build, it can either be exactly the same as the last release candidate or have a few more bug fixes.","title":"Release Candidates"},{"location":"datagen/intro/","text":"Data Generators Data generators are a way to programmatically generate the assets and data of mods. It allows the definition of the contents of these files in the code and their automatic generation, without worrying about the specifics. The data generator system is loaded by the main class net.minecraft.data.Main . Different command-line arguments can be passed to customize which mods\u2019 data are gathered, what existing files are considered, etc. The class responsible for data generation is net.minecraft.data.DataGenerator . The default configurations in the MDK build.gradle adds the runData task for running the data generators. Generator Modes The data generator can be configured to run 4 different data generations, which are configured from the command-line parameters, and can be checked from GatherDataEvent#include*** methods. Client Assets Generates client-only files in assets : block/item models, blockstate JSONs, language files, etc. --client , includeClient() Server Data Generates server-only files in data : recipes, advancements, tags, etc. --server , includeServer() Development Tools Runs some development tools: converting SNBT to NBT and vice-versa, etc. --dev , includeDev() Reports Dumps all registered blocks, items, commands, etc. --reports , includeReports() Data Providers Data providers are the classes that actually define what data will be generated and provided. All data providers implement DataProvider . Minecraft has abstract implementations for most assets and data, so modders need only to extend and override the specified method. The GatherDataEvent is fired on the mod event bus when the data generator is being created, and the DataGenerator can be obtained from the event. Create and register data providers using DataGenerator#addProvider . Client Assets net.minecraftforge.common.data.LanguageProvider - for language strings; override #addTranslations ModelProvider<?> - base class for all model providers These classes are under the net.minecraftforge.client.model.generators package ItemModelProvider - for item models; override #registerModels BlockStateProvider - for blockstates and their block and item models; override #registerStatesAndModels BlockModelProvider - for block models; override #registerModels net.minecraftforge.common.data.SoundDefinitionsProvider - for the sounds.json Server Data net.minecraftforge.common.data.GlobalLootModifierProvider - for global loot modifiers ; override #start These classes are under the net.minecraft.data package LootTableProvider - for loot tables; override #getTables RecipeProvider - for recipes and their unlocking advancements; override #buildShapelessRecipes TagsProvider - for tags; override #addTags Notes An AdvancementProvider class does exist, however it is hardcoded for only the vanilla advancements.","title":"Introduction"},{"location":"datagen/intro/#data-generators","text":"Data generators are a way to programmatically generate the assets and data of mods. It allows the definition of the contents of these files in the code and their automatic generation, without worrying about the specifics. The data generator system is loaded by the main class net.minecraft.data.Main . Different command-line arguments can be passed to customize which mods\u2019 data are gathered, what existing files are considered, etc. The class responsible for data generation is net.minecraft.data.DataGenerator . The default configurations in the MDK build.gradle adds the runData task for running the data generators.","title":"Data Generators"},{"location":"datagen/intro/#generator-modes","text":"The data generator can be configured to run 4 different data generations, which are configured from the command-line parameters, and can be checked from GatherDataEvent#include*** methods. Client Assets Generates client-only files in assets : block/item models, blockstate JSONs, language files, etc. --client , includeClient() Server Data Generates server-only files in data : recipes, advancements, tags, etc. --server , includeServer() Development Tools Runs some development tools: converting SNBT to NBT and vice-versa, etc. --dev , includeDev() Reports Dumps all registered blocks, items, commands, etc. --reports , includeReports()","title":"Generator Modes"},{"location":"datagen/intro/#data-providers","text":"Data providers are the classes that actually define what data will be generated and provided. All data providers implement DataProvider . Minecraft has abstract implementations for most assets and data, so modders need only to extend and override the specified method. The GatherDataEvent is fired on the mod event bus when the data generator is being created, and the DataGenerator can be obtained from the event. Create and register data providers using DataGenerator#addProvider .","title":"Data Providers"},{"location":"datagen/intro/#client-assets","text":"net.minecraftforge.common.data.LanguageProvider - for language strings; override #addTranslations ModelProvider<?> - base class for all model providers These classes are under the net.minecraftforge.client.model.generators package ItemModelProvider - for item models; override #registerModels BlockStateProvider - for blockstates and their block and item models; override #registerStatesAndModels BlockModelProvider - for block models; override #registerModels net.minecraftforge.common.data.SoundDefinitionsProvider - for the sounds.json","title":"Client Assets"},{"location":"datagen/intro/#server-data","text":"net.minecraftforge.common.data.GlobalLootModifierProvider - for global loot modifiers ; override #start These classes are under the net.minecraft.data package LootTableProvider - for loot tables; override #getTables RecipeProvider - for recipes and their unlocking advancements; override #buildShapelessRecipes TagsProvider - for tags; override #addTags Notes An AdvancementProvider class does exist, however it is hardcoded for only the vanilla advancements.","title":"Server Data"},{"location":"datagen/modelproviders/","text":"Model Providers The model providers are a specific type of data generators for defining models. All model providers are a subclass of ModelProvider . ModelProvider provides methods to define models for blocks and items alike: cubes, single textures, doors, slabs, and even custom non-data-generated models as parent models. Existing Files All references to textures or other data files not generated for data generation must reference existing files on the system. This is to ensure that all referenced textures are in the correct places, so typos can be found and corrected. ExistingFileHelper is the class responsible for validating the existence of those data files. An instance can be retrieved from GatherDataEvent#getExistingFileHelper() . The --existing <folderpath> argument allows the specified folder and its subfolders to be used when validating the existence of files. By default, only the vanilla datapack and resources are available to the ExistingFileHelper . Implementation There are three main abstract implementations of ModelProvider : ItemModelProvider , BlockModelProvider , and BlockStateProvider . For items, use ItemModelProvider to define their models: override #generateModels and use the helper methods. For blocks, it is recommended to use BlockStateProvider to define the blockstates, models, and their item models in a single class. It contains an instance of both BlockModelProvider and ItemModelProvider , which can be accessed through #models() and #itemModels() . BlockModelProvider is used to define only block models. Call #getVariantBuilder(Block) to get a VariantBlockStateBuilder for building a blockstate with different variants, or #getMultipartBuilder(Block) to get a MultiPartBlockStateBuilder for building a blockstate using multiparts.","title":"Model Providers"},{"location":"datagen/modelproviders/#model-providers","text":"The model providers are a specific type of data generators for defining models. All model providers are a subclass of ModelProvider . ModelProvider provides methods to define models for blocks and items alike: cubes, single textures, doors, slabs, and even custom non-data-generated models as parent models.","title":"Model Providers"},{"location":"datagen/modelproviders/#existing-files","text":"All references to textures or other data files not generated for data generation must reference existing files on the system. This is to ensure that all referenced textures are in the correct places, so typos can be found and corrected. ExistingFileHelper is the class responsible for validating the existence of those data files. An instance can be retrieved from GatherDataEvent#getExistingFileHelper() . The --existing <folderpath> argument allows the specified folder and its subfolders to be used when validating the existence of files. By default, only the vanilla datapack and resources are available to the ExistingFileHelper .","title":"Existing Files"},{"location":"datagen/modelproviders/#implementation","text":"There are three main abstract implementations of ModelProvider : ItemModelProvider , BlockModelProvider , and BlockStateProvider . For items, use ItemModelProvider to define their models: override #generateModels and use the helper methods. For blocks, it is recommended to use BlockStateProvider to define the blockstates, models, and their item models in a single class. It contains an instance of both BlockModelProvider and ItemModelProvider , which can be accessed through #models() and #itemModels() . BlockModelProvider is used to define only block models. Call #getVariantBuilder(Block) to get a VariantBlockStateBuilder for building a blockstate with different variants, or #getMultipartBuilder(Block) to get a MultiPartBlockStateBuilder for building a blockstate using multiparts.","title":"Implementation"},{"location":"datastorage/capabilities/","text":"The Capability System Capabilities allow exposing features in a dynamic and flexible way without having to resort to directly implementing many interfaces. In general terms, each capability provides a feature in the form of an interface, a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations. Forge adds capability support to BlockEntities, Entities, ItemStacks, Levels, and LevelChunks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections. Forge-provided Capabilities Forge provides three capabilities: IItemHandler , IFluidHandler and IEnergyStorage IItemHandler exposes an interface for handling inventory slots. It can be applied to BlockEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old IInventory and ISidedInventory with an automation-friendly system. IFluidHandler exposes an interface for handling fluid inventories. It can also be applied to BlockEntities, Entities, or ItemStacks. It replaces the old IFluidHandler with a more consistent and automation-friendly system. IEnergyStorage exposes an interface for handling energy containers. It can be applied to BlockEntities, Entities, or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH. Using an Existing Capability As mentioned earlier, BlockEntities, Entities, and ItemStacks implement the capability provider feature through the ICapabilityProvider interface. This interface adds the method #getCapability , which can be used to query the capabilities present in the associated provider objects. In order to obtain a capability, you will need to refer it by its unique instance. In the case of the IItemHandler , this capability is primarily stored in CapabilityItemHandler#ITEM_HANDLER_CAPABILITY , but it is possible to get other instance references by using CapabilityManager#get static Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = CapabilityManager.get(new CapabilityToken<>(){}); When called, CapabilityManager#get provides a non-null capability for your associated type. The anonymous CapabilityToken allows Forge to keep a soft dependency system while still having the necessary generic information to get the correct capability. Important Even if you have a non-null capability available to you at all times, it does not mean the capability itself is usable or registered yet. This can be checked via Capability#isRegistered . The #getCapability method has a second parameter, of type Direction , which can be used to request the specific instance for that one face. If passed null , it can be assumed that the request comes either from within the block or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of #getCapability will correspond to a LazyOptional of the type declared in the capability passed to the method. For the Item Handler capability, this is LazyOptional<IItemHandler> . If the capability is not available for a particular provider, it will return an empty LazyOptional instead. Exposing a Capability In order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object. In the case of IItemHandler , the default implementation uses the ItemStackHandler class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about @CapabilityInject in the previous section). Once you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability and provide a LazyOptional of the interface reference. This is done by overriding the #getCapability method, and comparing the capability instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the side parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player ( Direction#UP exposing the player\u2019s helmet slot), or about the surrounding blocks in the inventory ( Direction#WEST exposing the input slot of a furnace). Do not forget to fall back to super , otherwise existing attached capabilities will stop working. Capabilities must be invalidated at the end of the provider\u2019s lifecycle via LazyOptional#invalidate . For owned BlockEntities and Entities, the LazyOptional can be invalidated within #invalidateCaps . For non-owned providers, a runnable supplying the invalidation should be passed into AttachCapabilitiesEvent#addListener . // Somewhere in your BlockEntity subclass LazyOptional<IItemHandler> inventoryHandlerLazyOptional; // Supplied instance (e.g. () -> inventoryHandler) // Ensure laziness as initialization should only happen when needed inventoryHandlerLazyOptional = LazyOptional.of(inventoryHandlerSupplier); @Override public <T> LazyOptional<T> getCapability(Capability<T> cap, Direction side) { if (cap == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return inventoryHandlerLazyOptional.cast(); } return super.getCapability(cap, side); } @Override public void invalidateCaps() { super.invalidateCaps(); inventoryHandlerLazyOptional.invalidate(); } Item s are a special case since their capability providers are stored on an ItemStack . Instead, a provider should be attached through Item#initCapabilities . This should hold your capabilities for the lifecycle of the stack. It is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps or other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game. Attaching Capabilities As mentioned, attaching capabilities to existing providers, Level s, and LevelChunk s can be done using AttachCapabilitiesEvent . The same event is used for all objects that can provide capabilities. AttachCapabilitiesEvent has 5 valid generic types providing the following events: AttachCapabilitiesEvent<Entity> : Fires only for entities. AttachCapabilitiesEvent<BlockEntity> : Fires only for block entities. AttachCapabilitiesEvent<ItemStack> : Fires only for item stacks. AttachCapabilitiesEvent<Level> : Fires only for levels. AttachCapabilitiesEvent<LevelChunk> : Fires only for level chunks. The generic type cannot be more specific than the above types. For example: If you want to attach capabilities to Player , you have to subscribe to the AttachCapabilitiesEvent<Entity> , and then determine that the provided object is an Player before attaching the capability. In all cases, the event has a method #addCapability which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement ICapabilityProvider , if the capability needs to store data persistently, it is possible to implement ICapabilitySerializable<T extends Tag> which, on top of returning the capabilities, will provide tag save/load functions. For information on how to implement ICapabilityProvider , refer to the Exposing a Capability section. Creating Your Own Capability In general terms, a capability is registered through the event RegisterCapabilitiesEvent on the mod event bus via the #register method. @SubscribeEvent public void registerCaps(RegisterCapabilitiesEvent event) { event.register(IExampleCapability.class); } Persisting LevelChunk and BlockEntity capabilities Unlike Levels, Entities, and ItemStacks, LevelChunks and BlockEntities are only written to disk when they have been marked as dirty. A capability implementation with persistent state for a LevelChunk or a BlockEntity should therefore ensure that whenever its state changes, its owner is marked as dirty. ItemStackHandler , commonly used for inventories in BlockEntities, has an overridable method void onContentsChanged(int slot) designed to be used to mark the BlockEntity as dirty. public class MyBlockEntity extends BlockEntity { private final IItemHandler inventory = new ItemStackHandler(...) { @Override protected void onContentsChanged(int slot) { super.onContentsChanged(slot); setChanged(); } } ... } Synchronizing Data with Clients By default, capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situations in which you may want to send synchronization packets, all of them optional: When the entity spawns in the level, or the block is placed, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity or block, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing network packets. Persisting across Player Deaths By default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done via PlayerEvent$Clone by reading the data from the original entity and assigning it to the new entity. In this event, the wasDead field can be used to distinguish between respawning after death and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case. Migrating from IExtendedEntityProperties Although the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. This section will explain how to convert existing IEEPs into Capabilities. This is a quick list of IEEP concepts and their Capability equivalent: Property name/id ( String ): Capability key ( ResourceLocation ) Registration ( EntityConstructing ): Attaching ( AttachCapabilitiesEvent<Entity> ), the real registration of the Capability happens during FMLCommonSetupEvent . Tag read/write methods: Does not happen automatically. Attach an ICapabilitySerializable in the event and run the read/write methods from the serializeNBT / deserializeNBT . Quick conversion guide: Convert the IEEP key/id string into a ResourceLocation (which will use your MODID as a namespace). In your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance. Change the EntityConstructing event to AttachCapabilitiesEvent , and instead of querying the IEEP, you will want to attach an ICapabilityProvider (probably ICapabilitySerializable , which allows saving/loading from a tag). Create a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.","title":"Capabilities"},{"location":"datastorage/capabilities/#the-capability-system","text":"Capabilities allow exposing features in a dynamic and flexible way without having to resort to directly implementing many interfaces. In general terms, each capability provides a feature in the form of an interface, a default implementation which can be requested, and a storage handler for at least this default implementation. The storage handler can support other implementations, but this is up to the capability implementor, so look it up in their documentation before trying to use the default storage with non-default implementations. Forge adds capability support to BlockEntities, Entities, ItemStacks, Levels, and LevelChunks, which can be exposed either by attaching them through an event or by overriding the capability methods in your own implementations of the objects. This will be explained in more detail in the following sections.","title":"The Capability System"},{"location":"datastorage/capabilities/#forge-provided-capabilities","text":"Forge provides three capabilities: IItemHandler , IFluidHandler and IEnergyStorage IItemHandler exposes an interface for handling inventory slots. It can be applied to BlockEntities (chests, machines, etc.), Entities (extra player slots, mob/creature inventories/bags), or ItemStacks (portable backpacks and such). It replaces the old IInventory and ISidedInventory with an automation-friendly system. IFluidHandler exposes an interface for handling fluid inventories. It can also be applied to BlockEntities, Entities, or ItemStacks. It replaces the old IFluidHandler with a more consistent and automation-friendly system. IEnergyStorage exposes an interface for handling energy containers. It can be applied to BlockEntities, Entities, or ItemStacks. It is based on the RedstoneFlux API by TeamCoFH.","title":"Forge-provided Capabilities"},{"location":"datastorage/capabilities/#using-an-existing-capability","text":"As mentioned earlier, BlockEntities, Entities, and ItemStacks implement the capability provider feature through the ICapabilityProvider interface. This interface adds the method #getCapability , which can be used to query the capabilities present in the associated provider objects. In order to obtain a capability, you will need to refer it by its unique instance. In the case of the IItemHandler , this capability is primarily stored in CapabilityItemHandler#ITEM_HANDLER_CAPABILITY , but it is possible to get other instance references by using CapabilityManager#get static Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = CapabilityManager.get(new CapabilityToken<>(){}); When called, CapabilityManager#get provides a non-null capability for your associated type. The anonymous CapabilityToken allows Forge to keep a soft dependency system while still having the necessary generic information to get the correct capability. Important Even if you have a non-null capability available to you at all times, it does not mean the capability itself is usable or registered yet. This can be checked via Capability#isRegistered . The #getCapability method has a second parameter, of type Direction , which can be used to request the specific instance for that one face. If passed null , it can be assumed that the request comes either from within the block or from some place where the side has no meaning, such as a different dimension. In this case a general capability instance that does not care about sides will be requested instead. The return type of #getCapability will correspond to a LazyOptional of the type declared in the capability passed to the method. For the Item Handler capability, this is LazyOptional<IItemHandler> . If the capability is not available for a particular provider, it will return an empty LazyOptional instead.","title":"Using an Existing Capability"},{"location":"datastorage/capabilities/#exposing-a-capability","text":"In order to expose a capability, you will first need an instance of the underlying capability type. Note that you should assign a separate instance to each object that keeps the capability, since the capability will most probably be tied to the containing object. In the case of IItemHandler , the default implementation uses the ItemStackHandler class, which has an optional argument in the constructor, to specify a number of slots. However, relying on the existence of these default implementations should be avoided, as the purpose of the capability system is to prevent loading errors in contexts where the capability is not present, so instantiation should be protected behind a check testing if the capability has been registered (see the remarks about @CapabilityInject in the previous section). Once you have your own instance of the capability interface, you will want to notify users of the capability system that you expose this capability and provide a LazyOptional of the interface reference. This is done by overriding the #getCapability method, and comparing the capability instance with the capability you are exposing. If your machine has different slots based on which side is being queried, you can test this with the side parameter. For Entities and ItemStacks, this parameter can be ignored, but it is still possible to have side as a context, such as different armor slots on a player ( Direction#UP exposing the player\u2019s helmet slot), or about the surrounding blocks in the inventory ( Direction#WEST exposing the input slot of a furnace). Do not forget to fall back to super , otherwise existing attached capabilities will stop working. Capabilities must be invalidated at the end of the provider\u2019s lifecycle via LazyOptional#invalidate . For owned BlockEntities and Entities, the LazyOptional can be invalidated within #invalidateCaps . For non-owned providers, a runnable supplying the invalidation should be passed into AttachCapabilitiesEvent#addListener . // Somewhere in your BlockEntity subclass LazyOptional<IItemHandler> inventoryHandlerLazyOptional; // Supplied instance (e.g. () -> inventoryHandler) // Ensure laziness as initialization should only happen when needed inventoryHandlerLazyOptional = LazyOptional.of(inventoryHandlerSupplier); @Override public <T> LazyOptional<T> getCapability(Capability<T> cap, Direction side) { if (cap == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) { return inventoryHandlerLazyOptional.cast(); } return super.getCapability(cap, side); } @Override public void invalidateCaps() { super.invalidateCaps(); inventoryHandlerLazyOptional.invalidate(); } Item s are a special case since their capability providers are stored on an ItemStack . Instead, a provider should be attached through Item#initCapabilities . This should hold your capabilities for the lifecycle of the stack. It is strongly suggested that direct checks in code are used to test for capabilities instead of attempting to rely on maps or other data structures, since capability tests can be done by many objects every tick, and they need to be as fast as possible in order to avoid slowing down the game.","title":"Exposing a Capability"},{"location":"datastorage/capabilities/#attaching-capabilities","text":"As mentioned, attaching capabilities to existing providers, Level s, and LevelChunk s can be done using AttachCapabilitiesEvent . The same event is used for all objects that can provide capabilities. AttachCapabilitiesEvent has 5 valid generic types providing the following events: AttachCapabilitiesEvent<Entity> : Fires only for entities. AttachCapabilitiesEvent<BlockEntity> : Fires only for block entities. AttachCapabilitiesEvent<ItemStack> : Fires only for item stacks. AttachCapabilitiesEvent<Level> : Fires only for levels. AttachCapabilitiesEvent<LevelChunk> : Fires only for level chunks. The generic type cannot be more specific than the above types. For example: If you want to attach capabilities to Player , you have to subscribe to the AttachCapabilitiesEvent<Entity> , and then determine that the provided object is an Player before attaching the capability. In all cases, the event has a method #addCapability which can be used to attach capabilities to the target object. Instead of adding capabilities themselves to the list, you add capability providers, which have the chance to return capabilities only from certain sides. While the provider only needs to implement ICapabilityProvider , if the capability needs to store data persistently, it is possible to implement ICapabilitySerializable<T extends Tag> which, on top of returning the capabilities, will provide tag save/load functions. For information on how to implement ICapabilityProvider , refer to the Exposing a Capability section.","title":"Attaching Capabilities"},{"location":"datastorage/capabilities/#creating-your-own-capability","text":"In general terms, a capability is registered through the event RegisterCapabilitiesEvent on the mod event bus via the #register method. @SubscribeEvent public void registerCaps(RegisterCapabilitiesEvent event) { event.register(IExampleCapability.class); }","title":"Creating Your Own Capability"},{"location":"datastorage/capabilities/#persisting-levelchunk-and-blockentity-capabilities","text":"Unlike Levels, Entities, and ItemStacks, LevelChunks and BlockEntities are only written to disk when they have been marked as dirty. A capability implementation with persistent state for a LevelChunk or a BlockEntity should therefore ensure that whenever its state changes, its owner is marked as dirty. ItemStackHandler , commonly used for inventories in BlockEntities, has an overridable method void onContentsChanged(int slot) designed to be used to mark the BlockEntity as dirty. public class MyBlockEntity extends BlockEntity { private final IItemHandler inventory = new ItemStackHandler(...) { @Override protected void onContentsChanged(int slot) { super.onContentsChanged(slot); setChanged(); } } ... }","title":"Persisting LevelChunk and BlockEntity capabilities"},{"location":"datastorage/capabilities/#synchronizing-data-with-clients","text":"By default, capability data is not sent to clients. In order to change this, the mods have to manage their own synchronization code using packets. There are three different situations in which you may want to send synchronization packets, all of them optional: When the entity spawns in the level, or the block is placed, you may want to share the initialization-assigned values with the clients. When the stored data changes, you may want to notify some or all of the watching clients. When a new client starts viewing the entity or block, you may want to notify it of the existing data. Refer to the Networking page for more information on implementing network packets.","title":"Synchronizing Data with Clients"},{"location":"datastorage/capabilities/#persisting-across-player-deaths","text":"By default, the capability data does not persist on death. In order to change this, the data has to be manually copied when the player entity is cloned during the respawn process. This can be done via PlayerEvent$Clone by reading the data from the original entity and assigning it to the new entity. In this event, the wasDead field can be used to distinguish between respawning after death and returning from the End. This is important because the data will already exist when returning from the End, so care has to be taken to not duplicate values in this case.","title":"Persisting across Player Deaths"},{"location":"datastorage/capabilities/#migrating-from-iextendedentityproperties","text":"Although the Capability system can do everything IEEPs (IExtendedEntityProperties) did and more, the two concepts don\u2019t fully match 1:1. This section will explain how to convert existing IEEPs into Capabilities. This is a quick list of IEEP concepts and their Capability equivalent: Property name/id ( String ): Capability key ( ResourceLocation ) Registration ( EntityConstructing ): Attaching ( AttachCapabilitiesEvent<Entity> ), the real registration of the Capability happens during FMLCommonSetupEvent . Tag read/write methods: Does not happen automatically. Attach an ICapabilitySerializable in the event and run the read/write methods from the serializeNBT / deserializeNBT . Quick conversion guide: Convert the IEEP key/id string into a ResourceLocation (which will use your MODID as a namespace). In your handler class (not the class that implements your capability interface), create a field that will hold the Capability instance. Change the EntityConstructing event to AttachCapabilitiesEvent , and instead of querying the IEEP, you will want to attach an ICapabilityProvider (probably ICapabilitySerializable , which allows saving/loading from a tag). Create a registration method if you don\u2019t have one (you may have one where you registered your IEEP\u2019s event handlers) and in it, run the capability registration function.","title":"Migrating from IExtendedEntityProperties"},{"location":"datastorage/saveddata/","text":"Saved Data The Saved Data (SD) system is an alternative to level capabilities that can attach data per level. Declaration Each SD implementation must subtype the WorldSavedData class. There are two important methods to be aware of: save : Allows the implementation to write NBT data to the level. setDirty : A method that must be called after changing the data, to notify the game that there are changes that need to be written. If not called, #save will not get called and the existing data will persist. Attaching to a Level Any SavedData is loaded and/or attached to a level dynamically. As such, if one is never created on a level, then it will not exist. SavedData s are created and loaded from the DimensionDataStorage , which can be accessed by either ServerChunkCache#getDataStorage or ServerLevel#getDataStorage . From there, you can get or create an instance of your SD by calling DimensionDataStorage#computeIfAbsent . This will attempt to get the current instance of the SD if present or create a new one and load all available data. DimensionDataStorage#computeIfAbsent takes in three arguments: a function to load NBT data into a SD and return it, a supplier to construct a new instance of the SD, and the name of the .dat file stored within the data folder for the implemented level. For example, if a SD was named \u201cexample\u201d within the Nether, then a file would be created at ./<level_folder>/DIM-1/data/example.dat and would be implemented like so: // In some class public ExampleSavedData create() { return new ExampleSavedData(); } public ExampleSavedData load(CompoundTag tag) { ExampleSavedData data = this.create(); // Load saved data return data; } // In some method within the class netherDataStorage.computeIfAbsent(this::load, this::create, \"example\"); To persist a SD across levels, a SD should be attached to the Overworld, which can be obtained from MinecraftServer#overworld . The Overworld is the only dimension that is never fully unloaded and as such makes it perfect to store multi-level data on.","title":"Saved Data"},{"location":"datastorage/saveddata/#saved-data","text":"The Saved Data (SD) system is an alternative to level capabilities that can attach data per level.","title":"Saved Data"},{"location":"datastorage/saveddata/#declaration","text":"Each SD implementation must subtype the WorldSavedData class. There are two important methods to be aware of: save : Allows the implementation to write NBT data to the level. setDirty : A method that must be called after changing the data, to notify the game that there are changes that need to be written. If not called, #save will not get called and the existing data will persist.","title":"Declaration"},{"location":"datastorage/saveddata/#attaching-to-a-level","text":"Any SavedData is loaded and/or attached to a level dynamically. As such, if one is never created on a level, then it will not exist. SavedData s are created and loaded from the DimensionDataStorage , which can be accessed by either ServerChunkCache#getDataStorage or ServerLevel#getDataStorage . From there, you can get or create an instance of your SD by calling DimensionDataStorage#computeIfAbsent . This will attempt to get the current instance of the SD if present or create a new one and load all available data. DimensionDataStorage#computeIfAbsent takes in three arguments: a function to load NBT data into a SD and return it, a supplier to construct a new instance of the SD, and the name of the .dat file stored within the data folder for the implemented level. For example, if a SD was named \u201cexample\u201d within the Nether, then a file would be created at ./<level_folder>/DIM-1/data/example.dat and would be implemented like so: // In some class public ExampleSavedData create() { return new ExampleSavedData(); } public ExampleSavedData load(CompoundTag tag) { ExampleSavedData data = this.create(); // Load saved data return data; } // In some method within the class netherDataStorage.computeIfAbsent(this::load, this::create, \"example\"); To persist a SD across levels, a SD should be attached to the Overworld, which can be obtained from MinecraftServer#overworld . The Overworld is the only dimension that is never fully unloaded and as such makes it perfect to store multi-level data on.","title":"Attaching to a Level"},{"location":"effects/particles/","text":"Particles Terminology Term Description Particle What is responsible for the rendering logic. ParticleType<?> What is registered using a unique name. ParticleOptions What contains server data that needs to be transferred to the client. ParticleProvider The factory takes in an ParticleOptions and returns a Particle . It will be registered using a unique ParticleType<?> . Different Particles You will need to have your own implementation of the Particle class which will handle the rendering of the particle. Vanilla examples will help you on how to handle rendering. This guide will not get into that and instead only discuss the logic part. Sidedness The Particle class is client only ; it does not exist on the server. This means that creating a fixed parameter particle is somewhat simpler, more on that later. However, if the particle has a parameter with dynamic values, server information is required. For example, breaking blocks create a particle effect based on the broken block\u2019s texture. This information obviously depends on the BlockState of the block, which is taken from the server. To make a particle appear, use either ClientLevel#addParticle , ClientLevel#addAlwaysVisibleParticle , or ServerLevel#sendParticles . ServerLevel#addParticle and ServerLevel#addAlwaysVisibleParticle will simply do nothing without throwing any errors. Does your particle need server data? Taking as an example a mod which adds some spells to the game: If there are 8 types of spells added with each one specific color, there is no need for server information. Each spell will have a distinct, registered ParticleType . However, if these spells can have modifiers that can affect the color in multiple ways (add/subtract red/green/blue data), then having a registry object for each combination will be tedious. In that case, server information will be required when spawning the particle to calculate the color to use. ParticleTypes Vanilla Implementation While there are a lot of different particles in vanilla, in almost all cases vanilla uses SimpleParticleType , a basic implementation of ParticleType and ParticleOptions . This implementation is used for anything that does not require server data . The only vanilla particles that do not use SimpleParticleType are redstone dust and block/item texture dependent particles. When requiring server data, a direct implementation of ParticleOptions is needed. The ParticleTypes class is very helpful to check out vanilla implementations. Seeing how vanilla implemented each particle will help better evaluate what you need. Registering ParticleType<?> is a ForgeRegistryEntry , so it is registered normally . A ParticleType needs to be registered for each distinct Particle . When using server information, only one ParticleType needs to be registered, since it will cover all cases. When opting for covering all discrete cases, multiple ParticleType s are registered all using SimpleParticleType . The difference will come in registering the ParticleProvider . ParticleProvider To tie up everything, you need to implement an ParticleProvider . One factory needs to be registered for every ParticleType you register. When covering discrete cases, you can specify a parameter in the constructor to be able to differentiate the cases. public static class Provider implements ParticleProvider<SimpleParticleType> { private final Color color; public Provider(Color color) { this.color = color; } @Nullable @Override public Particle createParticle(SimpleParticleType typeIn, ClientLevel level, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) { return new SHParticle(level, this.color, x, y, z, xSpeed, ySpeed, zSpeed); } } In the example above, a Color can be specified during registration. The downside is the colors are \u201chardcoded\u201d and can\u2019t be changed using the /particle command. However, adding a new distinct case is easy, there only needs to be a new ParticleType and the associated factory. Finally, ParticleProvider has one method, #createParticle , which returns a Particle . You can then return a new instance of your particle as shown above. If you are using a SimpleParticleType , that parameter will be unused. Registering Factories need to be added to the ParticleEngine using the ParticleFactoryRegisterEvent . At that point use: ParticleEngine#register to register your factory. It needs a ParticleType (from it, it will get the registry name) and an instance of your ParticleProvider . When registering discrete valued particles, the factory will contain the discrete information, like so pertaining to the previous example: Minecraft.getInstance().particleEngine.register(DeferredRegistration.HEART_CRYSTAL_PARTICLE.get(), new SHParticle.Provider(Color.FIREBRICK)); Minecraft.getInstance().particleEngine.register(DeferredRegistration.POWER_CRYSTAL_PARTICLE.get(), new SHParticle.Provider(Color.ROYALBLUE)); The interest in doing this is to avoid having to deal with ParticleOptions and not create multiple Particle implementations for each color. Warning If you are using an animated sprite set for your Particle with its associated JSON, you will need to register an ParticleEngine$SpriteParticleRegistration instead. Otherwise, you will throw an IllegalStateException . Important ParticleProvider is client only , like the Particle class. A way of dealing with this is using a handler class and the EventBusSubscriber annotation with a dist value.","title":"Particles"},{"location":"effects/particles/#particles","text":"","title":"Particles"},{"location":"effects/particles/#terminology","text":"Term Description Particle What is responsible for the rendering logic. ParticleType<?> What is registered using a unique name. ParticleOptions What contains server data that needs to be transferred to the client. ParticleProvider The factory takes in an ParticleOptions and returns a Particle . It will be registered using a unique ParticleType<?> .","title":"Terminology"},{"location":"effects/particles/#different-particles","text":"You will need to have your own implementation of the Particle class which will handle the rendering of the particle. Vanilla examples will help you on how to handle rendering. This guide will not get into that and instead only discuss the logic part.","title":"Different Particles"},{"location":"effects/particles/#sidedness","text":"The Particle class is client only ; it does not exist on the server. This means that creating a fixed parameter particle is somewhat simpler, more on that later. However, if the particle has a parameter with dynamic values, server information is required. For example, breaking blocks create a particle effect based on the broken block\u2019s texture. This information obviously depends on the BlockState of the block, which is taken from the server. To make a particle appear, use either ClientLevel#addParticle , ClientLevel#addAlwaysVisibleParticle , or ServerLevel#sendParticles . ServerLevel#addParticle and ServerLevel#addAlwaysVisibleParticle will simply do nothing without throwing any errors.","title":"Sidedness"},{"location":"effects/particles/#does-your-particle-need-server-data","text":"Taking as an example a mod which adds some spells to the game: If there are 8 types of spells added with each one specific color, there is no need for server information. Each spell will have a distinct, registered ParticleType . However, if these spells can have modifiers that can affect the color in multiple ways (add/subtract red/green/blue data), then having a registry object for each combination will be tedious. In that case, server information will be required when spawning the particle to calculate the color to use.","title":"Does your particle need server data?"},{"location":"effects/particles/#particletypes","text":"","title":"ParticleTypes"},{"location":"effects/particles/#vanilla-implementation","text":"While there are a lot of different particles in vanilla, in almost all cases vanilla uses SimpleParticleType , a basic implementation of ParticleType and ParticleOptions . This implementation is used for anything that does not require server data . The only vanilla particles that do not use SimpleParticleType are redstone dust and block/item texture dependent particles. When requiring server data, a direct implementation of ParticleOptions is needed. The ParticleTypes class is very helpful to check out vanilla implementations. Seeing how vanilla implemented each particle will help better evaluate what you need.","title":"Vanilla Implementation"},{"location":"effects/particles/#registering","text":"ParticleType<?> is a ForgeRegistryEntry , so it is registered normally . A ParticleType needs to be registered for each distinct Particle . When using server information, only one ParticleType needs to be registered, since it will cover all cases. When opting for covering all discrete cases, multiple ParticleType s are registered all using SimpleParticleType . The difference will come in registering the ParticleProvider .","title":"Registering"},{"location":"effects/particles/#particleprovider","text":"To tie up everything, you need to implement an ParticleProvider . One factory needs to be registered for every ParticleType you register. When covering discrete cases, you can specify a parameter in the constructor to be able to differentiate the cases. public static class Provider implements ParticleProvider<SimpleParticleType> { private final Color color; public Provider(Color color) { this.color = color; } @Nullable @Override public Particle createParticle(SimpleParticleType typeIn, ClientLevel level, double x, double y, double z, double xSpeed, double ySpeed, double zSpeed) { return new SHParticle(level, this.color, x, y, z, xSpeed, ySpeed, zSpeed); } } In the example above, a Color can be specified during registration. The downside is the colors are \u201chardcoded\u201d and can\u2019t be changed using the /particle command. However, adding a new distinct case is easy, there only needs to be a new ParticleType and the associated factory. Finally, ParticleProvider has one method, #createParticle , which returns a Particle . You can then return a new instance of your particle as shown above. If you are using a SimpleParticleType , that parameter will be unused.","title":"ParticleProvider"},{"location":"effects/particles/#registering_1","text":"Factories need to be added to the ParticleEngine using the ParticleFactoryRegisterEvent . At that point use: ParticleEngine#register to register your factory. It needs a ParticleType (from it, it will get the registry name) and an instance of your ParticleProvider . When registering discrete valued particles, the factory will contain the discrete information, like so pertaining to the previous example: Minecraft.getInstance().particleEngine.register(DeferredRegistration.HEART_CRYSTAL_PARTICLE.get(), new SHParticle.Provider(Color.FIREBRICK)); Minecraft.getInstance().particleEngine.register(DeferredRegistration.POWER_CRYSTAL_PARTICLE.get(), new SHParticle.Provider(Color.ROYALBLUE)); The interest in doing this is to avoid having to deal with ParticleOptions and not create multiple Particle implementations for each color. Warning If you are using an animated sprite set for your Particle with its associated JSON, you will need to register an ParticleEngine$SpriteParticleRegistration instead. Otherwise, you will throw an IllegalStateException . Important ParticleProvider is client only , like the Particle class. A way of dealing with this is using a handler class and the EventBusSubscriber annotation with a dist value.","title":"Registering"},{"location":"effects/sounds/","text":"Sounds Terminology Term Description Sound Events Something that triggers a sound effect. Examples include minecraft:block.anvil.hit or botania:spreader_fire . Sound Category The category of the sound, for example player , block or simply master . The sliders in the sound settings GUI represent these categories. Sound File The literal file on disk that is played: an .ogg file. sounds.json This JSON defines sound events, and defines which sound files they play, the subtitle, etc. Sound events are identified with ResourceLocation s. sounds.json should be located at the root of a resource namespace ( assets/<namespace>/sounds.json ), and it defines sound events in that namespace ( assets/<namespace>/sounds.json defines sound events in the namespace namespace .). A full specification is available on the vanilla wiki , but this example highlights the important parts: { \"open_chest\": { \"subtitle\": \"mymod.subtitle.open_chest\", \"sounds\": [ \"mymod:open_chest_sound_file\" ] }, \"epic_music\": { \"sounds\": [ { \"name\": \"mymod:music/epic_music\", \"stream\": true } ] } } Underneath the top-level object, each key corresponds to a sound event. Note that the namespace is not given, as it is taken from the namespace of the JSON itself. Each event specifies a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified, the game will randomly choose one to play whenever the sound event is triggered. The two examples represent two different ways to specify a sound file. The wiki has precise details, but generally, long sound files such as background music or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but to stream it from disk. The second form can also specify the volume, pitch, and weight of a sound file. In all cases, the path to a sound file for namespace namespace and path path is assets/<namespace>/sounds/<path>.ogg . Therefore mymod:open_chest_sound_file points to assets/mymod/sounds/open_chest_sound_file.ogg , and mymod:music/epic_music points to assets/mymod/sounds/music/epic_music.ogg . Creating Sound Events In order to actually be able to play sounds, a SoundEvent corresponding to an entry in sounds.json must be created. This SoundEvent must then be registered . Normally, the location used to create a sound event should be set as it\u2019s registry name. The SoundEvent acts as a reference to the sound and is passed around to play them. If a mod has an API, it should expose its SoundEvent s in the API. Playing Sounds Vanilla has lots of methods for playing sounds, and it is unclear which to use at times. Note that each takes a SoundEvent , the ones registered above. Additionally, the terms \u201cServer Behavior\u201d and \u201cClient Behavior\u201d refer to the respective logical side . Level playSound(Player, BlockPos, SoundEvent, SoundCategory, volume, pitch) Simply forwards to overload (2) , adding 0.5 to each coordinate of the BlockPos given. playSound(Player, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch) Client Behavior : If the passed in player is the client player, plays the sound event to the client player. Server Behavior : Plays the sound event to everyone nearby except the passed in player. Player can be null . Usage : The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time: the logical client handles playing it to the user, and the logical server handles everyone else hearing it without re-playing it to the original user. They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a null player, thus letting everyone hear it. playLocalSound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Client Behavior : Just plays the sound event in the client level. If distanceDelay is true , then delays the sound based on how far it is from the player. Server Behavior : Does nothing. Usage : This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder. ClientLevel playLocalSound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Simply forwards to Level \u2018s overload (3) , adding 0.5 to each coordinate of the BlockPos given. Entity playSound(SoundEvent, volume, pitch) Forwards to Level \u2018s overload (2) , passing in null as the player. Client Behavior : Does nothing. Server Behavior : Plays the sound event to everyone at this entity\u2019s position. Usage : Emitting any sound from any non-player entity server-side. Player playSound(SoundEvent, volume, pitch) (overriding the one in Entity ) Forwards to Level \u2018s overload (2) , passing in this as the player. Client Behavior : Does nothing, see override in LocalPlayer . Server Behavior : Plays the sound to everyone nearby except this player. Usage : See LocalPlayer . LocalPlayer playSound(SoundEvent, volume, pitch) (overriding the one in Player ) Forwards to Level \u2018s overload (2) , passing in this as the player. Client Behavior : Just plays the Sound Event. Server Behavior : Method is client-only. Usage : Just like the ones in Level , these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.","title":"Sounds"},{"location":"effects/sounds/#sounds","text":"","title":"Sounds"},{"location":"effects/sounds/#terminology","text":"Term Description Sound Events Something that triggers a sound effect. Examples include minecraft:block.anvil.hit or botania:spreader_fire . Sound Category The category of the sound, for example player , block or simply master . The sliders in the sound settings GUI represent these categories. Sound File The literal file on disk that is played: an .ogg file.","title":"Terminology"},{"location":"effects/sounds/#soundsjson","text":"This JSON defines sound events, and defines which sound files they play, the subtitle, etc. Sound events are identified with ResourceLocation s. sounds.json should be located at the root of a resource namespace ( assets/<namespace>/sounds.json ), and it defines sound events in that namespace ( assets/<namespace>/sounds.json defines sound events in the namespace namespace .). A full specification is available on the vanilla wiki , but this example highlights the important parts: { \"open_chest\": { \"subtitle\": \"mymod.subtitle.open_chest\", \"sounds\": [ \"mymod:open_chest_sound_file\" ] }, \"epic_music\": { \"sounds\": [ { \"name\": \"mymod:music/epic_music\", \"stream\": true } ] } } Underneath the top-level object, each key corresponds to a sound event. Note that the namespace is not given, as it is taken from the namespace of the JSON itself. Each event specifies a localization key to be shown when subtitles are enabled. Finally, the actual sound files to be played are specified. Note that the value is an array; if multiple sound files are specified, the game will randomly choose one to play whenever the sound event is triggered. The two examples represent two different ways to specify a sound file. The wiki has precise details, but generally, long sound files such as background music or music discs should use the second form, because the \u201cstream\u201d argument tells Minecraft to not load the entire sound file into memory but to stream it from disk. The second form can also specify the volume, pitch, and weight of a sound file. In all cases, the path to a sound file for namespace namespace and path path is assets/<namespace>/sounds/<path>.ogg . Therefore mymod:open_chest_sound_file points to assets/mymod/sounds/open_chest_sound_file.ogg , and mymod:music/epic_music points to assets/mymod/sounds/music/epic_music.ogg .","title":"sounds.json"},{"location":"effects/sounds/#creating-sound-events","text":"In order to actually be able to play sounds, a SoundEvent corresponding to an entry in sounds.json must be created. This SoundEvent must then be registered . Normally, the location used to create a sound event should be set as it\u2019s registry name. The SoundEvent acts as a reference to the sound and is passed around to play them. If a mod has an API, it should expose its SoundEvent s in the API.","title":"Creating Sound Events"},{"location":"effects/sounds/#playing-sounds","text":"Vanilla has lots of methods for playing sounds, and it is unclear which to use at times. Note that each takes a SoundEvent , the ones registered above. Additionally, the terms \u201cServer Behavior\u201d and \u201cClient Behavior\u201d refer to the respective logical side .","title":"Playing Sounds"},{"location":"effects/sounds/#level","text":"playSound(Player, BlockPos, SoundEvent, SoundCategory, volume, pitch) Simply forwards to overload (2) , adding 0.5 to each coordinate of the BlockPos given. playSound(Player, double x, double y, double z, SoundEvent, SoundCategory, volume, pitch) Client Behavior : If the passed in player is the client player, plays the sound event to the client player. Server Behavior : Plays the sound event to everyone nearby except the passed in player. Player can be null . Usage : The correspondence between the behaviors implies that these two methods are to be called from some player-initiated code that will be run on both logical sides at the same time: the logical client handles playing it to the user, and the logical server handles everyone else hearing it without re-playing it to the original user. They can also be used to play any sound in general at any position server-side by calling it on the logical server and passing in a null player, thus letting everyone hear it. playLocalSound(double x, double y, double z, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Client Behavior : Just plays the sound event in the client level. If distanceDelay is true , then delays the sound based on how far it is from the player. Server Behavior : Does nothing. Usage : This method only works client-side, and thus is useful for sounds sent in custom packets, or other client-only effect-type sounds. Used for thunder.","title":"Level"},{"location":"effects/sounds/#clientlevel","text":"playLocalSound(BlockPos, SoundEvent, SoundCategory, volume, pitch, distanceDelay) Simply forwards to Level \u2018s overload (3) , adding 0.5 to each coordinate of the BlockPos given.","title":"ClientLevel"},{"location":"effects/sounds/#entity","text":"playSound(SoundEvent, volume, pitch) Forwards to Level \u2018s overload (2) , passing in null as the player. Client Behavior : Does nothing. Server Behavior : Plays the sound event to everyone at this entity\u2019s position. Usage : Emitting any sound from any non-player entity server-side.","title":"Entity"},{"location":"effects/sounds/#player","text":"playSound(SoundEvent, volume, pitch) (overriding the one in Entity ) Forwards to Level \u2018s overload (2) , passing in this as the player. Client Behavior : Does nothing, see override in LocalPlayer . Server Behavior : Plays the sound to everyone nearby except this player. Usage : See LocalPlayer .","title":"Player"},{"location":"effects/sounds/#localplayer","text":"playSound(SoundEvent, volume, pitch) (overriding the one in Player ) Forwards to Level \u2018s overload (2) , passing in this as the player. Client Behavior : Just plays the Sound Event. Server Behavior : Method is client-only. Usage : Just like the ones in Level , these two overrides in the player classes seem to be for code that runs together on both sides. The client handles playing the sound to the user, while the server handles everyone else hearing it without re-playing to the original user.","title":"LocalPlayer"},{"location":"events/intro/","text":"Events Forge uses an event bus that allows mods to intercept events from various Vanilla and mod behaviors. Example: An event can be used to perform an action when a Vanilla stick is right clicked. The main event bus used for most events is located at MinecraftForge#EVENT_BUS . There is another event bus for mod specific events located at FMLJavaModLoadingContext#getModEventBus that you should only use in specific cases. More information about this bus can be found below. Every event is fired on one of these busses: most events are fired on the main forge event bus, but some are fired on the mod specific event buses. An event handler is some method that has been registered to an event bus. Creating an Event Handler public class MyForgeEventHandler { @SubscribeEvent public void pickupItem(EntityItemPickupEvent event) { System.out.println(\"Item picked up!\"); } } This event handler listens for the EntityItemPickupEvent , which is, as the name states, posted to the event bus whenever an Entity picks up an item. To register this event handler, use MinecraftForge.EVENT_BUS.register(...) and pass it an instance of the class the event handler is within. If you want to register this handler to the mod specific event bus, you should use FMLJavaModLoadingContext.get().getModEventBus().register(...) instead. Static Event Handlers An event handler may also be static. The handling method is still annotated with @SubscribeEvent . The only difference from an instance handler is that it is also marked static . In order to register a static event handler, an instance of the class won\u2019t do. The Class itself has to be passed in. An example: public class MyStaticForgeEventHandler { @SubscribeEvent public static void arrowNocked(ArrowNockEvent event) { System.out.println(\"Arrow nocked!\"); } } which must be registered like this: MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class) . Automatically Registering Static Event Handlers A class may be annotated with the @Mod$EventBusSubscriber annotation. Such a class is automatically registered to MinecraftForge#EVENT_BUS when the @Mod class itself is constructed. This is essentially equivalent to adding MinecraftForge.EVENT_BUS.register(AnnotatedClass.class); at the end of the @Mod class\u2019s constructor. You can pass the bus you want to listen to the @Mod$EventBusSubscriber annotation. It is recommended you also specify the mod id, since the annotation process may not be able to figure it out, and the bus you are registering to, since it serves as a reminder to make sure you are on the correct one. You can also specify the Dist s or physical sides to load this event subscriber on. This can be used to not load client specific event subscribers on the dedicated server. An example for a static event listener listening to RenderWorldLastEvent which will only be called on the client: @Mod.EventBusSubscriber(modid = \"mymod\", bus = Bus.FORGE, value = Dist.CLIENT) public class MyStaticClientOnlyEventHandler { @SubscribeEvent public static void drawLast(RenderWorldLastEvent event) { System.out.println(\"Drawing!\"); } } Note This does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static). Canceling If an event can be canceled, it will be marked with the @Cancelable annotation, and the method Event#isCancelable() will return true . The cancel state of a cancelable event may be modified by calling Event#setCanceled(boolean canceled) , wherein passing the boolean value true is interpreted as canceling the event, and passing the boolean value false is interpreted as \u201cun-canceling\u201d the event. However, if the event cannot be canceled (as defined by Event#isCancelable() ), an UnsupportedOperationException will be thrown regardless of the passed boolean value, since the cancel state of a non-cancelable event event is considered immutable. Important Not all events can be canceled! Attempting to cancel an event that is not cancelable will result in an unchecked UnsupportedOperationException being thrown, which is expected to result in the game crashing! Always check that an event can be canceled using Event#isCancelable() before attempting to cancel it! Results Some events have an Event$Result . A result can be one of three things: DENY which stops the event, DEFAULT which uses the Vanilla behavior, and ALLOW which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling #setResult with an Event$Result on the event. Not all events have results; an event with a result will be annotated with @HasResult . Important Different events may use results in different ways, refer to the event\u2019s JavaDoc before using the result. Priority Event handler methods (marked with @SubscribeEvent ) have a priority. You can set the priority of an event handler method by setting the priority value of the annotation. The priority can be any value of the EventPriority enum ( HIGHEST , HIGH , NORMAL , LOW , and LOWEST ). Event handlers with priority HIGHEST are executed first and from there in descending order until LOWEST events which are executed last. Sub Events Many events have different variations of themselves. These can be different but all based around one common factor (e.g. PlayerEvent ) or can be an event that has multiple phases (e.g. PotionBrewEvent ). Take note that if you listen to the parent event class, you will receive calls to your method for all subclasses. Mod Event Bus The mod event bus is primarily used for listening to lifecycle events in which mods should initialize. Each event on the mod bus is required to implement IModBusEvent . Many of these events are also ran in parallel so mods can be initialized at the same time. This does mean you can\u2019t directly execute code from other mods in these events. Use the InterModComms system for that. These are the four most commonly used lifecycle events that are called during mod initialization on the mod event bus: FMLCommonSetupEvent FMLClientSetupEvent & FMLDedicatedServerSetupEvent InterModEnqueueEvent InterModProcessEvent Note The FMLClientSetupEvent and FMLDedicatedServerSetupEvent are only called on their respective distribution. These four lifecycle events are all ran in parallel since they all are a subclass of ParallelDispatchEvent . If you want to run run code on the main thread during any ParallelDispatchEvent , you can use the #enqueueWork to do so. Next to the lifecycle events, there are a few miscellaneous events that are fired on the mod event bus where you can register, set up, or initialize various things. Most of these events are not ran in parallel in contrast to the lifecycle events. A few examples: ColorHandlerEvent ModelBakeEvent TextureStitchEvent RegistryEvent A good rule of thumb: events are fired on the mod event bus when they should be handled during initialization of a mod.","title":"Basic Usage"},{"location":"events/intro/#events","text":"Forge uses an event bus that allows mods to intercept events from various Vanilla and mod behaviors. Example: An event can be used to perform an action when a Vanilla stick is right clicked. The main event bus used for most events is located at MinecraftForge#EVENT_BUS . There is another event bus for mod specific events located at FMLJavaModLoadingContext#getModEventBus that you should only use in specific cases. More information about this bus can be found below. Every event is fired on one of these busses: most events are fired on the main forge event bus, but some are fired on the mod specific event buses. An event handler is some method that has been registered to an event bus.","title":"Events"},{"location":"events/intro/#creating-an-event-handler","text":"public class MyForgeEventHandler { @SubscribeEvent public void pickupItem(EntityItemPickupEvent event) { System.out.println(\"Item picked up!\"); } } This event handler listens for the EntityItemPickupEvent , which is, as the name states, posted to the event bus whenever an Entity picks up an item. To register this event handler, use MinecraftForge.EVENT_BUS.register(...) and pass it an instance of the class the event handler is within. If you want to register this handler to the mod specific event bus, you should use FMLJavaModLoadingContext.get().getModEventBus().register(...) instead.","title":"Creating an Event Handler"},{"location":"events/intro/#static-event-handlers","text":"An event handler may also be static. The handling method is still annotated with @SubscribeEvent . The only difference from an instance handler is that it is also marked static . In order to register a static event handler, an instance of the class won\u2019t do. The Class itself has to be passed in. An example: public class MyStaticForgeEventHandler { @SubscribeEvent public static void arrowNocked(ArrowNockEvent event) { System.out.println(\"Arrow nocked!\"); } } which must be registered like this: MinecraftForge.EVENT_BUS.register(MyStaticForgeEventHandler.class) .","title":"Static Event Handlers"},{"location":"events/intro/#automatically-registering-static-event-handlers","text":"A class may be annotated with the @Mod$EventBusSubscriber annotation. Such a class is automatically registered to MinecraftForge#EVENT_BUS when the @Mod class itself is constructed. This is essentially equivalent to adding MinecraftForge.EVENT_BUS.register(AnnotatedClass.class); at the end of the @Mod class\u2019s constructor. You can pass the bus you want to listen to the @Mod$EventBusSubscriber annotation. It is recommended you also specify the mod id, since the annotation process may not be able to figure it out, and the bus you are registering to, since it serves as a reminder to make sure you are on the correct one. You can also specify the Dist s or physical sides to load this event subscriber on. This can be used to not load client specific event subscribers on the dedicated server. An example for a static event listener listening to RenderWorldLastEvent which will only be called on the client: @Mod.EventBusSubscriber(modid = \"mymod\", bus = Bus.FORGE, value = Dist.CLIENT) public class MyStaticClientOnlyEventHandler { @SubscribeEvent public static void drawLast(RenderWorldLastEvent event) { System.out.println(\"Drawing!\"); } } Note This does not register an instance of the class; it registers the class itself (i.e. the event handling methods must be static).","title":"Automatically Registering Static Event Handlers"},{"location":"events/intro/#canceling","text":"If an event can be canceled, it will be marked with the @Cancelable annotation, and the method Event#isCancelable() will return true . The cancel state of a cancelable event may be modified by calling Event#setCanceled(boolean canceled) , wherein passing the boolean value true is interpreted as canceling the event, and passing the boolean value false is interpreted as \u201cun-canceling\u201d the event. However, if the event cannot be canceled (as defined by Event#isCancelable() ), an UnsupportedOperationException will be thrown regardless of the passed boolean value, since the cancel state of a non-cancelable event event is considered immutable. Important Not all events can be canceled! Attempting to cancel an event that is not cancelable will result in an unchecked UnsupportedOperationException being thrown, which is expected to result in the game crashing! Always check that an event can be canceled using Event#isCancelable() before attempting to cancel it!","title":"Canceling"},{"location":"events/intro/#results","text":"Some events have an Event$Result . A result can be one of three things: DENY which stops the event, DEFAULT which uses the Vanilla behavior, and ALLOW which forces the action to take place, regardless if it would have originally. The result of an event can be set by calling #setResult with an Event$Result on the event. Not all events have results; an event with a result will be annotated with @HasResult . Important Different events may use results in different ways, refer to the event\u2019s JavaDoc before using the result.","title":"Results"},{"location":"events/intro/#priority","text":"Event handler methods (marked with @SubscribeEvent ) have a priority. You can set the priority of an event handler method by setting the priority value of the annotation. The priority can be any value of the EventPriority enum ( HIGHEST , HIGH , NORMAL , LOW , and LOWEST ). Event handlers with priority HIGHEST are executed first and from there in descending order until LOWEST events which are executed last.","title":"Priority"},{"location":"events/intro/#sub-events","text":"Many events have different variations of themselves. These can be different but all based around one common factor (e.g. PlayerEvent ) or can be an event that has multiple phases (e.g. PotionBrewEvent ). Take note that if you listen to the parent event class, you will receive calls to your method for all subclasses.","title":"Sub Events"},{"location":"events/intro/#mod-event-bus","text":"The mod event bus is primarily used for listening to lifecycle events in which mods should initialize. Each event on the mod bus is required to implement IModBusEvent . Many of these events are also ran in parallel so mods can be initialized at the same time. This does mean you can\u2019t directly execute code from other mods in these events. Use the InterModComms system for that. These are the four most commonly used lifecycle events that are called during mod initialization on the mod event bus: FMLCommonSetupEvent FMLClientSetupEvent & FMLDedicatedServerSetupEvent InterModEnqueueEvent InterModProcessEvent Note The FMLClientSetupEvent and FMLDedicatedServerSetupEvent are only called on their respective distribution. These four lifecycle events are all ran in parallel since they all are a subclass of ParallelDispatchEvent . If you want to run run code on the main thread during any ParallelDispatchEvent , you can use the #enqueueWork to do so. Next to the lifecycle events, there are a few miscellaneous events that are fired on the mod event bus where you can register, set up, or initialize various things. Most of these events are not ran in parallel in contrast to the lifecycle events. A few examples: ColorHandlerEvent ModelBakeEvent TextureStitchEvent RegistryEvent A good rule of thumb: events are fired on the mod event bus when they should be handled during initialization of a mod.","title":"Mod Event Bus"},{"location":"forgedev/","text":"Getting Started If you have decided to contribute to Forge, you will have to take some special steps to get started with developing. A simple mod development environment will not suffice to work with Forge\u2019s codebase directly. Instead, you can use the following guide to help you with your setup and get you started with improving Forge! Forking and Cloning the Repository Like most major open source projects you will find, Forge is hosted on GitHub . If you have contributed to another project before, you will know this process already and can skip right ahead to the next section. For those who are beginners when it comes to collaboration via Git, here are two easy steps to get you started. Note This guide assumes that you already have a GitHub account set up. If you do not, visit their registration page to create an account. Furthermore, this guide is not a tutorial for git\u2019s usage. Please consult different sources first if you are struggling to get it working. Forking First of all, you have to \u201cfork\u201d the MinecraftForge repository by clicking the \u201cFork\u201d button in the upper right hand corner. If you are in an organization, select the account you want your fork to be hosted on. Forking the repository is necessary since not every GitHub user can have free access to every repository. Instead, you create a copy of the original repository to later contribute your changes via a so called Pull Request, which you will learn more about later. Cloning After forking the repository, it is time to get local access to actually make some changes. For this, you need to clone the repository onto your local machine. Using your favorite git client, simply clone your fork into a directory of your choice. As general example, here is a command line snippet that should work on all correctly configured systems and clones the repository into a directory called \u201cMinecraftForge\u201d under the current directory (note that you have to replace <User> with your username): git clone https://github.com/<User>/MinecraftForge Checking out the Correct Branch Forking and cloning the repository are the only mandatory steps to develop for Forge. However, to ease the process of creating Pull Requests for you, it is best to work with branches. It is recommended to create and check out a branch for each PR you plan to submit. This way, you can always keep around the latest changes of Forge for new PRs while you still work on older patches. After completing this step, you are ready to go and set up your development environment. Setting Up the Environment Depending on your favorite IDE, there is a different set of recommended steps you have to follow to successfully set up a development environment. Eclipse Due to the way Eclipse workspaces work, ForgeGradle can do most of the work involved to get you started with a Forge workspace. Open a terminal/command prompt and navigate to the directory of your cloned fork. Type ./gradlew setup and hit enter. Wait until ForgeGradle is done. Type ./gradlew genEclipseRuns and hit enter. Once again, wait until ForgeGradle is done. Open your Eclipse workspace and go to File -> Import -> General -> Existing Gradle Project . Browse to the repo directory for the \u201cProject root directory\u201d option in the dialog that opens. Complete the import by clicking the \u201cFinish\u201d button. That is all it takes to get you up and running with Eclipse. There is no extra steps required to get the test mods running. Simply hit \u201cRun\u201d like in any other project and select the appropriate run configuration. IntelliJ IDEA JetBrains\u2019 flagship IDE comes with great integrated support for Gradle : Forge\u2019s build system of choice. Due to some peculiarities of Minecraft mod development, however, there are additional steps required to get everything to work properly. IDEA 2021 onwards Start IntelliJ IDEA 2021. If you already have another project open, close the project with the File -> Close project option. In the projects tab of the \u201cWelcome to IntelliJ IDEA\u201d window, click the \u201cOpen\u201d button on the top right and select the MinecraftForge folder you cloned earlier. Click \u201cTrust Project\u201d if prompted. After IDEA is done importing the project and indexing its files, run the Gradle setup task. You can do this by: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks, then other and double-click the setup task (may also appear as MinecraftForge[Setup] ) found in Forge -> Tasks -> other -> setup . Generate the run configurations: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks, then other and double-click the genIntellijRuns task (may also appear as MinecraftForge[genIntellijRuns] ) found in Forge -> Tasks -> forgegradle runs -> genIntellijRuns . If you get a licensing error during build before making any changes, running the updateLicenses task may help. This task is found in Forge -> Tasks -> other as well. IDEA 2019-2020 There are a few minor differences between IDEA 2021 and these versions for setup. Import Forge\u2019s build.gradle as an IDEA project. For this, simply click Import Project from the Welcome to IntelliJ IDEA splash screen, then select the build.gradle file. After IDEA is done importing the project and indexing the files, run the Gradle setup task. Either: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks , then other and double-click the setup task (may also appear as MinecraftForge[Setup] . Or alternatively: Tap the CTRL key twice, and type gradle setup in the Run command window that pops up. You can then run Forge using the forge_client gradle task ( Tasks -> fg_runs -> forge_client ): right-click the task and select either Run or Debug as desired. IDEA older versions Versions older than 2016 will not work because they did not have the appropriate Gradle support nor support Forge development multi-project workspaces. IDEA 2016 - 2018 will work with extra manual steps required, but it is strongly recommended to update to IDEA 2019+ instead. cpw has uploaded a video for IDEA 2016.1 explaining very similar steps which will lead to a working setup. That is all there is to creating a Forge development environment in IntelliJ IDEA. However, you will not be able to run tests and debug mods included in Forge straight away. This takes some extra effort. Enabling test mods To enable the test mods coming with Forge, you will need to add the compiler output to the classpath. Again, cpw has put up a video explaining these steps for IDEA 2016.1. Build the test classes by selecting the src/main/test directory in your project view and then run Build -> Build module 'Forge_test' from the menu bar. Open the \u201cProject Structure\u201d window under File -> Project Structure . Head to the \u201cModules\u201d section and expand the Forge module. Select the Forge_test submodule and head to the \u201cPaths\u201d tab. Remember the path listed under the \u201cTest output path\u201d label and select the Forge_main submodule from the tree. Open the \u201cDependencies\u201d tab, hit the green plus button on the right-hand side, and select \u201cJARs or directories\u201d. Navigate to the path previously displayed as the Forge_test output path and confirm your selection. For the \u201cScope\u201d of this newly added dependency (currently \u201cCompile\u201d) choose \u201cRuntime\u201d, since the main code does not rely on the test code for compilation. Now that you have added the test mods to the classpath, you need to rebuild them each time you make a change, as they will not be built automatically. To do so, repeat step 1 from the above list or, in case you make changes to a single test mod file and want them to get rebuilt, simply hit Build -> Rebuild project or the corresponding keyboard shortcut (CTRL+F9 by default). Testing with existing mods You might want to test changes in Forge with an existing project. The video by cpw linked in the test mods section also covers this for IDEA 2016.1. Getting the mod to run requires similar steps to the test mod, but getting your project added to the workspace requires some additional work. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and press the green plus icon above the tree view. Select \u201cImport Module\u201d, navigate to your project\u2019s build.gradle file, and confirm your selection as well as the import settings. Close the \u201cProject Structure\u201d window by clicking the \u201cOK\u201d button. Reopen the window after IDEA is done importing the project and select your project\u2019s _main module from the tree. Open the \u201cDependencies\u201d tab, click the green plus icon on the right-hand side, and select \u201cModule dependency\u201d. In the window that just opened, select the Forge_main module. From here on, reproduce the steps from the test mods section, just with your project\u2019s _main module instead of the Forge_test one. Note You might need to remove existing dependencies from a normal development environment (mainly references to a forgeSrc JAR) or move the Forge module higher up in the dependency list. You should now be able to work with your mod using the changes you introduce to the Forge and Vanilla codebase. Making Changes and Pull Requests Once you have set up your development environment, it is time to make some changes to Forge\u2019s codebase. There are, however, some pitfalls you have to avoid when editing the project\u2019s code. The most important thing to note is that if you wish to edit Minecraft source code, you must only do so in the \u201cForge\u201d sub-project. Any changes in the \u201cClean\u201d project will mess with ForgeGradle and generating the patches. This can have disastrous consequences and might render your environment completely useless. If you wish to have a flawless experience, make sure you only edit code in the \u201cForge\u201d project! Generating Patches After you have made changes to the code base and tested them thoroughly, you may go ahead and generate patches. This is only necessary if you work on the Minecraft code base (i.e. in the \u201cForge\u201d project), but this step is vital for your changes to work elsewhere. Forge works by injecting only changed things into Vanilla Minecraft and hence needs those changes available in an appropriate format. Thankfully, ForgeGradle is capable of generating the changeset for you to commit it. To initiate the patch generation, simply run the genPatches Gradle task from your IDE or the command line. After its completion, you can commit all your changes (make sure you do not add any unnecessary files) and submit your Pull Request! Pull Requests The last step before your contribution is added to Forge is a Pull Request (PR in short). This is a formal request to incorporate your fork\u2019s changes into the live code base. Creating a PR is easy. Simply go to this GitHub page and follow the proposed steps. It is now that a good setup with branches pays off, since you are able to select precisely the changes you want to submit. Note Pull Requests are bound to rules; not every request will blindly be accepted. Follow this document to get further information and to ensure the best quality of your PR! If you want to maximize the chances of your PR getting accepted, follow these PR guidelines !","title":"Getting Started"},{"location":"forgedev/#getting-started","text":"If you have decided to contribute to Forge, you will have to take some special steps to get started with developing. A simple mod development environment will not suffice to work with Forge\u2019s codebase directly. Instead, you can use the following guide to help you with your setup and get you started with improving Forge!","title":"Getting Started"},{"location":"forgedev/#forking-and-cloning-the-repository","text":"Like most major open source projects you will find, Forge is hosted on GitHub . If you have contributed to another project before, you will know this process already and can skip right ahead to the next section. For those who are beginners when it comes to collaboration via Git, here are two easy steps to get you started. Note This guide assumes that you already have a GitHub account set up. If you do not, visit their registration page to create an account. Furthermore, this guide is not a tutorial for git\u2019s usage. Please consult different sources first if you are struggling to get it working.","title":"Forking and Cloning the Repository"},{"location":"forgedev/#forking","text":"First of all, you have to \u201cfork\u201d the MinecraftForge repository by clicking the \u201cFork\u201d button in the upper right hand corner. If you are in an organization, select the account you want your fork to be hosted on. Forking the repository is necessary since not every GitHub user can have free access to every repository. Instead, you create a copy of the original repository to later contribute your changes via a so called Pull Request, which you will learn more about later.","title":"Forking"},{"location":"forgedev/#cloning","text":"After forking the repository, it is time to get local access to actually make some changes. For this, you need to clone the repository onto your local machine. Using your favorite git client, simply clone your fork into a directory of your choice. As general example, here is a command line snippet that should work on all correctly configured systems and clones the repository into a directory called \u201cMinecraftForge\u201d under the current directory (note that you have to replace <User> with your username): git clone https://github.com/<User>/MinecraftForge","title":"Cloning"},{"location":"forgedev/#checking-out-the-correct-branch","text":"Forking and cloning the repository are the only mandatory steps to develop for Forge. However, to ease the process of creating Pull Requests for you, it is best to work with branches. It is recommended to create and check out a branch for each PR you plan to submit. This way, you can always keep around the latest changes of Forge for new PRs while you still work on older patches. After completing this step, you are ready to go and set up your development environment.","title":"Checking out the Correct Branch"},{"location":"forgedev/#setting-up-the-environment","text":"Depending on your favorite IDE, there is a different set of recommended steps you have to follow to successfully set up a development environment.","title":"Setting Up the Environment"},{"location":"forgedev/#eclipse","text":"Due to the way Eclipse workspaces work, ForgeGradle can do most of the work involved to get you started with a Forge workspace. Open a terminal/command prompt and navigate to the directory of your cloned fork. Type ./gradlew setup and hit enter. Wait until ForgeGradle is done. Type ./gradlew genEclipseRuns and hit enter. Once again, wait until ForgeGradle is done. Open your Eclipse workspace and go to File -> Import -> General -> Existing Gradle Project . Browse to the repo directory for the \u201cProject root directory\u201d option in the dialog that opens. Complete the import by clicking the \u201cFinish\u201d button. That is all it takes to get you up and running with Eclipse. There is no extra steps required to get the test mods running. Simply hit \u201cRun\u201d like in any other project and select the appropriate run configuration.","title":"Eclipse"},{"location":"forgedev/#intellij-idea","text":"JetBrains\u2019 flagship IDE comes with great integrated support for Gradle : Forge\u2019s build system of choice. Due to some peculiarities of Minecraft mod development, however, there are additional steps required to get everything to work properly.","title":"IntelliJ IDEA"},{"location":"forgedev/#idea-2021-onwards","text":"Start IntelliJ IDEA 2021. If you already have another project open, close the project with the File -> Close project option. In the projects tab of the \u201cWelcome to IntelliJ IDEA\u201d window, click the \u201cOpen\u201d button on the top right and select the MinecraftForge folder you cloned earlier. Click \u201cTrust Project\u201d if prompted. After IDEA is done importing the project and indexing its files, run the Gradle setup task. You can do this by: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks, then other and double-click the setup task (may also appear as MinecraftForge[Setup] ) found in Forge -> Tasks -> other -> setup . Generate the run configurations: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks, then other and double-click the genIntellijRuns task (may also appear as MinecraftForge[genIntellijRuns] ) found in Forge -> Tasks -> forgegradle runs -> genIntellijRuns . If you get a licensing error during build before making any changes, running the updateLicenses task may help. This task is found in Forge -> Tasks -> other as well.","title":"IDEA 2021 onwards"},{"location":"forgedev/#idea-2019-2020","text":"There are a few minor differences between IDEA 2021 and these versions for setup. Import Forge\u2019s build.gradle as an IDEA project. For this, simply click Import Project from the Welcome to IntelliJ IDEA splash screen, then select the build.gradle file. After IDEA is done importing the project and indexing the files, run the Gradle setup task. Either: Open the Gradle sidebar on the right hand side of your screen, then open the forge project tree, select Tasks , then other and double-click the setup task (may also appear as MinecraftForge[Setup] . Or alternatively: Tap the CTRL key twice, and type gradle setup in the Run command window that pops up. You can then run Forge using the forge_client gradle task ( Tasks -> fg_runs -> forge_client ): right-click the task and select either Run or Debug as desired.","title":"IDEA 2019-2020"},{"location":"forgedev/#idea-older-versions","text":"Versions older than 2016 will not work because they did not have the appropriate Gradle support nor support Forge development multi-project workspaces. IDEA 2016 - 2018 will work with extra manual steps required, but it is strongly recommended to update to IDEA 2019+ instead. cpw has uploaded a video for IDEA 2016.1 explaining very similar steps which will lead to a working setup. That is all there is to creating a Forge development environment in IntelliJ IDEA. However, you will not be able to run tests and debug mods included in Forge straight away. This takes some extra effort.","title":"IDEA older versions"},{"location":"forgedev/#enabling-test-mods","text":"To enable the test mods coming with Forge, you will need to add the compiler output to the classpath. Again, cpw has put up a video explaining these steps for IDEA 2016.1. Build the test classes by selecting the src/main/test directory in your project view and then run Build -> Build module 'Forge_test' from the menu bar. Open the \u201cProject Structure\u201d window under File -> Project Structure . Head to the \u201cModules\u201d section and expand the Forge module. Select the Forge_test submodule and head to the \u201cPaths\u201d tab. Remember the path listed under the \u201cTest output path\u201d label and select the Forge_main submodule from the tree. Open the \u201cDependencies\u201d tab, hit the green plus button on the right-hand side, and select \u201cJARs or directories\u201d. Navigate to the path previously displayed as the Forge_test output path and confirm your selection. For the \u201cScope\u201d of this newly added dependency (currently \u201cCompile\u201d) choose \u201cRuntime\u201d, since the main code does not rely on the test code for compilation. Now that you have added the test mods to the classpath, you need to rebuild them each time you make a change, as they will not be built automatically. To do so, repeat step 1 from the above list or, in case you make changes to a single test mod file and want them to get rebuilt, simply hit Build -> Rebuild project or the corresponding keyboard shortcut (CTRL+F9 by default).","title":"Enabling test mods"},{"location":"forgedev/#testing-with-existing-mods","text":"You might want to test changes in Forge with an existing project. The video by cpw linked in the test mods section also covers this for IDEA 2016.1. Getting the mod to run requires similar steps to the test mod, but getting your project added to the workspace requires some additional work. Open the \u201cProject Structure\u201d Window under File -> Project Structure . Head to the \u201cModules\u201d section and press the green plus icon above the tree view. Select \u201cImport Module\u201d, navigate to your project\u2019s build.gradle file, and confirm your selection as well as the import settings. Close the \u201cProject Structure\u201d window by clicking the \u201cOK\u201d button. Reopen the window after IDEA is done importing the project and select your project\u2019s _main module from the tree. Open the \u201cDependencies\u201d tab, click the green plus icon on the right-hand side, and select \u201cModule dependency\u201d. In the window that just opened, select the Forge_main module. From here on, reproduce the steps from the test mods section, just with your project\u2019s _main module instead of the Forge_test one. Note You might need to remove existing dependencies from a normal development environment (mainly references to a forgeSrc JAR) or move the Forge module higher up in the dependency list. You should now be able to work with your mod using the changes you introduce to the Forge and Vanilla codebase.","title":"Testing with existing mods"},{"location":"forgedev/#making-changes-and-pull-requests","text":"Once you have set up your development environment, it is time to make some changes to Forge\u2019s codebase. There are, however, some pitfalls you have to avoid when editing the project\u2019s code. The most important thing to note is that if you wish to edit Minecraft source code, you must only do so in the \u201cForge\u201d sub-project. Any changes in the \u201cClean\u201d project will mess with ForgeGradle and generating the patches. This can have disastrous consequences and might render your environment completely useless. If you wish to have a flawless experience, make sure you only edit code in the \u201cForge\u201d project!","title":"Making Changes and Pull Requests"},{"location":"forgedev/#generating-patches","text":"After you have made changes to the code base and tested them thoroughly, you may go ahead and generate patches. This is only necessary if you work on the Minecraft code base (i.e. in the \u201cForge\u201d project), but this step is vital for your changes to work elsewhere. Forge works by injecting only changed things into Vanilla Minecraft and hence needs those changes available in an appropriate format. Thankfully, ForgeGradle is capable of generating the changeset for you to commit it. To initiate the patch generation, simply run the genPatches Gradle task from your IDE or the command line. After its completion, you can commit all your changes (make sure you do not add any unnecessary files) and submit your Pull Request!","title":"Generating Patches"},{"location":"forgedev/#pull-requests","text":"The last step before your contribution is added to Forge is a Pull Request (PR in short). This is a formal request to incorporate your fork\u2019s changes into the live code base. Creating a PR is easy. Simply go to this GitHub page and follow the proposed steps. It is now that a good setup with branches pays off, since you are able to select precisely the changes you want to submit. Note Pull Requests are bound to rules; not every request will blindly be accepted. Follow this document to get further information and to ensure the best quality of your PR! If you want to maximize the chances of your PR getting accepted, follow these PR guidelines !","title":"Pull Requests"},{"location":"forgedev/prguidelines/","text":"Pull Request Guidelines Mods are built on top of Forge, but there are some things that Forge does not support, and that limits what mods can do. When modders run into something like that, they can make a change to Forge to support it, and submit that change as a Pull Request on Github. To make the best use of both your and the Forge team\u2019s time, it is recommended to follow some rough guidelines when preparing a Pull Request. The following points are the most important aspects to keep in mind when it comes to writing a good Pull Request. What Exactly is Forge? At a high level, Forge is a mod compatibility layer on top of Minecraft. Early mods edited Minecraft\u2019s code directly (like coremods do now), but they ran into conflicts with each other when they edited the same things. They also ran into issues when one mod changed behavior in ways that the other mods could not anticipate (like coremods do now), causing mysterious issues and lots of headaches. By using something like Forge, mods can centralize common changes and avoid conflicts. Forge also includes supporting structures for common mod features like Capabilities, Registries, and others that allow mods to work together better. When writing a good Forge Pull Request, you also have to know what Forge is at a lower level. There are two main types of code in Forge: Minecraft patches, and Forge code. Patches Patches are applied as direct changes to Minecraft\u2019s source code, and aim to be as minimal as possible. Every time Minecraft code changes, all the Forge patches need to be looked over carefully and applied correctly to the new code. This means that large patches that change lots of things are difficult to maintain, so Forge aims to avoid those and keep patches as small as possible. In addition to making sure the code makes sense, reviews for patches will focus on minimizing the size. There are many strategies to make small patches, and reviews will often point out better methods to do things. Forge patches often insert a single line that fires an event or a code hook, which affects the code after it if the event meets some condition. This allows most of the code to exist outside of the patch, which keeps the patch small and simple. For more detailed information about creating patches, see the GitHub wiki . Forge Code Aside from the patches, Forge code is just normal Java code. It can be event code, compatibility features, or anything else that is not directly editing Minecraft code. When Minecraft updates, Forge code has to update just like everything else. However, it is much easier because it is not directly entangled in the Minecraft code. Because this code stands on its own, there is no size restriction like there is with the patches. In addition to making sure the code makes sense, reviews will focus on making the code clean: with proper formatting and Java documentation. Explain Yourself All Pull Requests need to answer the question: why is this necessary? Any code added to Forge needs to be maintained, and more code means more potential for bugs, so solid justification is needed for adding code. A common Pull Request issue is offering no explanation, or giving cryptic examples for how the Pull Request might theoretically be used. This only delays the Pull Request process. A clear explanation for the general case is good, but also give a concrete example of how your mod needs this Pull Request. Sometimes there is better way to do what you wanted, or a way to do it without a Pull Request at all. Code changes can not be accepted until those possibilities have been completely ruled out. Show that it Works The code you submit to Forge should work perfectly, and it is up to you to convince the reviewers that it does. One of the best ways to do that is to add an example mod or JUnit test to Forge that makes use of your new code and shows it working. To set up and run a Forge Environment with the example mods, see this guide . Breaking Changes in Forge Forge cannot make changes that break the mods that depend on it. This means that Pull Requests have to ensure that they do not break binary compatibility with previous Forge versions. A change that breaks binary compatibility is called a Breaking Change. There are some exceptions to this: Forge accepts Breaking Changes at the beginning of new Minecraft versions, where Minecraft itself already causes Breaking Changes for modders. Sometimes an emergency breaking change is required outside of that time window, but it is rare and can cause dependency headaches for everyone in the modded Minecraft community. Outside of those exceptional times, Pull Requests with breaking changes are not accepted. They must be adapted to support the old behavior or wait for the next Minecraft version. Be Patient, Civil, and Empathetic When submitting Pull Requests, you will often have to survive code review and make several changes before it is the best Pull Request possible. Keep in mind that code review is not judgement against you. Bugs in your code are not personal. Nobody is perfect, and that is why we are working together. Negativity will not help. Threatening to give up on your Pull Request and write a coremod instead will just make people upset and make the modded ecosystem worse. It is important that while working together you assume the best intentions of the people who are reviewing your Pull Request and not take things personally. Review If you do your best to understand the slow and perfectionistic nature of the Pull Request process, we will do our best to understand your point of view as well. After your Pull Request has been reviewed and cleaned up to the best of everyone\u2019s ability, it will be marked for a final review by Lex, who has the final say on what is included in the project or not.","title":"PR Guidelines"},{"location":"forgedev/prguidelines/#pull-request-guidelines","text":"Mods are built on top of Forge, but there are some things that Forge does not support, and that limits what mods can do. When modders run into something like that, they can make a change to Forge to support it, and submit that change as a Pull Request on Github. To make the best use of both your and the Forge team\u2019s time, it is recommended to follow some rough guidelines when preparing a Pull Request. The following points are the most important aspects to keep in mind when it comes to writing a good Pull Request.","title":"Pull Request Guidelines"},{"location":"forgedev/prguidelines/#what-exactly-is-forge","text":"At a high level, Forge is a mod compatibility layer on top of Minecraft. Early mods edited Minecraft\u2019s code directly (like coremods do now), but they ran into conflicts with each other when they edited the same things. They also ran into issues when one mod changed behavior in ways that the other mods could not anticipate (like coremods do now), causing mysterious issues and lots of headaches. By using something like Forge, mods can centralize common changes and avoid conflicts. Forge also includes supporting structures for common mod features like Capabilities, Registries, and others that allow mods to work together better. When writing a good Forge Pull Request, you also have to know what Forge is at a lower level. There are two main types of code in Forge: Minecraft patches, and Forge code.","title":"What Exactly is Forge?"},{"location":"forgedev/prguidelines/#patches","text":"Patches are applied as direct changes to Minecraft\u2019s source code, and aim to be as minimal as possible. Every time Minecraft code changes, all the Forge patches need to be looked over carefully and applied correctly to the new code. This means that large patches that change lots of things are difficult to maintain, so Forge aims to avoid those and keep patches as small as possible. In addition to making sure the code makes sense, reviews for patches will focus on minimizing the size. There are many strategies to make small patches, and reviews will often point out better methods to do things. Forge patches often insert a single line that fires an event or a code hook, which affects the code after it if the event meets some condition. This allows most of the code to exist outside of the patch, which keeps the patch small and simple. For more detailed information about creating patches, see the GitHub wiki .","title":"Patches"},{"location":"forgedev/prguidelines/#forge-code","text":"Aside from the patches, Forge code is just normal Java code. It can be event code, compatibility features, or anything else that is not directly editing Minecraft code. When Minecraft updates, Forge code has to update just like everything else. However, it is much easier because it is not directly entangled in the Minecraft code. Because this code stands on its own, there is no size restriction like there is with the patches. In addition to making sure the code makes sense, reviews will focus on making the code clean: with proper formatting and Java documentation.","title":"Forge Code"},{"location":"forgedev/prguidelines/#explain-yourself","text":"All Pull Requests need to answer the question: why is this necessary? Any code added to Forge needs to be maintained, and more code means more potential for bugs, so solid justification is needed for adding code. A common Pull Request issue is offering no explanation, or giving cryptic examples for how the Pull Request might theoretically be used. This only delays the Pull Request process. A clear explanation for the general case is good, but also give a concrete example of how your mod needs this Pull Request. Sometimes there is better way to do what you wanted, or a way to do it without a Pull Request at all. Code changes can not be accepted until those possibilities have been completely ruled out.","title":"Explain Yourself"},{"location":"forgedev/prguidelines/#show-that-it-works","text":"The code you submit to Forge should work perfectly, and it is up to you to convince the reviewers that it does. One of the best ways to do that is to add an example mod or JUnit test to Forge that makes use of your new code and shows it working. To set up and run a Forge Environment with the example mods, see this guide .","title":"Show that it Works"},{"location":"forgedev/prguidelines/#breaking-changes-in-forge","text":"Forge cannot make changes that break the mods that depend on it. This means that Pull Requests have to ensure that they do not break binary compatibility with previous Forge versions. A change that breaks binary compatibility is called a Breaking Change. There are some exceptions to this: Forge accepts Breaking Changes at the beginning of new Minecraft versions, where Minecraft itself already causes Breaking Changes for modders. Sometimes an emergency breaking change is required outside of that time window, but it is rare and can cause dependency headaches for everyone in the modded Minecraft community. Outside of those exceptional times, Pull Requests with breaking changes are not accepted. They must be adapted to support the old behavior or wait for the next Minecraft version.","title":"Breaking Changes in Forge"},{"location":"forgedev/prguidelines/#be-patient-civil-and-empathetic","text":"When submitting Pull Requests, you will often have to survive code review and make several changes before it is the best Pull Request possible. Keep in mind that code review is not judgement against you. Bugs in your code are not personal. Nobody is perfect, and that is why we are working together. Negativity will not help. Threatening to give up on your Pull Request and write a coremod instead will just make people upset and make the modded ecosystem worse. It is important that while working together you assume the best intentions of the people who are reviewing your Pull Request and not take things personally.","title":"Be Patient, Civil, and Empathetic"},{"location":"forgedev/prguidelines/#review","text":"If you do your best to understand the slow and perfectionistic nature of the Pull Request process, we will do our best to understand your point of view as well. After your Pull Request has been reviewed and cleaned up to the best of everyone\u2019s ability, it will be marked for a final review by Lex, who has the final say on what is included in the project or not.","title":"Review"},{"location":"gettingstarted/","text":"Getting Started with Forge This is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here. From Zero to Modding Obtain a Java 16 Development Kit (JDK) and a 64-bit Java Virtual Machine (JVM). Minecraft and MinecraftForge both compile against Java 16 and as such should be used for development. Using a 32-bit JVM will result in some problems when running the below gradle tasks. You can obtain one from AdoptOpenJDK . Obtain the Mod Development Kit (MDK) from Forge\u2019s files site. Extract the downloaded MDK into an empty directory. You should see a bunch of files along with an example mod placed in src/main/java for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects. These files are: build.gradle gradlew.bat gradlew the gradle folder Move the files listed above to a new folder. This will be your mod project folder. Choose your IDE: Forge only explicitly supports developing with Eclipse, but there are additional run tasks for IntelliJ IDEA or Visual Studio Code environments. However, any environment, from Netbeans to vim/emacs, can be made to work. For both Intellij IDEA and Eclipse, their Gradle integration will handle the rest of the initial workspace setup. This includes downloading packages from Mojang, MinecraftForge, and a few other software sharing sites. For VSCode, the \u2018Gradle Tasks\u2019 plugin can be used to handle the initial workspace setup. For most, if not all, changes to the build.gradle file to take effect, Gradle will need to be invoked to re-evaluate the project. This can be done through \u2018Refresh\u2019 buttons in the Gradle panels of both of the previously mentioned IDEs. Generating IDE Launch/Run Configurations: For Eclipse, run the genEclipseRuns gradle task ( gradlew genEclipseRuns ). This will generate the Launch Configurations and download any required assets for the game to run. After this has finished, refresh your project. For IntelliJ, run the genIntellijRuns gradle task ( gradlew genIntellijRuns ). This will generate the Run Configurations and download any required assets for the game to run. If you encounter an error saying \u201cmodule not specified\u201d, you can either edit the configuration to select your \u201cmain\u201d module or specify it through the ideaModule property. For VSCode, run the genVSCodeRuns gradle task ( gradlew genVSCodeRuns ). This will generate the Launch Configurations and download any required assets for the game to run. Customizing Your Mod Information Edit the build.gradle file to customize how your mod is built (the file names, versions, and other things). Important Do not edit the buildscript {} section of the build.gradle file, its default text is necessary for ForgeGradle to function. Almost anything underneath the // Only edit below this line, the above code adds and enables the necessary things for Forge to be setup. marker can be changed. Many things can be removed and customized there as well. Simple build.gradle Customizations These customizations are highly recommended for all projects. To change the name of the file you build - edit the value of archivesBaseName to suit. To change your \u201cmaven coordinates\u201d - edit the value of group as well. To change the version number - edit the value of version . To update the run configurations - replace all occurrences of examplemod to the mod id of your mod. Migration to Mojang\u2019s Official Mappings Forge uses Mojang\u2019s Official Mappings, or MojMaps, for the forseeable future. The official mappings provide class, method, and field names. Parameters and javadocs are not provided by this mapping set. Currently, there is no guarantee that these mappings are legally safe; however, Forge has decided to adopt them in good faith since Mojang wants them to be used. You can read about Forge\u2019s stance here . Building and Testing Your Mod To build your mod, run gradlew build . This will output a file in build/libs with the name [archivesBaseName]-[version].jar . This file can be placed in the mods folder of a Forge enabled Minecraft setup or distributed. To test run your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run gradlew runClient . This will launch Minecraft from the <runDir> location along with your mod\u2019s code in any source sets specified within your run configurations. The default MDK includes the main source set, so any code written within src/main/java will be applied. You can also run a dedicated server using the server run config or via gradlew runServer . This will launch the Minecraft server with its GUI. After the first run, the server will shut down immediately until the Minecraft EULA is accepted by editing run/eula.txt . Once accepted, the server will load and can be accessed via a direct connect to localhost . Note It is always advisable to test your mod in a dedicated server environment if it is intended to run there.","title":"Home"},{"location":"gettingstarted/#getting-started-with-forge","text":"This is a simple guide to get you from nothing to a basic mod. The rest of this documentation is about where to go from here.","title":"Getting Started with Forge"},{"location":"gettingstarted/#from-zero-to-modding","text":"Obtain a Java 16 Development Kit (JDK) and a 64-bit Java Virtual Machine (JVM). Minecraft and MinecraftForge both compile against Java 16 and as such should be used for development. Using a 32-bit JVM will result in some problems when running the below gradle tasks. You can obtain one from AdoptOpenJDK . Obtain the Mod Development Kit (MDK) from Forge\u2019s files site. Extract the downloaded MDK into an empty directory. You should see a bunch of files along with an example mod placed in src/main/java for you to look at. Only a few of these files are strictly necessary for mod development, and you may reuse these files for all your projects. These files are: build.gradle gradlew.bat gradlew the gradle folder Move the files listed above to a new folder. This will be your mod project folder. Choose your IDE: Forge only explicitly supports developing with Eclipse, but there are additional run tasks for IntelliJ IDEA or Visual Studio Code environments. However, any environment, from Netbeans to vim/emacs, can be made to work. For both Intellij IDEA and Eclipse, their Gradle integration will handle the rest of the initial workspace setup. This includes downloading packages from Mojang, MinecraftForge, and a few other software sharing sites. For VSCode, the \u2018Gradle Tasks\u2019 plugin can be used to handle the initial workspace setup. For most, if not all, changes to the build.gradle file to take effect, Gradle will need to be invoked to re-evaluate the project. This can be done through \u2018Refresh\u2019 buttons in the Gradle panels of both of the previously mentioned IDEs. Generating IDE Launch/Run Configurations: For Eclipse, run the genEclipseRuns gradle task ( gradlew genEclipseRuns ). This will generate the Launch Configurations and download any required assets for the game to run. After this has finished, refresh your project. For IntelliJ, run the genIntellijRuns gradle task ( gradlew genIntellijRuns ). This will generate the Run Configurations and download any required assets for the game to run. If you encounter an error saying \u201cmodule not specified\u201d, you can either edit the configuration to select your \u201cmain\u201d module or specify it through the ideaModule property. For VSCode, run the genVSCodeRuns gradle task ( gradlew genVSCodeRuns ). This will generate the Launch Configurations and download any required assets for the game to run.","title":"From Zero to Modding"},{"location":"gettingstarted/#customizing-your-mod-information","text":"Edit the build.gradle file to customize how your mod is built (the file names, versions, and other things). Important Do not edit the buildscript {} section of the build.gradle file, its default text is necessary for ForgeGradle to function. Almost anything underneath the // Only edit below this line, the above code adds and enables the necessary things for Forge to be setup. marker can be changed. Many things can be removed and customized there as well.","title":"Customizing Your Mod Information"},{"location":"gettingstarted/#simple-buildgradle-customizations","text":"These customizations are highly recommended for all projects. To change the name of the file you build - edit the value of archivesBaseName to suit. To change your \u201cmaven coordinates\u201d - edit the value of group as well. To change the version number - edit the value of version . To update the run configurations - replace all occurrences of examplemod to the mod id of your mod.","title":"Simple build.gradle Customizations"},{"location":"gettingstarted/#migration-to-mojangs-official-mappings","text":"Forge uses Mojang\u2019s Official Mappings, or MojMaps, for the forseeable future. The official mappings provide class, method, and field names. Parameters and javadocs are not provided by this mapping set. Currently, there is no guarantee that these mappings are legally safe; however, Forge has decided to adopt them in good faith since Mojang wants them to be used. You can read about Forge\u2019s stance here .","title":"Migration to Mojang's Official Mappings"},{"location":"gettingstarted/#building-and-testing-your-mod","text":"To build your mod, run gradlew build . This will output a file in build/libs with the name [archivesBaseName]-[version].jar . This file can be placed in the mods folder of a Forge enabled Minecraft setup or distributed. To test run your mod, the easiest way is to use the run configs that were generated when you set up your project. Otherwise, you can run gradlew runClient . This will launch Minecraft from the <runDir> location along with your mod\u2019s code in any source sets specified within your run configurations. The default MDK includes the main source set, so any code written within src/main/java will be applied. You can also run a dedicated server using the server run config or via gradlew runServer . This will launch the Minecraft server with its GUI. After the first run, the server will shut down immediately until the Minecraft EULA is accepted by editing run/eula.txt . Once accepted, the server will load and can be accessed via a direct connect to localhost . Note It is always advisable to test your mod in a dedicated server environment if it is intended to run there.","title":"Building and Testing Your Mod"},{"location":"gettingstarted/autoupdate/","text":"Forge Update Checker Forge provides a very lightweight, opt-in, update-checking framework. If any mods have an available update, it will show a flashing icon on the \u2018Mods\u2019 button of the main menu and mod list along with the respective changelogs. It does not download updates automatically. Getting Started The first thing you want to do is specify the updateJSONURL parameter in your mods.toml file. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, GitHub, or wherever you want as long as it can be reliably reached by all users of your mod. Update JSON format The JSON itself has a relatively simple format as follows: { \"homepage\": \"<homepage/download page for your mod>\", \"<mcversion>\": { \"<modversion>\": \"<changelog for this version>\", // List all versions of your mod for the given Minecraft version, along with their changelogs ... }, \"promos\": { \"<mcversion>-latest\": \"<modversion>\", // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version \"<mcversion>-recommended\": \"<modversion>\", // Declare the latest \"stable\" version of your mod for the given Minecraft version ... } } This is fairly self-explanatory, but some notes: The link under homepage is the link the user will be shown when the mod is outdated. Forge uses an internal algorithm to determine whether one version string of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the ComparableVersion class if you are concerned about whether your scheme is supported. Adherence to semantic versioning is highly recommended. The changelog string can be separated into lines using \\n . Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes. Manually inputting data can be chore. You can configure your build.gradle to automatically update this file when building a release as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader. Some examples can be found here for nocubes , Corail Tombstone and Chisels & Bits 2 . Retrieving Update Check Results You can retrieve the results of the Forge Update Checker using VersionChecker#getResult(IModInfo) . You can obtain your IModInfo via ModContainer#getModInfo . You can get your ModContainer using ModLoadingContext.get().getActiveContainer() inside your constructor, ModList.get().getModContainerById(<your modId>) , or ModList.get().getModContainerByObject(<your mod instance>) . You can obtain any other mod\u2019s ModContainer using ModList.get().getModContainerById(<modId>) . The returned object has a field status which indicates the status of the version check. Status Description FAILED The version checker could not connect to the URL provided. UP_TO_DATE The current version is equal to or newer than the latest stable version. OUTDATED There is a new stable version. BETA_OUTDATED There is a new unstable version. BETA The current version is equal to or newer than the latest unstable version. PENDING The result requested has not finished yet, so you should try again in a little bit. The returned object will also have the target version and any changelog lines as specified in update.json .","title":"Forge Update Checker"},{"location":"gettingstarted/autoupdate/#forge-update-checker","text":"Forge provides a very lightweight, opt-in, update-checking framework. If any mods have an available update, it will show a flashing icon on the \u2018Mods\u2019 button of the main menu and mod list along with the respective changelogs. It does not download updates automatically.","title":"Forge Update Checker"},{"location":"gettingstarted/autoupdate/#getting-started","text":"The first thing you want to do is specify the updateJSONURL parameter in your mods.toml file. The value of this parameter should be a valid URL pointing to an update JSON file. This file can be hosted on your own web server, GitHub, or wherever you want as long as it can be reliably reached by all users of your mod.","title":"Getting Started"},{"location":"gettingstarted/autoupdate/#update-json-format","text":"The JSON itself has a relatively simple format as follows: { \"homepage\": \"<homepage/download page for your mod>\", \"<mcversion>\": { \"<modversion>\": \"<changelog for this version>\", // List all versions of your mod for the given Minecraft version, along with their changelogs ... }, \"promos\": { \"<mcversion>-latest\": \"<modversion>\", // Declare the latest \"bleeding-edge\" version of your mod for the given Minecraft version \"<mcversion>-recommended\": \"<modversion>\", // Declare the latest \"stable\" version of your mod for the given Minecraft version ... } } This is fairly self-explanatory, but some notes: The link under homepage is the link the user will be shown when the mod is outdated. Forge uses an internal algorithm to determine whether one version string of your mod is \u201cnewer\u201d than another. Most versioning schemes should be compatible, but see the ComparableVersion class if you are concerned about whether your scheme is supported. Adherence to semantic versioning is highly recommended. The changelog string can be separated into lines using \\n . Some prefer to include a abbreviated changelog, then link to an external site that provides a full listing of changes. Manually inputting data can be chore. You can configure your build.gradle to automatically update this file when building a release as Groovy has native JSON parsing support. Doing this is left as an exercise to the reader. Some examples can be found here for nocubes , Corail Tombstone and Chisels & Bits 2 .","title":"Update JSON format"},{"location":"gettingstarted/autoupdate/#retrieving-update-check-results","text":"You can retrieve the results of the Forge Update Checker using VersionChecker#getResult(IModInfo) . You can obtain your IModInfo via ModContainer#getModInfo . You can get your ModContainer using ModLoadingContext.get().getActiveContainer() inside your constructor, ModList.get().getModContainerById(<your modId>) , or ModList.get().getModContainerByObject(<your mod instance>) . You can obtain any other mod\u2019s ModContainer using ModList.get().getModContainerById(<modId>) . The returned object has a field status which indicates the status of the version check. Status Description FAILED The version checker could not connect to the URL provided. UP_TO_DATE The current version is equal to or newer than the latest stable version. OUTDATED There is a new stable version. BETA_OUTDATED There is a new unstable version. BETA The current version is equal to or newer than the latest unstable version. PENDING The result requested has not finished yet, so you should try again in a little bit. The returned object will also have the target version and any changelog lines as specified in update.json .","title":"Retrieving Update Check Results"},{"location":"gettingstarted/debugprofiler/","text":"Debug Profiler Minecraft provides a Debug Profiler that provides system data, current game settings, JVM data, level data, and sided tick information to find time consuming code. Considering things like TickEvent s and ticking BlockEntities , this can be very useful for modders and server owners that want to find a lag source. Using the Debug Profiler The Debug Profiler is very simple to use. It requires the debug keybind F3 + L to start the profiler. After 10 seconds, it will automatically stop; however, it can be stopped earlier by pressing the keybind again. Note Naturally, you can only profile code paths that are actually being reached. Entities and BlockEntities that you want to profile must exist in the level to show up in the results. After you have stopped the debugger, it will create a new zip within the debug/profiling subdirectory in your run directory. The file name will be formatted with the date and time as yyyy-mm-dd_hh_mi_ss-WorldName-VersionNumber.zip Reading a Profiling result Within each sided folder ( client and server ), you will find a profiling.txt file containing the result data. At the top, it first tells you how long in milliseconds it was running and how many ticks ran in that time. Below that, you will find information similar to the snippet below: [00] levels - 96.70%/96.70% [01] | Level Name - 99.76%/96.47% [02] | | tick - 99.31%/95.81% [03] | | | entities - 47.72%/45.72% [04] | | | | regular - 98.32%/44.95% [04] | | | | blockEntities - 0.90%/0.41% [05] | | | | | unspecified - 64.26%/0.26% [05] | | | | | minecraft:furnace - 33.35%/0.14% [05] | | | | | minecraft:chest - 2.39%/0.01% Here is a small explanation of what each part means [02] tick 99.31% 95.81% The Depth of the section The Name of the Section The percentage of time it took in relation to it\u2019s parent. For Layer 0, it is the percentage of the time a tick takes. For Layer 1, it is the percentage of the time its parent takes. The second percentage tells you how much time it took from the entire tick. Profiling your own code The Debug Profiler has basic support for Entity and BlockEntity . If you would like to profile something else, you may need to manually create your sections like so: ProfilerFiller#push(yourSectionName : String); //The code you want to profile ProfilerFiller#pop(); You can obtain the ProfilerFiller instance from a Level , MinecraftServer , or Minecraft instance. Now you just need to search the results file for your section name.","title":"Debug Profiler"},{"location":"gettingstarted/debugprofiler/#debug-profiler","text":"Minecraft provides a Debug Profiler that provides system data, current game settings, JVM data, level data, and sided tick information to find time consuming code. Considering things like TickEvent s and ticking BlockEntities , this can be very useful for modders and server owners that want to find a lag source.","title":"Debug Profiler"},{"location":"gettingstarted/debugprofiler/#using-the-debug-profiler","text":"The Debug Profiler is very simple to use. It requires the debug keybind F3 + L to start the profiler. After 10 seconds, it will automatically stop; however, it can be stopped earlier by pressing the keybind again. Note Naturally, you can only profile code paths that are actually being reached. Entities and BlockEntities that you want to profile must exist in the level to show up in the results. After you have stopped the debugger, it will create a new zip within the debug/profiling subdirectory in your run directory. The file name will be formatted with the date and time as yyyy-mm-dd_hh_mi_ss-WorldName-VersionNumber.zip","title":"Using the Debug Profiler"},{"location":"gettingstarted/debugprofiler/#reading-a-profiling-result","text":"Within each sided folder ( client and server ), you will find a profiling.txt file containing the result data. At the top, it first tells you how long in milliseconds it was running and how many ticks ran in that time. Below that, you will find information similar to the snippet below: [00] levels - 96.70%/96.70% [01] | Level Name - 99.76%/96.47% [02] | | tick - 99.31%/95.81% [03] | | | entities - 47.72%/45.72% [04] | | | | regular - 98.32%/44.95% [04] | | | | blockEntities - 0.90%/0.41% [05] | | | | | unspecified - 64.26%/0.26% [05] | | | | | minecraft:furnace - 33.35%/0.14% [05] | | | | | minecraft:chest - 2.39%/0.01% Here is a small explanation of what each part means [02] tick 99.31% 95.81% The Depth of the section The Name of the Section The percentage of time it took in relation to it\u2019s parent. For Layer 0, it is the percentage of the time a tick takes. For Layer 1, it is the percentage of the time its parent takes. The second percentage tells you how much time it took from the entire tick.","title":"Reading a Profiling result"},{"location":"gettingstarted/debugprofiler/#profiling-your-own-code","text":"The Debug Profiler has basic support for Entity and BlockEntity . If you would like to profile something else, you may need to manually create your sections like so: ProfilerFiller#push(yourSectionName : String); //The code you want to profile ProfilerFiller#pop(); You can obtain the ProfilerFiller instance from a Level , MinecraftServer , or Minecraft instance. Now you just need to search the results file for your section name.","title":"Profiling your own code"},{"location":"gettingstarted/structuring/","text":"Structuring Your Mod Let us look at how to organize your mod into different files and what those files should do. Packaging Pick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use com.example as your top level package. Important If you do not own a domain, do not use it for your top level package. You can use your email, a subdomain of where you host a website, or your name/username as long as it can be unique. After the top level package (if you have one), you append a unique name for your mod, such as examplemod . In our case it will end up as com.example.examplemod . The mods.toml file Important The license field in the mods.toml is required. If it is not provided, an error will occur. See your choices at https://choosealicense.com/ This file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the \u2018Mods\u2019 button. A single info file can describe several mods. The mods.toml file is formatted as TOML , the example mods.toml file in the MDK provides comments explaining the contents of the file. It should be stored as src/main/resources/META-INF/mods.toml . A basic mods.toml , describing one mod, may look like this: # The name of the mod loader type to load - for regular FML @Mod mods it should be javafml modLoader=\"javafml\" # A version range to match for said mod loader - for regular FML @Mod it will be the forge version # Forge for 1.17.1 is version 37 loaderVersion=\"[37,)\" # The license for your mod. This is mandatory and allows for easier comprehension of your redistributive properties. # Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here. license=\"All Rights Reserved\" # A URL to refer people to when problems occur with this mod issueTrackerURL=\"github.com/MinecraftForge/MinecraftForge/issues\" # If the mods defined in this file should show as separate resource packs showAsResourcePack=false [[mods]] modId=\"examplemod\" version=\"1.0.0.0\" displayName=\"Example Mod\" updateJSONURL=\"minecraftforge.net/versions.json\" displayURL=\"minecraftforge.net\" logoFile=\"logo.png\" credits=\"I'd like to thank my mother and father.\" authors=\"Author\" description=''' Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc. ''' [[dependencies.examplemod]] modId=\"forge\" mandatory=true versionRange=\"[37,)\" ordering=\"NONE\" side=\"BOTH\" [[dependencies.examplemod]] modId=\"minecraft\" mandatory=true versionRange=\"[1.17,1.18)\" ordering=\"NONE\" side=\"BOTH\" If any string is specified as ${file.jarVersion} , Forge will replace the string with the Implementation Version specified in your jar manifest at runtime. Since the user development environment has no jar manifest to pull from, it will be NONE instead. As such, it is usually recommended to leave the version field alone. Here is a table of attributes that may be given to a mod, where mandatory means there is no default and the absence of the property causes an error. Property Type Default Description modid string mandatory The modid this file is linked to. version string mandatory The version of the mod. It should be just numbers separated by dots, ideally conforming to Forge\u2019s Semantic Versioning structure. displayName string mandatory The user-friendly name of this mod. updateJSONURL string \"\" The URL to a version JSON . displayURL string \"\" A link to the mod\u2019s homepage. logoFile string \"\" The filename of the mod\u2019s logo. It must be placed in the root resource folder, not in a subfolder. credits string \"\" A string that contains any acknowledgements you want to mention. authors string \"\" The authors of this mod. description string mandatory A description of this mod. dependencies [list] [] A list of dependencies of this mod. * All version ranges use the Maven Version Range Specification . The Mod File Generally, we will start with a file named after your mod and put into your package. This is the entry point to your mod and will contain some special indicators marking it as such. What is @Mod ? This is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. The @Mod annotation\u2019s value should match a mod id in the src/main/resources/META-INF/mods.toml file. Keeping Your Code Clean Using Sub-packages Rather than clutter up a single class and package with everything, it is recommended that you break your mod into subpackages. A common subpackage strategy has packages for common and client code, which is code that can be run on both server/client and only client, respectively. Inside the common package would go things like Items, Blocks, and Block Entities (which can each, in turn, be another subpackage). Things like Screens and Renderers would go inside the client package. Note This package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system. By keeping your code in clean subpackages, you can grow your mod much more organically. Class Naming Schemes A common class naming scheme allows easier deciphering of what a class is, and it also makes it easier for someone developing with your mod to find things. For Example: An Item called PowerRing would be in an item package, with a class name of PowerRingItem . A Block called NotDirt would be in a block package, with a class name of NotDirtBlock . Finally, a BlockEntity for a block called SuperChewer would be a block.entity or blockentity package, with a class name of SuperChewerBlockEntity . Appending your class names with what kind of object they are makes it easier to figure out what a class is or guess the class for an object.","title":"Structuring Your Mod"},{"location":"gettingstarted/structuring/#structuring-your-mod","text":"Let us look at how to organize your mod into different files and what those files should do.","title":"Structuring Your Mod"},{"location":"gettingstarted/structuring/#packaging","text":"Pick a unique package name. If you own a URL associated with your project, you can use it as your top level package. For example if you own \u201cexample.com\u201d, you may use com.example as your top level package. Important If you do not own a domain, do not use it for your top level package. You can use your email, a subdomain of where you host a website, or your name/username as long as it can be unique. After the top level package (if you have one), you append a unique name for your mod, such as examplemod . In our case it will end up as com.example.examplemod .","title":"Packaging"},{"location":"gettingstarted/structuring/#the-modstoml-file","text":"Important The license field in the mods.toml is required. If it is not provided, an error will occur. See your choices at https://choosealicense.com/ This file defines the metadata of your mod. Its information may be viewed by users from the main screen of the game through the \u2018Mods\u2019 button. A single info file can describe several mods. The mods.toml file is formatted as TOML , the example mods.toml file in the MDK provides comments explaining the contents of the file. It should be stored as src/main/resources/META-INF/mods.toml . A basic mods.toml , describing one mod, may look like this: # The name of the mod loader type to load - for regular FML @Mod mods it should be javafml modLoader=\"javafml\" # A version range to match for said mod loader - for regular FML @Mod it will be the forge version # Forge for 1.17.1 is version 37 loaderVersion=\"[37,)\" # The license for your mod. This is mandatory and allows for easier comprehension of your redistributive properties. # Review your options at https://choosealicense.com/. All rights reserved is the default copyright stance, and is thus the default here. license=\"All Rights Reserved\" # A URL to refer people to when problems occur with this mod issueTrackerURL=\"github.com/MinecraftForge/MinecraftForge/issues\" # If the mods defined in this file should show as separate resource packs showAsResourcePack=false [[mods]] modId=\"examplemod\" version=\"1.0.0.0\" displayName=\"Example Mod\" updateJSONURL=\"minecraftforge.net/versions.json\" displayURL=\"minecraftforge.net\" logoFile=\"logo.png\" credits=\"I'd like to thank my mother and father.\" authors=\"Author\" description=''' Lets you craft dirt into diamonds. This is a traditional mod that has existed for eons. It is ancient. The holy Notch created it. Jeb rainbowfied it. Dinnerbone made it upside down. Etc. ''' [[dependencies.examplemod]] modId=\"forge\" mandatory=true versionRange=\"[37,)\" ordering=\"NONE\" side=\"BOTH\" [[dependencies.examplemod]] modId=\"minecraft\" mandatory=true versionRange=\"[1.17,1.18)\" ordering=\"NONE\" side=\"BOTH\" If any string is specified as ${file.jarVersion} , Forge will replace the string with the Implementation Version specified in your jar manifest at runtime. Since the user development environment has no jar manifest to pull from, it will be NONE instead. As such, it is usually recommended to leave the version field alone. Here is a table of attributes that may be given to a mod, where mandatory means there is no default and the absence of the property causes an error. Property Type Default Description modid string mandatory The modid this file is linked to. version string mandatory The version of the mod. It should be just numbers separated by dots, ideally conforming to Forge\u2019s Semantic Versioning structure. displayName string mandatory The user-friendly name of this mod. updateJSONURL string \"\" The URL to a version JSON . displayURL string \"\" A link to the mod\u2019s homepage. logoFile string \"\" The filename of the mod\u2019s logo. It must be placed in the root resource folder, not in a subfolder. credits string \"\" A string that contains any acknowledgements you want to mention. authors string \"\" The authors of this mod. description string mandatory A description of this mod. dependencies [list] [] A list of dependencies of this mod. * All version ranges use the Maven Version Range Specification .","title":"The mods.toml file"},{"location":"gettingstarted/structuring/#the-mod-file","text":"Generally, we will start with a file named after your mod and put into your package. This is the entry point to your mod and will contain some special indicators marking it as such.","title":"The Mod File"},{"location":"gettingstarted/structuring/#what-is-mod","text":"This is an annotation indicating to the Forge Mod Loader that the class is a Mod entry point. The @Mod annotation\u2019s value should match a mod id in the src/main/resources/META-INF/mods.toml file.","title":"What is @Mod?"},{"location":"gettingstarted/structuring/#keeping-your-code-clean-using-sub-packages","text":"Rather than clutter up a single class and package with everything, it is recommended that you break your mod into subpackages. A common subpackage strategy has packages for common and client code, which is code that can be run on both server/client and only client, respectively. Inside the common package would go things like Items, Blocks, and Block Entities (which can each, in turn, be another subpackage). Things like Screens and Renderers would go inside the client package. Note This package style is only a suggestion, though it is a commonly used style. Feel free to use your own packaging system. By keeping your code in clean subpackages, you can grow your mod much more organically.","title":"Keeping Your Code Clean Using Sub-packages"},{"location":"gettingstarted/structuring/#class-naming-schemes","text":"A common class naming scheme allows easier deciphering of what a class is, and it also makes it easier for someone developing with your mod to find things. For Example: An Item called PowerRing would be in an item package, with a class name of PowerRingItem . A Block called NotDirt would be in a block package, with a class name of NotDirtBlock . Finally, a BlockEntity for a block called SuperChewer would be a block.entity or blockentity package, with a class name of SuperChewerBlockEntity . Appending your class names with what kind of object they are makes it easier to figure out what a class is or guess the class for an object.","title":"Class Naming Schemes"},{"location":"items/globallootmodifiers/","text":"Global Loot Modifiers Global Loot Modifiers are a data-driven method of handling modification of harvested drops without the need to overwrite dozens to hundreds of vanilla loot tables or to handle effects that would require interactions with another mod\u2019s loot tables without knowing what mods may be loaded. Global Loot Modifiers are also stacking, rather than last-load-wins, similar to tags. Registering a Global Loot Modifier You will need 4 things: 1. Create a global_loot_modifiers.json file at /data/forge/loot_modifiers/ . This will tell Forge about your modifiers and works similar to tags . 2. A serialized json representing your modifier. This will contain all of the data about your modification and allows data packs to tweak your effect. 3. A class that extends IGlobalLootModifier . The operational code that makes your modifier work. Most modders can extend LootModifier as it supplies base functionality. 4. Finally, the serializer for your operational class. This is registered as any other IForgeRegistryEntry . The global_loot_modifiers.json All you need to add here are the file names of your loot modifiers. The ResourceLocation specified points to data/<namespace>/loot_modifiers/<path>.json . { \"replace\": false, \"entries\": [ \"global_loot_test:silk_touch_bamboo\", \"global_loot_test:smelting\", \"global_loot_test:wheat_harvest\" ] } replace causes the cache of modifiers to be cleared fully when this asset loads (mods are loaded in an order that may be specified by a data pack). For modders, you will want to use false . Data pack makers may want to specify their overrides with true . entries is an ordered list of the modifiers that will be loaded. This means that any modifier that not listed will not be loaded, and the ones listed are their written order. This is primarily relevant to data pack makers for resolving conflicts between modifiers from separate mods. The Serialized JSON This file contains all of the potential variables related to your modifier, including the conditions that must be met prior to modifying any loot. Avoid hard-coded values wherever possible so that data pack makers can adjust balance if they wish to. { \"conditions\": [ { \"condition\": \"minecraft:match_tool\", \"predicate\": { \"item\": \"minecraft:shears\" } }, { \"condition\": \"block_state_property\", \"block\":\"minecraft:wheat\" } ], \"seedItem\": \"minecraft:wheat_seeds\", \"numSeeds\": 3, \"replacement\": \"minecraft:wheat\" } In the above example, the modification only happens if an entity harvests wheat when using shears (specified by the two conditions which are automatically AND ed together). The seedsItem and numSeeds values are then used to count how many seeds were generated by the vanilla loot table, and if matched, are substituted for an additional replacement item instead. The operation code will be shown below. conditions is the only object needed by the system specification, everything else is the mod maker\u2019s data. The LootModifier Subclass and Serializer You will also need a class that extends GlobalLootModifierSerializer<T> where T is your LootModifier subclass in order to deserialize your json data file into operational code. public class WheatSeedsConverterModifier extends LootModifier { private final int numSeedsToConvert; private final Item itemToCheck; private final Item itemReward; public WheatSeedsConverterModifier(LootItemCondition[] conditions, int numSeeds, Item itemCheck, Item reward) { super(conditions); numSeedsToConvert = numSeeds; itemToCheck = itemCheck; itemReward = reward; } @Nonnull @Override public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) { // // Additional conditions can be checked, though as much as possible should be parameterized via JSON data. // It is better to write a new ILootCondition implementation than to do things here. // int numSeeds = 0; for (ItemStack stack : generatedLoot) { if (stack.getItem() == itemToCheck) numSeeds += stack.getCount(); } if (numSeeds >= numSeedsToConvert) { generatedLoot.removeIf(x -> x.getItem() == itemToCheck); generatedLoot.add(new ItemStack(itemReward, (numSeeds / numSeedsToConvert))); numSeeds = numSeeds % numSeedsToConvert; if (numSeeds > 0) generatedLoot.add(new ItemStack(itemToCheck, numSeeds)); } return generatedLoot; } public static class Serializer extends GlobalLootModifierSerializer<WheatSeedsConverterModifier> { @Override public WheatSeedsConverterModifier read(ResourceLocation name, JsonObject object, LootItemCondition[] conditions) { int numSeeds = GsonHelper.getAsInt(object, \"numSeeds\"); Item seed = ForgeRegistries.ITEMS.getValue(new ResourceLocation((GsonHelper.getAsString(object, \"seedItem\")))); Item wheat = ForgeRegistries.ITEMS.getValue(new ResourceLocation(GsonHelper.getAsString(object, \"replacement\"))); return new WheatSeedsConverterModifier(conditions, numSeeds, seed, wheat); } @Override public JsonObject write(WheatSeedsConverterModifier instance) { JsonObject json = makeConditions(instance.conditions); json.addProperty(\"numSeeds\", instance.numSeedsToConvert); json.addProperty(\"seedItem\", ForgeRegistries.ITEMS.getKey(instance.itemToCheck).toString()); json.addProperty(\"replacement\", ForgeRegistries.ITEMS.getKey(instance.itemReward).toString()); return json; } } } The critical portion is the doApply method. This method is only called if the conditions specified return true . If so, the modder is now able to make the modifications they desire. In this case, we can see that the number of itemToCheck meets or exceeds the numSeedsToConvert before modifying the list by adding an itemReward and removing any excess itemToCheck stacks, matching the previously mentioned effects: When a wheat block is harvested with shears, if enough seeds are generated as loot, they are converted to additional wheat instead . Also take note of the read method in the serializer. The conditions are already deserialized for you and if you have no other data, simply return new MyModifier(conditions) . However, the full JsonObject is available if needed. The write method, on the other hand, is used for if you want to utilize GlobalLootModifierProvider for data generation . Additional examples can be found on the Forge Git repository, including silk touch and smelting effects.","title":"Loot Modification"},{"location":"items/globallootmodifiers/#global-loot-modifiers","text":"Global Loot Modifiers are a data-driven method of handling modification of harvested drops without the need to overwrite dozens to hundreds of vanilla loot tables or to handle effects that would require interactions with another mod\u2019s loot tables without knowing what mods may be loaded. Global Loot Modifiers are also stacking, rather than last-load-wins, similar to tags.","title":"Global Loot Modifiers"},{"location":"items/globallootmodifiers/#registering-a-global-loot-modifier","text":"You will need 4 things: 1. Create a global_loot_modifiers.json file at /data/forge/loot_modifiers/ . This will tell Forge about your modifiers and works similar to tags . 2. A serialized json representing your modifier. This will contain all of the data about your modification and allows data packs to tweak your effect. 3. A class that extends IGlobalLootModifier . The operational code that makes your modifier work. Most modders can extend LootModifier as it supplies base functionality. 4. Finally, the serializer for your operational class. This is registered as any other IForgeRegistryEntry .","title":"Registering a Global Loot Modifier"},{"location":"items/globallootmodifiers/#the-global_loot_modifiersjson","text":"All you need to add here are the file names of your loot modifiers. The ResourceLocation specified points to data/<namespace>/loot_modifiers/<path>.json . { \"replace\": false, \"entries\": [ \"global_loot_test:silk_touch_bamboo\", \"global_loot_test:smelting\", \"global_loot_test:wheat_harvest\" ] } replace causes the cache of modifiers to be cleared fully when this asset loads (mods are loaded in an order that may be specified by a data pack). For modders, you will want to use false . Data pack makers may want to specify their overrides with true . entries is an ordered list of the modifiers that will be loaded. This means that any modifier that not listed will not be loaded, and the ones listed are their written order. This is primarily relevant to data pack makers for resolving conflicts between modifiers from separate mods.","title":"The global_loot_modifiers.json"},{"location":"items/globallootmodifiers/#the-serialized-json","text":"This file contains all of the potential variables related to your modifier, including the conditions that must be met prior to modifying any loot. Avoid hard-coded values wherever possible so that data pack makers can adjust balance if they wish to. { \"conditions\": [ { \"condition\": \"minecraft:match_tool\", \"predicate\": { \"item\": \"minecraft:shears\" } }, { \"condition\": \"block_state_property\", \"block\":\"minecraft:wheat\" } ], \"seedItem\": \"minecraft:wheat_seeds\", \"numSeeds\": 3, \"replacement\": \"minecraft:wheat\" } In the above example, the modification only happens if an entity harvests wheat when using shears (specified by the two conditions which are automatically AND ed together). The seedsItem and numSeeds values are then used to count how many seeds were generated by the vanilla loot table, and if matched, are substituted for an additional replacement item instead. The operation code will be shown below. conditions is the only object needed by the system specification, everything else is the mod maker\u2019s data.","title":"The Serialized JSON"},{"location":"items/globallootmodifiers/#the-lootmodifier-subclass-and-serializer","text":"You will also need a class that extends GlobalLootModifierSerializer<T> where T is your LootModifier subclass in order to deserialize your json data file into operational code. public class WheatSeedsConverterModifier extends LootModifier { private final int numSeedsToConvert; private final Item itemToCheck; private final Item itemReward; public WheatSeedsConverterModifier(LootItemCondition[] conditions, int numSeeds, Item itemCheck, Item reward) { super(conditions); numSeedsToConvert = numSeeds; itemToCheck = itemCheck; itemReward = reward; } @Nonnull @Override public List<ItemStack> doApply(List<ItemStack> generatedLoot, LootContext context) { // // Additional conditions can be checked, though as much as possible should be parameterized via JSON data. // It is better to write a new ILootCondition implementation than to do things here. // int numSeeds = 0; for (ItemStack stack : generatedLoot) { if (stack.getItem() == itemToCheck) numSeeds += stack.getCount(); } if (numSeeds >= numSeedsToConvert) { generatedLoot.removeIf(x -> x.getItem() == itemToCheck); generatedLoot.add(new ItemStack(itemReward, (numSeeds / numSeedsToConvert))); numSeeds = numSeeds % numSeedsToConvert; if (numSeeds > 0) generatedLoot.add(new ItemStack(itemToCheck, numSeeds)); } return generatedLoot; } public static class Serializer extends GlobalLootModifierSerializer<WheatSeedsConverterModifier> { @Override public WheatSeedsConverterModifier read(ResourceLocation name, JsonObject object, LootItemCondition[] conditions) { int numSeeds = GsonHelper.getAsInt(object, \"numSeeds\"); Item seed = ForgeRegistries.ITEMS.getValue(new ResourceLocation((GsonHelper.getAsString(object, \"seedItem\")))); Item wheat = ForgeRegistries.ITEMS.getValue(new ResourceLocation(GsonHelper.getAsString(object, \"replacement\"))); return new WheatSeedsConverterModifier(conditions, numSeeds, seed, wheat); } @Override public JsonObject write(WheatSeedsConverterModifier instance) { JsonObject json = makeConditions(instance.conditions); json.addProperty(\"numSeeds\", instance.numSeedsToConvert); json.addProperty(\"seedItem\", ForgeRegistries.ITEMS.getKey(instance.itemToCheck).toString()); json.addProperty(\"replacement\", ForgeRegistries.ITEMS.getKey(instance.itemReward).toString()); return json; } } } The critical portion is the doApply method. This method is only called if the conditions specified return true . If so, the modder is now able to make the modifications they desire. In this case, we can see that the number of itemToCheck meets or exceeds the numSeedsToConvert before modifying the list by adding an itemReward and removing any excess itemToCheck stacks, matching the previously mentioned effects: When a wheat block is harvested with shears, if enough seeds are generated as loot, they are converted to additional wheat instead . Also take note of the read method in the serializer. The conditions are already deserialized for you and if you have no other data, simply return new MyModifier(conditions) . However, the full JsonObject is available if needed. The write method, on the other hand, is used for if you want to utilize GlobalLootModifierProvider for data generation . Additional examples can be found on the Forge Git repository, including silk touch and smelting effects.","title":"The LootModifier Subclass and Serializer"},{"location":"items/items/","text":"Items Along with blocks, items are a key component of most mods. While blocks make up the level around you, items exist within inventories. Creating an Item Basic Items Basic items that need no special functionality (think sticks or sugar) do not need custom classes. You can create an item by instantiating the Item class with an Item$Properties object. This Item$Properties object can be made via the constructor and customized by calling its methods. For instance: Method Description tab Sets which CreativeModeTab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class CreativeModeTab . durability Sets the maximum damage value for this item. If it is over 0 , two item properties \u201cdamaged\u201d and \u201cdamage\u201d are added. stacksTo Sets the maximum stack size. You cannot have an item that is both damageable and stackable. setNoRepair Makes this item impossible to repair, even if it is damageable. craftRemainder Sets this item\u2019s container item, the way that lava buckets give you back an empty bucket when they are used. addToolType Adds a pair of ToolType ( SHOVEL , AXE , PICKAXE ) and harvest level ( 0 for Wood/Gold, 1 for Stone, 2 for Iron, 3 for Diamond). The above methods are chainable, meaning they return this to facilitate calling them in series. Advanced Items Setting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods. Registering an Item Items must be registered to function.","title":"Home"},{"location":"items/items/#items","text":"Along with blocks, items are a key component of most mods. While blocks make up the level around you, items exist within inventories.","title":"Items"},{"location":"items/items/#creating-an-item","text":"","title":"Creating an Item"},{"location":"items/items/#basic-items","text":"Basic items that need no special functionality (think sticks or sugar) do not need custom classes. You can create an item by instantiating the Item class with an Item$Properties object. This Item$Properties object can be made via the constructor and customized by calling its methods. For instance: Method Description tab Sets which CreativeModeTab this item is under. Must be called if this item is meant to be shown on the creative menu. Vanilla tabs can be found in the class CreativeModeTab . durability Sets the maximum damage value for this item. If it is over 0 , two item properties \u201cdamaged\u201d and \u201cdamage\u201d are added. stacksTo Sets the maximum stack size. You cannot have an item that is both damageable and stackable. setNoRepair Makes this item impossible to repair, even if it is damageable. craftRemainder Sets this item\u2019s container item, the way that lava buckets give you back an empty bucket when they are used. addToolType Adds a pair of ToolType ( SHOVEL , AXE , PICKAXE ) and harvest level ( 0 for Wood/Gold, 1 for Stone, 2 for Iron, 3 for Diamond). The above methods are chainable, meaning they return this to facilitate calling them in series.","title":"Basic Items"},{"location":"items/items/#advanced-items","text":"Setting the properties of an item as above only works for simple items. If you want more complicated items, you should subclass Item and override its methods.","title":"Advanced Items"},{"location":"items/items/#registering-an-item","text":"Items must be registered to function.","title":"Registering an Item"},{"location":"legacy/","text":"Documentation for Legacy Versions Forge has existed for years, and you can still easily access builds of Forge for Minecraft versions as old as Minecraft 1.1. There are significant differences between each and every version, and it would be an impossible task to support so many different versions. Therefore, Forge uses an LTS system where a previous major Minecraft version is deemed as \u201cLTS\u201d (Long Term Support). Only the latest version and any current LTS versions will have easily accessible documentation and be included in the version dropdown in the sidebar. However, some older versions were LTS once or the latest version at some point and had documentation written. Links to old sites with documentation for those versions can be found here. Important These old documentation sites are for reference purposes only. Do not ask for help with old versions on the Forge discord or the Forge forums. You will not receive support when you are using older versions. List of Previously Documented versions Unfortunately, not all versions were used for a significant amount of time, and the documentation for that version may be incomplete. Whenever a new version is released, the documentation from the previous version is copied and adjusted over time to include new and updated information. When a version wasn\u2019t supported for long, the information was never updated. The accuracy percentages represent how much of the information that should have been updated was actually updated. Version Accuracy Link 1.12.x 100% https://mcforge.readthedocs.io/en/1.12.x/ 1.13.x 10% https://mcforge.readthedocs.io/en/1.13.x/ 1.14.x 10% https://mcforge.readthedocs.io/en/1.14.x/ 1.15.x 85% https://mcforge.readthedocs.io/en/1.15.x/ 1.16.x 85% https://mcforge.readthedocs.io/en/1.16.x/ RetroGradle RetroGradle is an archival initiative to update the older ForgeGradle 1.x to 2.3 toolchains and their Minecraft versions to use the modern ForgeGradle 4.x and above toolchain. The goal is to preserve all past released versions of Minecraft Forge by moving them to a verifiably working and modern toolchain which is data-driven and not hardcoded for version-specific workflows. If any developer wishes to contribute to this archival effort, please visit The Forge Project discord server and ask for directions to the designated channel. Please note that this initiative only aims to preserve these old versions for the benefit of the community, not to support developing mods for these old, unsupported versions. There will not be any support for using or developing for unsupported versions.","title":"Home"},{"location":"legacy/#documentation-for-legacy-versions","text":"Forge has existed for years, and you can still easily access builds of Forge for Minecraft versions as old as Minecraft 1.1. There are significant differences between each and every version, and it would be an impossible task to support so many different versions. Therefore, Forge uses an LTS system where a previous major Minecraft version is deemed as \u201cLTS\u201d (Long Term Support). Only the latest version and any current LTS versions will have easily accessible documentation and be included in the version dropdown in the sidebar. However, some older versions were LTS once or the latest version at some point and had documentation written. Links to old sites with documentation for those versions can be found here. Important These old documentation sites are for reference purposes only. Do not ask for help with old versions on the Forge discord or the Forge forums. You will not receive support when you are using older versions.","title":"Documentation for Legacy Versions"},{"location":"legacy/#list-of-previously-documented-versions","text":"Unfortunately, not all versions were used for a significant amount of time, and the documentation for that version may be incomplete. Whenever a new version is released, the documentation from the previous version is copied and adjusted over time to include new and updated information. When a version wasn\u2019t supported for long, the information was never updated. The accuracy percentages represent how much of the information that should have been updated was actually updated. Version Accuracy Link 1.12.x 100% https://mcforge.readthedocs.io/en/1.12.x/ 1.13.x 10% https://mcforge.readthedocs.io/en/1.13.x/ 1.14.x 10% https://mcforge.readthedocs.io/en/1.14.x/ 1.15.x 85% https://mcforge.readthedocs.io/en/1.15.x/ 1.16.x 85% https://mcforge.readthedocs.io/en/1.16.x/","title":"List of Previously Documented versions"},{"location":"legacy/#retrogradle","text":"RetroGradle is an archival initiative to update the older ForgeGradle 1.x to 2.3 toolchains and their Minecraft versions to use the modern ForgeGradle 4.x and above toolchain. The goal is to preserve all past released versions of Minecraft Forge by moving them to a verifiably working and modern toolchain which is data-driven and not hardcoded for version-specific workflows. If any developer wishes to contribute to this archival effort, please visit The Forge Project discord server and ask for directions to the designated channel. Please note that this initiative only aims to preserve these old versions for the benefit of the community, not to support developing mods for these old, unsupported versions. There will not be any support for using or developing for unsupported versions.","title":"RetroGradle"},{"location":"legacy/porting/","text":"Porting to Minecraft 1.17 Here you can find a list of primers on how to port from old versions to the current version. Some versions are lumped together since that particular version never saw much usage. From -> To Primer 1.12 -> 1.13/1.14 Primer by williewillus 1.14 -> 1.15 Primer by williewillus 1.15 -> 1.16 Primer by 50ap5ud5 1.16 -> 1.17 Primer by 50ap5ud5","title":"Porting to 1.17"},{"location":"legacy/porting/#porting-to-minecraft-117","text":"Here you can find a list of primers on how to port from old versions to the current version. Some versions are lumped together since that particular version never saw much usage. From -> To Primer 1.12 -> 1.13/1.14 Primer by williewillus 1.14 -> 1.15 Primer by williewillus 1.15 -> 1.16 Primer by 50ap5ud5 1.16 -> 1.17 Primer by 50ap5ud5","title":"Porting to Minecraft 1.17"},{"location":"models/color/","text":"Coloring Textures Many blocks and items in vanilla change their texture color depending on where they are or what properties they have, such as grass. Models support specifying \u201ctint indices\u201d on faces, which are integers that can then be handled by BlockColor s and ItemColor s. See the wiki for information on how tint indices are defined in vanilla models. BlockColor / ItemColor Both of these are single-method interfaces. BlockColor takes a BlockState , an (nullable) BlockAndTintGetter , and a (nullable) BlockPos . ItemColor takes an ItemStack . Both of them take an int parameter tintIndex , which is the tint index of the face being colored. Both of them return an int , a color multiplier. This int is treated as 4 unsigned bytes, alpha, red, green, and blue, in that order, from most significant byte to least. For each pixel in the tinted face, the value of each color channel is (int)((float) base * multiplier / 255.0) , where base is the original value for the channel, and multiplier is the associated byte from the color multiplier. Note that blocks do not use the alpha channel. For example, the grass texture, untinted, looks white and gray. The BlockColor and ItemColor for grass return color multipliers with low red and blue components, but high alpha and green components, (at least in warm biomes) so when the multiplication is performed, the green is brought out and the red/blue diminished. If an item inherits from the builtin/generated model, each layer (\u201clayer0\u201d, \u201clayer1\u201d, etc.) has a tint index corresponding to its layer index. Creating Color Handlers BlockColor s need to be registered to the BlockColors instance of the game. BlockColors can be acquired through ColorHandlerEvent$Block , and an BlockColor can be registered by BlockColors#register . Note that this does not cause the BlockItem for the given block to be colored. BlockItem s are items and need to be colored with an ItemColor . @SubscribeEvent public void registerBlockColors(ColorHandlerEvent.Block event){ event.getBlockColors().register(myBlockColor, coloredBlock1, coloredBlock2, ...); } ItemColor s need to be registered to the ItemColors instance of the game. ItemColors can be acquired through ColorHandlerEvent$Item , and an ItemColor can be registered by ItemColors#register . This method is overloaded to also take Block s, which simply registers the color handler for the item Block#asItem (i.e. the block\u2019s BlockItem ). @SubscribeEvent public void registerItemColors(ColorHandlerEvent.Item event){ event.getItemColors().register(myItemColor, coloredItem1, coloredItem2, ...); }","title":"Coloring Textures"},{"location":"models/color/#coloring-textures","text":"Many blocks and items in vanilla change their texture color depending on where they are or what properties they have, such as grass. Models support specifying \u201ctint indices\u201d on faces, which are integers that can then be handled by BlockColor s and ItemColor s. See the wiki for information on how tint indices are defined in vanilla models.","title":"Coloring Textures"},{"location":"models/color/#blockcoloritemcolor","text":"Both of these are single-method interfaces. BlockColor takes a BlockState , an (nullable) BlockAndTintGetter , and a (nullable) BlockPos . ItemColor takes an ItemStack . Both of them take an int parameter tintIndex , which is the tint index of the face being colored. Both of them return an int , a color multiplier. This int is treated as 4 unsigned bytes, alpha, red, green, and blue, in that order, from most significant byte to least. For each pixel in the tinted face, the value of each color channel is (int)((float) base * multiplier / 255.0) , where base is the original value for the channel, and multiplier is the associated byte from the color multiplier. Note that blocks do not use the alpha channel. For example, the grass texture, untinted, looks white and gray. The BlockColor and ItemColor for grass return color multipliers with low red and blue components, but high alpha and green components, (at least in warm biomes) so when the multiplication is performed, the green is brought out and the red/blue diminished. If an item inherits from the builtin/generated model, each layer (\u201clayer0\u201d, \u201clayer1\u201d, etc.) has a tint index corresponding to its layer index.","title":"BlockColor/ItemColor"},{"location":"models/color/#creating-color-handlers","text":"BlockColor s need to be registered to the BlockColors instance of the game. BlockColors can be acquired through ColorHandlerEvent$Block , and an BlockColor can be registered by BlockColors#register . Note that this does not cause the BlockItem for the given block to be colored. BlockItem s are items and need to be colored with an ItemColor . @SubscribeEvent public void registerBlockColors(ColorHandlerEvent.Block event){ event.getBlockColors().register(myBlockColor, coloredBlock1, coloredBlock2, ...); } ItemColor s need to be registered to the ItemColors instance of the game. ItemColors can be acquired through ColorHandlerEvent$Item , and an ItemColor can be registered by ItemColors#register . This method is overloaded to also take Block s, which simply registers the color handler for the item Block#asItem (i.e. the block\u2019s BlockItem ). @SubscribeEvent public void registerItemColors(ColorHandlerEvent.Item event){ event.getItemColors().register(myItemColor, coloredItem1, coloredItem2, ...); }","title":"Creating Color Handlers"},{"location":"models/files/","text":"Model Files A \u201cmodel\u201d is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you\u2019ll see will be in the vanilla JSON format. Models in other formats are loaded into IModelGeometry s by an IModelLoader at runtime. Forge provides default implementations for WaveFront OBJ files, buckets, composite models, models in different render layers, and a reimplementation of Vanilla\u2019s builtin/generated item model. Most things do not care about what loaded the model or what format it\u2019s in as they are all eventually represented by an BakedModel in code. When ResourceLocation refers to a model, the path is normally relative to models (e.g. examplemod:block/block \u2192 assets/examplemod/models/block/block.json ). Block and item models differ in a few ways, the major one being item property overrides . Textures Textures, like models, are contained within resource packs and are referred to with ResourceLocation s. When ResourceLocation s refer to textures in models, the paths are taken to be relative to textures/ (e.g. examplemod:block/test \u2192 assets/examplemod/textures/block/test.png ). Additionally, in Minecraft, the UV coordinates (0,0) are taken to mean the top-left corner. UVs are always from 0 to 16. If a texture is larger or smaller, the coordinates are scaled to fit. A texture should also be square, and the side length of a texture should be a power of two, as doing otherwise breaks mipmapping (e.g. 1x1, 2x2, 8x8, 16x16, and 128x128 are good. 5x5 and 30x30 are not recommended because they are not powers of 2. 5x10 and 4x8 are completely broken as they are not square.). If there is an mcmeta file associated with the texture, and an animation is defined, the image can be rectangular and is interpreted as a vertical sequence of square regions from top to bottom, where each square is a frame of the animation. JSON Models Vanilla Minecraft\u2019s JSON model format is rather simple. It defines cuboid (cube/rectangular prism) elements and assigns textures to their faces. On the wiki , there is a definition of its format. Note JSON models only support cuboid elements; there is no way to express a triangular wedge or anything like it. To have more complicated models, another format must be used. When a ResourceLocation refers to the location of a JSON model, it is not suffixed with .json , unlike OBJ models (e.g. minecraft:block/cube_all , not minecraft:block/cube_all.json ). WaveFront OBJ Models Forge adds a loader for the .obj file format. To use these models, the JSON must reference the forge:obj loader. This loader accepts any model location that is in a registered namespace and whose path ends in .obj . The .mtl file should be placed in the same location with the same name as the .obj to be used automatically. The .mtl file will probably have to be manually edited to change the paths pointing to textures defined within the JSON. Additionally, the V axis for textures may be flipped depending on the external program that created the model (i.e. V = 0 may be the bottom edge, not the top). This may be rectified in the modelling program itself or done in the model JSON like so: { \"__comment\": \"Add the following line on the same level as a 'model' declaration.\", \"loader\": \"forge:obj\", \"flip-v\": true, \"model\": \"examplemod:models/block/model.obj\", \"textures\": { \"_comment\": \"Can refer to in .mtl using #texture0\", \"texture0\": \"minecraft:block/dirt\", \"particle\": \"minecraft:block/dirt\" } }","title":"Model Files"},{"location":"models/files/#model-files","text":"A \u201cmodel\u201d is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you\u2019ll see will be in the vanilla JSON format. Models in other formats are loaded into IModelGeometry s by an IModelLoader at runtime. Forge provides default implementations for WaveFront OBJ files, buckets, composite models, models in different render layers, and a reimplementation of Vanilla\u2019s builtin/generated item model. Most things do not care about what loaded the model or what format it\u2019s in as they are all eventually represented by an BakedModel in code. When ResourceLocation refers to a model, the path is normally relative to models (e.g. examplemod:block/block \u2192 assets/examplemod/models/block/block.json ). Block and item models differ in a few ways, the major one being item property overrides .","title":"Model Files"},{"location":"models/files/#textures","text":"Textures, like models, are contained within resource packs and are referred to with ResourceLocation s. When ResourceLocation s refer to textures in models, the paths are taken to be relative to textures/ (e.g. examplemod:block/test \u2192 assets/examplemod/textures/block/test.png ). Additionally, in Minecraft, the UV coordinates (0,0) are taken to mean the top-left corner. UVs are always from 0 to 16. If a texture is larger or smaller, the coordinates are scaled to fit. A texture should also be square, and the side length of a texture should be a power of two, as doing otherwise breaks mipmapping (e.g. 1x1, 2x2, 8x8, 16x16, and 128x128 are good. 5x5 and 30x30 are not recommended because they are not powers of 2. 5x10 and 4x8 are completely broken as they are not square.). If there is an mcmeta file associated with the texture, and an animation is defined, the image can be rectangular and is interpreted as a vertical sequence of square regions from top to bottom, where each square is a frame of the animation.","title":"Textures"},{"location":"models/files/#json-models","text":"Vanilla Minecraft\u2019s JSON model format is rather simple. It defines cuboid (cube/rectangular prism) elements and assigns textures to their faces. On the wiki , there is a definition of its format. Note JSON models only support cuboid elements; there is no way to express a triangular wedge or anything like it. To have more complicated models, another format must be used. When a ResourceLocation refers to the location of a JSON model, it is not suffixed with .json , unlike OBJ models (e.g. minecraft:block/cube_all , not minecraft:block/cube_all.json ).","title":"JSON Models"},{"location":"models/files/#wavefront-obj-models","text":"Forge adds a loader for the .obj file format. To use these models, the JSON must reference the forge:obj loader. This loader accepts any model location that is in a registered namespace and whose path ends in .obj . The .mtl file should be placed in the same location with the same name as the .obj to be used automatically. The .mtl file will probably have to be manually edited to change the paths pointing to textures defined within the JSON. Additionally, the V axis for textures may be flipped depending on the external program that created the model (i.e. V = 0 may be the bottom edge, not the top). This may be rectified in the modelling program itself or done in the model JSON like so: { \"__comment\": \"Add the following line on the same level as a 'model' declaration.\", \"loader\": \"forge:obj\", \"flip-v\": true, \"model\": \"examplemod:models/block/model.obj\", \"textures\": { \"_comment\": \"Can refer to in .mtl using #texture0\", \"texture0\": \"minecraft:block/dirt\", \"particle\": \"minecraft:block/dirt\" } }","title":"WaveFront OBJ Models"},{"location":"models/introduction/","text":"Intro to Models The model system is Minecraft\u2019s way of giving blocks and items their shapes. Through the model system, blocks and items are mapped to their models, which define how they look. One of the main goals of the model system is to allow not only textures but the entire shape of a block/item to be changed by resource packs. Indeed, any mod that adds items or blocks also contains a mini-resource pack for their blocks and items. In order to link code to models and textures on disk, there exists the class ResourceLocation . One may recognize them from the registry system; however, their original purpose was to identify files on disk; they just happened to be useful as unique identifiers as well. A ResourceLocation is a simple object composed of two String s: a namespace and a path. When a ResourceLocation is represented as a plain string, it looks like namespace:path . When a ResourceLocation is created and a namespace isn\u2019t explicitly given, the namespace defaults to minecraft . However, it is good practice to include the namespace anyway. The namespace of a ResourceLocation in the model system represents a directory directly underneath assets/ . Usually, the namespace is the same as the modid (e.g. in vanilla Minecraft the namespace is always minecraft ). The path portion of a ResourceLocation represents a context-sensitive path to file underneath the namespace. What the path means and where exactly it points depends on what\u2019s using it. For example, when referring to a model, the path is normally resolved under models , but when referring to a texture, it is under textures . Therefore, mod:file means assets/mod/models/file.json in one context but assets/mod/textures/file.png in another. When something is described as requiring a ResourceLocation , it will be defined what exactly the path means. All strings related to the model system (especially ResourceLocation s) should be in snake case (meaning_all_lowercase_and_underscore_separated_words_like_this). This is enforced since Minecraft 1.11.","title":"Intro to Models"},{"location":"models/introduction/#intro-to-models","text":"The model system is Minecraft\u2019s way of giving blocks and items their shapes. Through the model system, blocks and items are mapped to their models, which define how they look. One of the main goals of the model system is to allow not only textures but the entire shape of a block/item to be changed by resource packs. Indeed, any mod that adds items or blocks also contains a mini-resource pack for their blocks and items. In order to link code to models and textures on disk, there exists the class ResourceLocation . One may recognize them from the registry system; however, their original purpose was to identify files on disk; they just happened to be useful as unique identifiers as well. A ResourceLocation is a simple object composed of two String s: a namespace and a path. When a ResourceLocation is represented as a plain string, it looks like namespace:path . When a ResourceLocation is created and a namespace isn\u2019t explicitly given, the namespace defaults to minecraft . However, it is good practice to include the namespace anyway. The namespace of a ResourceLocation in the model system represents a directory directly underneath assets/ . Usually, the namespace is the same as the modid (e.g. in vanilla Minecraft the namespace is always minecraft ). The path portion of a ResourceLocation represents a context-sensitive path to file underneath the namespace. What the path means and where exactly it points depends on what\u2019s using it. For example, when referring to a model, the path is normally resolved under models , but when referring to a texture, it is under textures . Therefore, mod:file means assets/mod/models/file.json in one context but assets/mod/textures/file.png in another. When something is described as requiring a ResourceLocation , it will be defined what exactly the path means. All strings related to the model system (especially ResourceLocation s) should be in snake case (meaning_all_lowercase_and_underscore_separated_words_like_this). This is enforced since Minecraft 1.11.","title":"Intro to Models"},{"location":"models/itemproperties/","text":"Item Property Overrides Item properties are a way for the \u201cproperties\u201d of items to be exposed to the model system. An example is the bow, where the most important property is how far the bow has been pulled. This information is then used to choose a model for the bow, creating an animation for pulling it. An item property assigns a certain float value to every ItemStack it is registered for, and vanilla item model definitions can use these values to define \u201coverrides\u201d, where an item defaults to a certain model, but if an override matches, it overrides the model and uses another. They are useful mainly because they are continuous. For example, bows use item properties to define their pull animation. The item models are decided by the \u2018float\u2019 number predicates, it is not limited but generally between 0.0F and 1.0F . This allows resource packs to add as many models as they want for the bow pulling animation along that spectrum, instead of being stuck with four \u201cslots\u201d for their models in the animation. The same is true of the compass and clock. Adding Properties to Items ItemProperties#register is used to add a property to a certain item. The Item parameter is the item the property is being attached to (e.g. ExampleItems#APPLE ). The ResourceLocation parameter is the name given to the property (e.g. new ResourceLocation(\"pull\") ). The ItemPropertyFunction is a functional interface that takes the ItemStack , the ClientLevel it is in (may be null), the LivingEntity that holds it (may be null), and the int containing the id of the holding entity (may be 0 ), returning the float value for the property. For modded item properties, it is recommended that the modid of the mod is used as the namespace (e.g. examplemod:property and not just property , as that really means minecraft:property ). These should be done in FMLClientSetupEvent . There\u2019s also another private method ItemProperties#registerGeneric that is used to add properties to all items, and it does not take Item as its parameter since all items will apply this property. Important Use FMLClientSetupEvent#enqueueWork to proceed with the tasks, since the data structures in ItemProperties are not thread-safe. Note ItemPropertyFunction is deprecated by Mojang in favor of using the subinterface ClampedItemPropertyFunction which clamps the result between 0 and 1 . Using Overrides The format of an override can be seen on the wiki , and a good example can be found in model/item/bow.json . For reference, here is a hypothetical example of an item with an examplemod:power property. If the values have no match, the default is the current model, but if there are multiple matches, the last match in the list will be selected. Important A predicate applies to all values greater than or equal to the given value. { \"parent\": \"item/generated\", \"textures\": { \"__comment\": \"Default\", \"layer0\": \"examplemod:items/example_partial\" }, \"overrides\": [ { \"__comment\": \"power >= .75\", \"predicate\": { \"examplemod:power\": 0.75 }, \"model\": \"examplemod:item/example_powered\" } ] } And here is a hypothetical snippet from the supporting code. Unlike the older versions (lower than 1.16.x), this needs to be done on client side only because ItemProperties does not exist on server. private void setup(final FMLClientSetupEvent event) { event.enqueueWork(() -> { ItemProperties.register(ExampleItems.APPLE, new ResourceLocation(ExampleMod.MODID, \"pulling\"), (stack, level, living, id) -> { return living != null && living.isUsingItem() && living.getUseItem() == stack ? 1.0F : 0.0F; }); }); }","title":"Item Properties"},{"location":"models/itemproperties/#item-property-overrides","text":"Item properties are a way for the \u201cproperties\u201d of items to be exposed to the model system. An example is the bow, where the most important property is how far the bow has been pulled. This information is then used to choose a model for the bow, creating an animation for pulling it. An item property assigns a certain float value to every ItemStack it is registered for, and vanilla item model definitions can use these values to define \u201coverrides\u201d, where an item defaults to a certain model, but if an override matches, it overrides the model and uses another. They are useful mainly because they are continuous. For example, bows use item properties to define their pull animation. The item models are decided by the \u2018float\u2019 number predicates, it is not limited but generally between 0.0F and 1.0F . This allows resource packs to add as many models as they want for the bow pulling animation along that spectrum, instead of being stuck with four \u201cslots\u201d for their models in the animation. The same is true of the compass and clock.","title":"Item Property Overrides"},{"location":"models/itemproperties/#adding-properties-to-items","text":"ItemProperties#register is used to add a property to a certain item. The Item parameter is the item the property is being attached to (e.g. ExampleItems#APPLE ). The ResourceLocation parameter is the name given to the property (e.g. new ResourceLocation(\"pull\") ). The ItemPropertyFunction is a functional interface that takes the ItemStack , the ClientLevel it is in (may be null), the LivingEntity that holds it (may be null), and the int containing the id of the holding entity (may be 0 ), returning the float value for the property. For modded item properties, it is recommended that the modid of the mod is used as the namespace (e.g. examplemod:property and not just property , as that really means minecraft:property ). These should be done in FMLClientSetupEvent . There\u2019s also another private method ItemProperties#registerGeneric that is used to add properties to all items, and it does not take Item as its parameter since all items will apply this property. Important Use FMLClientSetupEvent#enqueueWork to proceed with the tasks, since the data structures in ItemProperties are not thread-safe. Note ItemPropertyFunction is deprecated by Mojang in favor of using the subinterface ClampedItemPropertyFunction which clamps the result between 0 and 1 .","title":"Adding Properties to Items"},{"location":"models/itemproperties/#using-overrides","text":"The format of an override can be seen on the wiki , and a good example can be found in model/item/bow.json . For reference, here is a hypothetical example of an item with an examplemod:power property. If the values have no match, the default is the current model, but if there are multiple matches, the last match in the list will be selected. Important A predicate applies to all values greater than or equal to the given value. { \"parent\": \"item/generated\", \"textures\": { \"__comment\": \"Default\", \"layer0\": \"examplemod:items/example_partial\" }, \"overrides\": [ { \"__comment\": \"power >= .75\", \"predicate\": { \"examplemod:power\": 0.75 }, \"model\": \"examplemod:item/example_powered\" } ] } And here is a hypothetical snippet from the supporting code. Unlike the older versions (lower than 1.16.x), this needs to be done on client side only because ItemProperties does not exist on server. private void setup(final FMLClientSetupEvent event) { event.enqueueWork(() -> { ItemProperties.register(ExampleItems.APPLE, new ResourceLocation(ExampleMod.MODID, \"pulling\"), (stack, level, living, id) -> { return living != null && living.isUsingItem() && living.getUseItem() == stack ? 1.0F : 0.0F; }); }); }","title":"Using Overrides"},{"location":"models/advanced/bakedmodel/","text":"BakedModel BakedModel is the result of calling UnbakedModel#bake for the vanilla model loader or IModelGeometry#bake for custom model loaders. Unlike UnbakedModel or IModelGeometry , which purely represents a shape without any concept of items or blocks, BakedModel is not as abstract. It represents geometry that has been optimized and reduced to a form where it is (almost) ready to go to the GPU. It can also process the state of an item or block to change the model. In a majority of cases, it is not really necessary to implement this interface manually. One can instead use one of the existing implementations. getOverrides Returns the ItemOverrides to use for this model. This is only used if this model is being rendered as an item. useAmbientOcclusion If the model is rendered as a block in the level, the block in question does not emit any light, and ambient occlusion is enabled. This causes the model to be rendered with ambient occlusion . isGui3d If the model is rendered as an item in an inventory, on the ground as an entity, on an item frame, etc., this makes the model look \u201cflat.\u201d In GUIs, this also disables the lighting. isCustomRenderer Important Unless you know what you\u2019re doing, just return false from this and continue on. When rendering this as an item, returning true causes the model to not be rendered, instead falling back to BlockEntityWithoutLevelRenderer#renderByItem . For certain vanilla items such as chests and banners, this method is hardcoded to copy data from the item into a BlockEntity , before using a BlockEntityRenderer to render that BE in place of the item. For all other items, it will use the BlockEntityWithoutLevelRenderer instance provided by IItemRenderProperties#getItemStackRenderer . Refer to BlockEntityWithoutLevelRenderer page for more information. getParticleIcon Whatever texture should be used for the particles. For blocks, this shows when an entity falls on it, when it breaks, etc. For items, this shows when it breaks or when it\u2019s eaten. Important The vanilla method with no parameters has been deprecated in favor of #getParticleIcon(IModelData) since model data can have an effect on how a particular model might be rendered. getTransforms Deprecated in favor of implementing #handlePerspective . The default implementation is fine if #handlePerspective is implemented. See Perspective . handlePerspective See Perspective . getQuads This is the main method of BakedModel . It returns a list of BakedQuad s: objects which contain the low-level vertex data that will be used to render the model. If the model is being rendered as a block, then the BlockState passed in is non-null. If the model is being rendered as an item, the ItemOverrides returned from #getOverrides is responsible for handling the state of the item, and the BlockState parameter will be null . The Direction passed in is used for face culling. If the block against the given side of another block being rendered is opaque, then the faces associated with that side are not rendered. If that parameter is null , all faces not associated with a side are returned (that will never be culled). The rand parameter is an instance of Random. It also takes in a non null IModelData instance. This can be used to define extra data when rendering the specific model via ModelProperty s. For example, one such property is CompositeModelData , which is used to store any additional submodel data for a model using the forge:composite model loader. Note that this method is called very often: once for every combination of non-culled face and supported block render layer (anywhere between 0 to 28 times) per block in a level . This method should be as fast as possible, and should probably cache heavily.","title":"BakedModel"},{"location":"models/advanced/bakedmodel/#bakedmodel","text":"BakedModel is the result of calling UnbakedModel#bake for the vanilla model loader or IModelGeometry#bake for custom model loaders. Unlike UnbakedModel or IModelGeometry , which purely represents a shape without any concept of items or blocks, BakedModel is not as abstract. It represents geometry that has been optimized and reduced to a form where it is (almost) ready to go to the GPU. It can also process the state of an item or block to change the model. In a majority of cases, it is not really necessary to implement this interface manually. One can instead use one of the existing implementations.","title":"BakedModel"},{"location":"models/advanced/bakedmodel/#getoverrides","text":"Returns the ItemOverrides to use for this model. This is only used if this model is being rendered as an item.","title":"getOverrides"},{"location":"models/advanced/bakedmodel/#useambientocclusion","text":"If the model is rendered as a block in the level, the block in question does not emit any light, and ambient occlusion is enabled. This causes the model to be rendered with ambient occlusion .","title":"useAmbientOcclusion"},{"location":"models/advanced/bakedmodel/#isgui3d","text":"If the model is rendered as an item in an inventory, on the ground as an entity, on an item frame, etc., this makes the model look \u201cflat.\u201d In GUIs, this also disables the lighting.","title":"isGui3d"},{"location":"models/advanced/bakedmodel/#iscustomrenderer","text":"Important Unless you know what you\u2019re doing, just return false from this and continue on. When rendering this as an item, returning true causes the model to not be rendered, instead falling back to BlockEntityWithoutLevelRenderer#renderByItem . For certain vanilla items such as chests and banners, this method is hardcoded to copy data from the item into a BlockEntity , before using a BlockEntityRenderer to render that BE in place of the item. For all other items, it will use the BlockEntityWithoutLevelRenderer instance provided by IItemRenderProperties#getItemStackRenderer . Refer to BlockEntityWithoutLevelRenderer page for more information.","title":"isCustomRenderer"},{"location":"models/advanced/bakedmodel/#getparticleicon","text":"Whatever texture should be used for the particles. For blocks, this shows when an entity falls on it, when it breaks, etc. For items, this shows when it breaks or when it\u2019s eaten. Important The vanilla method with no parameters has been deprecated in favor of #getParticleIcon(IModelData) since model data can have an effect on how a particular model might be rendered.","title":"getParticleIcon"},{"location":"models/advanced/bakedmodel/#gettransforms","text":"Deprecated in favor of implementing #handlePerspective . The default implementation is fine if #handlePerspective is implemented. See Perspective .","title":"getTransforms"},{"location":"models/advanced/bakedmodel/#handleperspective","text":"See Perspective .","title":"handlePerspective"},{"location":"models/advanced/bakedmodel/#getquads","text":"This is the main method of BakedModel . It returns a list of BakedQuad s: objects which contain the low-level vertex data that will be used to render the model. If the model is being rendered as a block, then the BlockState passed in is non-null. If the model is being rendered as an item, the ItemOverrides returned from #getOverrides is responsible for handling the state of the item, and the BlockState parameter will be null . The Direction passed in is used for face culling. If the block against the given side of another block being rendered is opaque, then the faces associated with that side are not rendered. If that parameter is null , all faces not associated with a side are returned (that will never be culled). The rand parameter is an instance of Random. It also takes in a non null IModelData instance. This can be used to define extra data when rendering the specific model via ModelProperty s. For example, one such property is CompositeModelData , which is used to store any additional submodel data for a model using the forge:composite model loader. Note that this method is called very often: once for every combination of non-culled face and supported block render layer (anywhere between 0 to 28 times) per block in a level . This method should be as fast as possible, and should probably cache heavily.","title":"getQuads"},{"location":"models/advanced/itemoverrides/","text":"ItemOverrides ItemOverrides provides a way for an BakedModel to process the state of an ItemStack and return a new BakedModel ; thereafter, the returned model replaces the old one. ItemOverrides represents an arbitrary function (BakedModel, ItemStack, ClientLevel, LivingEntity, int) \u2192 BakedModel , making it useful for dynamic models. In vanilla, it is used to implement item property overrides. ItemOverrides() Given a list of ItemOverride s, the constructor copies that list and stores the copy. The list may be accessed with #getOverrides . resolve This takes an BakedModel , an ItemStack , a ClientLevel , a LivingEntity , and an int to produce another BakedModel to use for rendering. This is where models can handle the state of their items. This should not mutate the level. getOverrides Returns an immutable list containing all the ItemOverride s used by this ItemOverrides . If none are applicable, this returns the empty list. ItemOverride This class represents a vanilla item override, which holds several predicates for the properties on an item and a model to use in case those predicates are satisfied. They are the objects in the overrides array of a vanilla item JSON model: { \"__comment\": \"Inside a vanilla JSON item model.\", \"overrides\": [ { \"__comment\": \"This is an ItemOverride.\", \"predicate\": { \"__comment\": \"This is the Map<ResourceLocation, Float>, containing the names of properties and their minimum values.\", \"example1:prop\": 0.5 }, \"__comment\": \"This is the 'location', or target model, of the override, which is used if the predicate above matches.\", \"model\": \"example1:item/model\" }, { \"__comment\": \"This is another ItemOverride.\", \"predicate\": { \"example2:prop\": 1 }, \"model\": \"example2:item/model\" } ] }","title":"Item Overrides"},{"location":"models/advanced/itemoverrides/#itemoverrides","text":"ItemOverrides provides a way for an BakedModel to process the state of an ItemStack and return a new BakedModel ; thereafter, the returned model replaces the old one. ItemOverrides represents an arbitrary function (BakedModel, ItemStack, ClientLevel, LivingEntity, int) \u2192 BakedModel , making it useful for dynamic models. In vanilla, it is used to implement item property overrides.","title":"ItemOverrides"},{"location":"models/advanced/itemoverrides/#itemoverrides_1","text":"Given a list of ItemOverride s, the constructor copies that list and stores the copy. The list may be accessed with #getOverrides .","title":"ItemOverrides()"},{"location":"models/advanced/itemoverrides/#resolve","text":"This takes an BakedModel , an ItemStack , a ClientLevel , a LivingEntity , and an int to produce another BakedModel to use for rendering. This is where models can handle the state of their items. This should not mutate the level.","title":"resolve"},{"location":"models/advanced/itemoverrides/#getoverrides","text":"Returns an immutable list containing all the ItemOverride s used by this ItemOverrides . If none are applicable, this returns the empty list.","title":"getOverrides"},{"location":"models/advanced/itemoverrides/#itemoverride","text":"This class represents a vanilla item override, which holds several predicates for the properties on an item and a model to use in case those predicates are satisfied. They are the objects in the overrides array of a vanilla item JSON model: { \"__comment\": \"Inside a vanilla JSON item model.\", \"overrides\": [ { \"__comment\": \"This is an ItemOverride.\", \"predicate\": { \"__comment\": \"This is the Map<ResourceLocation, Float>, containing the names of properties and their minimum values.\", \"example1:prop\": 0.5 }, \"__comment\": \"This is the 'location', or target model, of the override, which is used if the predicate above matches.\", \"model\": \"example1:item/model\" }, { \"__comment\": \"This is another ItemOverride.\", \"predicate\": { \"example2:prop\": 1 }, \"model\": \"example2:item/model\" } ] }","title":"ItemOverride"},{"location":"models/advanced/perspective/","text":"Perspective When an BakedModel is being rendered as an item, it can apply special handling depending on which perspective it is being rendered in. \u201cPerspective\u201d means in what context the model is being rendered. The possible perspectives are represented in code by the ItemTransforms$TransformType enum. There are two systems for handling perspective: the deprecated vanilla system, constituted by BakedModel#getTransforms , ItemTransforms , and ItemTransform , and the Forge system, embodied by the method IForgeBakedModel#handlePerspective . The vanilla code is patched to favor using handlePerspective over the vanilla system whenever possible. TransformType NONE - Unused. THIRD_PERSON_LEFT_HAND / THIRD_PERSON_RIGHT_HAND / FIRST_PERSON_LEFT_HAND / FIRST_PERSON_RIGHT_HAND - The first person values represent when the player is holding the item in their own hand. The third person values represent when another player is holding the item and the client is looking at them in the 3rd person. Hands are self-explanatory. HEAD - Represents when any player is wearing the item in the helmet slot (e.g. pumpkins). GUI - Represents when the item is being rendered in a Screen . GROUND - Represents when the item is being rendered in the level as an ItemEntity . FIXED - Used for item frames. The Vanilla Way The vanilla way of handling perspective is through BakedModel#getTransforms . This method returns an ItemTransforms , which is a simple object that contains various ItemTransform s as public final fields. An ItemTransform represents a rotation, a translation, and a scale to be applied to the model. The ItemTransforms is a container for these, holding one for each of the TransformType s except NONE . In the vanilla implementation, calling #getTransform for NONE results in the default transform, ItemTransform#NO_TRANSFORM . The entire vanilla system for handling transforms is deprecated by Forge, and most implementations of BakedModel should simply return ItemTransforms#NO_TRANSFORMS (which is the default implementation) from BakedModel#getTransforms . Instead, they should implement #handlePerspective . The Forge Way The Forge way of handling transforms is #handlePerspective , a method patched into BakedModel . It supersedes the ##getTransforms method. Additionally, the class PerspectiveMapWrapper is a simple implementation of an BakedModel with the method; it is a wrapper around other BakedModel s, augmenting them with a Map<TransformType, Transformation> to handle perspective. BakedModel#handlePerspective Given a TransformType and PoseStack , this method produces an BakedModel to be rendered. Because the returned BakedModel can be a totally new model, this method is more flexible than the vanilla method (e.g. a piece of paper that looks flat in hand but crumpled on the ground). PerspectiveMapWrapper A wrapper around other BakedModel s, this class delegates to the wrapped model for all BakedModel methods except #handlePerspective , and utilizes a simple Map<TransformType, Transformation> for #handlePerspective . However, the more interesting parts of this class are the static helper methods. getTransforms and getTransformsWithFallback Given an ItemTransforms or an ModelState , this method will extract an ImmutableMap<TransformType, Transformation> from it. To extract this information from an ModelState , each TransformType is passed to #getPartTransformation . This is how models should support custom perspective transforms through ModelState . UnbakedModel s should pass the ModelState in #bake . Then the BakedModel can use these custom transforms in #handlePerspective , composing them on top of its own. handlePerspective Given either a map of transforms or an ModelState , an BakedModel , a TransformType , and a PoseStack , this finds the BakedModel for the transform from the map or the ModelState , and then pairs it with the given model. To extract the transform from an ModelState , the TransformType is passed to #getPartTransformation . This method is meant to be a simple implementation of BakedModel#handlePerspective .","title":"Perspective"},{"location":"models/advanced/perspective/#perspective","text":"When an BakedModel is being rendered as an item, it can apply special handling depending on which perspective it is being rendered in. \u201cPerspective\u201d means in what context the model is being rendered. The possible perspectives are represented in code by the ItemTransforms$TransformType enum. There are two systems for handling perspective: the deprecated vanilla system, constituted by BakedModel#getTransforms , ItemTransforms , and ItemTransform , and the Forge system, embodied by the method IForgeBakedModel#handlePerspective . The vanilla code is patched to favor using handlePerspective over the vanilla system whenever possible.","title":"Perspective"},{"location":"models/advanced/perspective/#transformtype","text":"NONE - Unused. THIRD_PERSON_LEFT_HAND / THIRD_PERSON_RIGHT_HAND / FIRST_PERSON_LEFT_HAND / FIRST_PERSON_RIGHT_HAND - The first person values represent when the player is holding the item in their own hand. The third person values represent when another player is holding the item and the client is looking at them in the 3rd person. Hands are self-explanatory. HEAD - Represents when any player is wearing the item in the helmet slot (e.g. pumpkins). GUI - Represents when the item is being rendered in a Screen . GROUND - Represents when the item is being rendered in the level as an ItemEntity . FIXED - Used for item frames.","title":"TransformType"},{"location":"models/advanced/perspective/#the-vanilla-way","text":"The vanilla way of handling perspective is through BakedModel#getTransforms . This method returns an ItemTransforms , which is a simple object that contains various ItemTransform s as public final fields. An ItemTransform represents a rotation, a translation, and a scale to be applied to the model. The ItemTransforms is a container for these, holding one for each of the TransformType s except NONE . In the vanilla implementation, calling #getTransform for NONE results in the default transform, ItemTransform#NO_TRANSFORM . The entire vanilla system for handling transforms is deprecated by Forge, and most implementations of BakedModel should simply return ItemTransforms#NO_TRANSFORMS (which is the default implementation) from BakedModel#getTransforms . Instead, they should implement #handlePerspective .","title":"The Vanilla Way"},{"location":"models/advanced/perspective/#the-forge-way","text":"The Forge way of handling transforms is #handlePerspective , a method patched into BakedModel . It supersedes the ##getTransforms method. Additionally, the class PerspectiveMapWrapper is a simple implementation of an BakedModel with the method; it is a wrapper around other BakedModel s, augmenting them with a Map<TransformType, Transformation> to handle perspective.","title":"The Forge Way"},{"location":"models/advanced/perspective/#bakedmodelhandleperspective","text":"Given a TransformType and PoseStack , this method produces an BakedModel to be rendered. Because the returned BakedModel can be a totally new model, this method is more flexible than the vanilla method (e.g. a piece of paper that looks flat in hand but crumpled on the ground).","title":"BakedModel#handlePerspective"},{"location":"models/advanced/perspective/#perspectivemapwrapper","text":"A wrapper around other BakedModel s, this class delegates to the wrapped model for all BakedModel methods except #handlePerspective , and utilizes a simple Map<TransformType, Transformation> for #handlePerspective . However, the more interesting parts of this class are the static helper methods.","title":"PerspectiveMapWrapper"},{"location":"models/advanced/perspective/#gettransforms-and-gettransformswithfallback","text":"Given an ItemTransforms or an ModelState , this method will extract an ImmutableMap<TransformType, Transformation> from it. To extract this information from an ModelState , each TransformType is passed to #getPartTransformation . This is how models should support custom perspective transforms through ModelState . UnbakedModel s should pass the ModelState in #bake . Then the BakedModel can use these custom transforms in #handlePerspective , composing them on top of its own.","title":"getTransforms and getTransformsWithFallback"},{"location":"models/advanced/perspective/#handleperspective","text":"Given either a map of transforms or an ModelState , an BakedModel , a TransformType , and a PoseStack , this finds the BakedModel for the transform from the map or the ModelState , and then pairs it with the given model. To extract the transform from an ModelState , the TransformType is passed to #getPartTransformation . This method is meant to be a simple implementation of BakedModel#handlePerspective .","title":"handlePerspective"},{"location":"models/blockstates/introduction/","text":"Introduction to Blockstate JSONs Blockstate JSONs are Minecraft\u2019s way to map \u201cvariant strings\u201d to models. A variant string can be absolutely anything, from \u201cinventory\u201d to \u201cpower=5\u201d to \u201cI am your father.\u201d They represent an actual model, where the blockstate is just a container for them. In code, a variant string within a blockstate JSON is represented by a ModelResourceLocation . When the game searches for a model corresponding to a block in the level, it takes the blockstate for that position, and then it uses a map within ModelManager to find the corresponding ModelResourceLocation for it, which then refers to the actual model. BlockModelShaper uses the block\u2019s registry name as the location of the blockstate JSON. (E.g. block examplemod:testblock goes to the ResourceLocation examplemod:testblock .) The variant string is pieced together from the blockstate\u2019s properties. As an example, let\u2019s take a look at the vanilla oak_log.json : { \"variants\": { \"axis=x\": { \"model\": \"minecraft:block/oak_log_horizontal\", \"x\": 90, \"y\": 90 }, \"axis=y\": { \"model\": \"minecraft:block/oak_log\" }, \"axis=z\": { \"model\": \"minecraft:block/oak_log_horizontal\", \"x\": 90 } } } Here we define 3 variant strings, and for each we use a certain model, either the upright log and the sideways log (rotated in the y direction or not). These variants will define the look of a log depending on the property axis . A variant should be defined for every property that invokes a change in the model displayed. Any property not specified in the JSON will not have any bearing to determine the current model (e.g. waterlogged has no effect on how a model might look). Each blockstate can be specified using one of two methods: variants and multiparts. A variant defines an associated array of states which point to the associated model to render. Note that every single property that changes the model must be defined (e.g. If 4 properties defines how the model looks, then 2 ^ 4 = 16 variants must be defined). Multiparts, on the other hand, use conditions to display a certain model when true (e.g. If a model is only shown when north was true, then when that case occurs, the model will display along with any other models whose conditions are met). For a better understanding of multiparts, let\u2019s look at a variant built fence connection: \"east=true,north=false,south=false,west=false\": { \"model\": \"oak_fence_n\", \"y\": 90, \"uvlock\": true } This represents one variant out of 16 possible states. Even worse, there must be models that can uniquely define unique states (a state that can be rotated to become another state is not unique for this purpose). For fences, there are 6 models: one for no connections, one connection, two connections in a straight line, two perpendicular connections, three connections, and one for all four connections. Now let\u2019s view a modern day multipart built fence connection: { \"when\": { \"east\": \"true\" }, \"apply\": { \"model\": \"oak_fence_side\", \"y\": 90, \"uvlock\": true } } In this case, the JSON defines that if the east connector is true, then show the model oak_fence_side rotated 90 degrees. This allows the model to be broken up in only two files: the base post and the connection. It can also be represented as 5 statements, one that checks for each of the states is true and one that applies the base post unconditionally. You can find more explanations and examples of these formats on the wiki .","title":"Intro to BlockState JSON"},{"location":"models/blockstates/introduction/#introduction-to-blockstate-jsons","text":"Blockstate JSONs are Minecraft\u2019s way to map \u201cvariant strings\u201d to models. A variant string can be absolutely anything, from \u201cinventory\u201d to \u201cpower=5\u201d to \u201cI am your father.\u201d They represent an actual model, where the blockstate is just a container for them. In code, a variant string within a blockstate JSON is represented by a ModelResourceLocation . When the game searches for a model corresponding to a block in the level, it takes the blockstate for that position, and then it uses a map within ModelManager to find the corresponding ModelResourceLocation for it, which then refers to the actual model. BlockModelShaper uses the block\u2019s registry name as the location of the blockstate JSON. (E.g. block examplemod:testblock goes to the ResourceLocation examplemod:testblock .) The variant string is pieced together from the blockstate\u2019s properties. As an example, let\u2019s take a look at the vanilla oak_log.json : { \"variants\": { \"axis=x\": { \"model\": \"minecraft:block/oak_log_horizontal\", \"x\": 90, \"y\": 90 }, \"axis=y\": { \"model\": \"minecraft:block/oak_log\" }, \"axis=z\": { \"model\": \"minecraft:block/oak_log_horizontal\", \"x\": 90 } } } Here we define 3 variant strings, and for each we use a certain model, either the upright log and the sideways log (rotated in the y direction or not). These variants will define the look of a log depending on the property axis . A variant should be defined for every property that invokes a change in the model displayed. Any property not specified in the JSON will not have any bearing to determine the current model (e.g. waterlogged has no effect on how a model might look). Each blockstate can be specified using one of two methods: variants and multiparts. A variant defines an associated array of states which point to the associated model to render. Note that every single property that changes the model must be defined (e.g. If 4 properties defines how the model looks, then 2 ^ 4 = 16 variants must be defined). Multiparts, on the other hand, use conditions to display a certain model when true (e.g. If a model is only shown when north was true, then when that case occurs, the model will display along with any other models whose conditions are met). For a better understanding of multiparts, let\u2019s look at a variant built fence connection: \"east=true,north=false,south=false,west=false\": { \"model\": \"oak_fence_n\", \"y\": 90, \"uvlock\": true } This represents one variant out of 16 possible states. Even worse, there must be models that can uniquely define unique states (a state that can be rotated to become another state is not unique for this purpose). For fences, there are 6 models: one for no connections, one connection, two connections in a straight line, two perpendicular connections, three connections, and one for all four connections. Now let\u2019s view a modern day multipart built fence connection: { \"when\": { \"east\": \"true\" }, \"apply\": { \"model\": \"oak_fence_side\", \"y\": 90, \"uvlock\": true } } In this case, the JSON defines that if the east connector is true, then show the model oak_fence_side rotated 90 degrees. This allows the model to be broken up in only two files: the base post and the connection. It can also be represented as 5 statements, one that checks for each of the states is true and one that applies the base post unconditionally. You can find more explanations and examples of these formats on the wiki .","title":"Introduction to Blockstate JSONs"},{"location":"networking/","text":"Networking Communication between servers and clients is the backbone of a successful mod implementation. Read an overview of why networking matters and the basic strategies in thinking about networking. There are a variety of techniques provided by Forge to facilitate communication mostly built on top of netty . The simplest, for a new mod, would be SimpleImpl , where most of the complexity of the netty system is abstracted away. It uses a message and handler style system.","title":"Home"},{"location":"networking/#networking","text":"Communication between servers and clients is the backbone of a successful mod implementation. Read an overview of why networking matters and the basic strategies in thinking about networking. There are a variety of techniques provided by Forge to facilitate communication mostly built on top of netty . The simplest, for a new mod, would be SimpleImpl , where most of the complexity of the netty system is abstracted away. It uses a message and handler style system.","title":"Networking"},{"location":"networking/entities/","text":"Entities In addition to regular network messages, there are various other systems provided to handle synchronizing entity data. Spawn Data In general, the spawning of modded entities is handled separately, by Forge. Note This means that simply extending a vanilla entity class may not inherit all its behavior. You may need to implement certain vanilla behaviors yourself. You can add extra data to the spawn packet Forge sends by implementing the following interface. IEntityAdditionalSpawnData If your entity has data that is needed on the client, but does not change over time, then it can be added to the entity spawn packet using this interface. #writeSpawnData and #readSpawnData control how the data should be encoded to/decoded from the network buffer. Dynamic Data Data Parameters This is the main vanilla system for synchronizing entity data from the server to the client. As such, a number of vanilla examples are available to refer to. Firstly, you need a EntityDataAccessor<T> for the data you wish to keep synchronized. This should be stored as a static final field in your entity class, obtained by calling SynchedEntityData#defineId and passing the entity class and a serializer for that type of data. The available serializer implementations can be found as static constants within the EntityDataSerializers class. Warning You should only create data parameters for your own entities, within that entity\u2019s class . Adding parameters to entities you do not control can cause the IDs used to send that data over the network to become desynchronized, causing difficult to debug crashes. Then, override Entity#defineSynchedData and call this.entityData.define(...) for each of your data parameters, passing the parameter and an initial value to use. Remember to always call the super method first! You can then get and set these values via your entity\u2019s entityData instance. Changes made will be synchronized to the client automatically.","title":"Entities"},{"location":"networking/entities/#entities","text":"In addition to regular network messages, there are various other systems provided to handle synchronizing entity data.","title":"Entities"},{"location":"networking/entities/#spawn-data","text":"In general, the spawning of modded entities is handled separately, by Forge. Note This means that simply extending a vanilla entity class may not inherit all its behavior. You may need to implement certain vanilla behaviors yourself. You can add extra data to the spawn packet Forge sends by implementing the following interface.","title":"Spawn Data"},{"location":"networking/entities/#ientityadditionalspawndata","text":"If your entity has data that is needed on the client, but does not change over time, then it can be added to the entity spawn packet using this interface. #writeSpawnData and #readSpawnData control how the data should be encoded to/decoded from the network buffer.","title":"IEntityAdditionalSpawnData"},{"location":"networking/entities/#dynamic-data","text":"","title":"Dynamic Data"},{"location":"networking/entities/#data-parameters","text":"This is the main vanilla system for synchronizing entity data from the server to the client. As such, a number of vanilla examples are available to refer to. Firstly, you need a EntityDataAccessor<T> for the data you wish to keep synchronized. This should be stored as a static final field in your entity class, obtained by calling SynchedEntityData#defineId and passing the entity class and a serializer for that type of data. The available serializer implementations can be found as static constants within the EntityDataSerializers class. Warning You should only create data parameters for your own entities, within that entity\u2019s class . Adding parameters to entities you do not control can cause the IDs used to send that data over the network to become desynchronized, causing difficult to debug crashes. Then, override Entity#defineSynchedData and call this.entityData.define(...) for each of your data parameters, passing the parameter and an initial value to use. Remember to always call the super method first! You can then get and set these values via your entity\u2019s entityData instance. Changes made will be synchronized to the client automatically.","title":"Data Parameters"},{"location":"networking/overview/","text":"Overview There are two primary goals in network communication: Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates (X, Y, Z) just grew Giving the client a way to tell the server that something has changed about the player the player pressed a key The most common way to accomplish these goals is to pass messages between the client and the server. These messages will usually be structured, containing data in a particular arrangement, for easy sending and receiving.","title":"Overview"},{"location":"networking/overview/#overview","text":"There are two primary goals in network communication: Making sure the client view is \u201cin sync\u201d with the server view The flower at coordinates (X, Y, Z) just grew Giving the client a way to tell the server that something has changed about the player the player pressed a key The most common way to accomplish these goals is to pass messages between the client and the server. These messages will usually be structured, containing data in a particular arrangement, for easy sending and receiving.","title":"Overview"},{"location":"networking/simpleimpl/","text":"SimpleImpl SimpleImpl is the name given to the packet system that revolves around the SimpleChannel class. Using this system is by far the easiest way to send custom data between clients and the server. Getting Started First you need to create your SimpleChannel object. We recommend that you do this in a separate class, possibly something like ModidPacketHandler . Create your SimpleChannel as a static field in this class, like so: private static final String PROTOCOL_VERSION = \"1\"; public static final SimpleChannel INSTANCE = NetworkRegistry.newSimpleChannel( new ResourceLocation(\"mymodid\", \"main\"), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals ); The first argument is a name for the channel. The second argument is a Supplier<String> returning the current network protocol version. The third and fourth arguments respectively are Predicate<String> checking whether an incoming connection protocol version is network-compatible with the client or server, respectively. Here, we simply compare with the PROTOCOL_VERSION field directly, meaning that the client and server PROTOCOL_VERSION s must always match or FML will deny login. The Version Checker If your mod does not require the other side to have a specific network channel, or to be a Forge instance at all, you should take care that you properly define your version compatibility checkers (the Predicate<String> parameters) to handle additional \u201cmeta-versions\u201d (defined in NetworkRegistry ) that can be received by the version checker. These are: ABSENT - if this channel is missing on the other endpoint. Note that in this case, the endpoint is still a Forge endpoint, and may have other mods. ACCEPTVANILLA - if the endpoint is a vanilla (or non-Forge) endpoint. Returning false for both means that this channel must be present on the other endpoint. If you just copy the code above, this is what it does. Note that these values are also used during the list ping compatibility check, which is responsible for showing the green check / red cross in the multiplayer server select screen. Registering Packets Next, we must declare the types of messages that we would like to send and receive. This is done using INSTANCE#registerMessage , which takes 5 parameters: The first parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a local variable to hold the ID, and then call registerMessage using id++ . This will guarantee 100% unique IDs. The second parameter is the actual packet class MSG . The third parameter is a BiConsumer<MSG, FriendlyByteBuf> responsible for encoding the message into the provided FriendlyByteBuf . The fourth parameter is a Function<FriendlyByteBuf, MSG> responsible for decoding the message from the provided FriendlyByteBuf . The final parameter is a BiConsumer<MSG, Supplier<NetworkEvent.Context>> responsible for handling the message itself. The last three parameters can be method references to either static or instance methods in Java. Remember that an instance method MSG#encode(FriendlyByteBuf) still satisfies BiConsumer<MSG, FriendlyByteBuf> ; the MSG simply becomes the implicit first argument. Handling Packets There are a couple things to highlight in a packet handler. A packet handler has both the message object and the network context available to it. The context allows access to the player that sent the packet (if on the server), and a way to enqueue thread-safe work. public static void handle(MyMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> { // Work that needs to be thread-safe (most work) ServerPlayer sender = ctx.get().getSender(); // the client that sent this packet // Do stuff }); ctx.get().setPacketHandled(true); } Packets sent from the server to the client should be handled in another class and wrapped via DistExecutor#unsafeRunWhenOn . // In Packet class public static void handle(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> // Make sure it's only executed on the physical client DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> () -> ClientPacketHandlerClass.handlePacket(msg, ctx)) ); ctx.get().setPacketHandled(true); } // In ClientPacketHandlerClass public static void handlePacket(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) { // Do stuff } Note the presence of #setPacketHandled , which is used to tell the network system that the packet has successfully completed handling. Warning As of Minecraft 1.8 packets are by default handled on the network thread. That means that your handler can not interact with most game objects directly. Forge provides a convenient way to make your code execute on the main thread instead through the supplied NetworkEvent$Context . Simply call NetworkEvent$Context#enqueueWork(Runnable) , which will call the given Runnable on the main thread at the next opportunity. Warning Be defensive when handling packets on the server. A client could attempt to exploit the packet handling by sending unexpected data. A common problem is vulnerability to arbitrary chunk generation . This typically happens when the server is trusting a block position sent by a client to access blocks and block entities. When accessing blocks and block entities in unloaded areas of the level, the server will either generate or load this area from disk, then promptly write it to disk. This can be exploited to cause catastrophic damage to a server\u2019s performance and storage space without leaving a trace. To avoid this problem, a general rule of thumb is to only access blocks and block entities if Level#hasChunkAt is true. Sending Packets Sending to the Server There is but one way to send a packet to the server. This is because there is only ever one server the client can be connected to at once. To do so, we must again use that SimpleChannel that was defined earlier. Simply call INSTANCE.sendToServer(new MyMessage()) . The message will be sent to the handler for its type, if one exists. Sending to Clients Packets can be sent directly to a client using the SimpleChannel : HANDLER.sendTo(new MyClientMessage(), serverPlayer.connection.getConnection(), NetworkDirection.PLAY_TO_CLIENT) . However, this can be quite inconvenient. Forge has some convenience functions that can be used: // Send to one player INSTANCE.send(PacketDistributor.PLAYER.with(serverPlayer), new MyMessage()); // Send to all players tracking this level chunk INSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(levelChunk), new MyMessage()); // Send to all connected players INSTANCE.send(PacketDistributor.ALL.noArg(), new MyMessage()); There are additional PacketDistributor types available; check the documentation on the PacketDistributor class for more details.","title":"SimpleImpl"},{"location":"networking/simpleimpl/#simpleimpl","text":"SimpleImpl is the name given to the packet system that revolves around the SimpleChannel class. Using this system is by far the easiest way to send custom data between clients and the server.","title":"SimpleImpl"},{"location":"networking/simpleimpl/#getting-started","text":"First you need to create your SimpleChannel object. We recommend that you do this in a separate class, possibly something like ModidPacketHandler . Create your SimpleChannel as a static field in this class, like so: private static final String PROTOCOL_VERSION = \"1\"; public static final SimpleChannel INSTANCE = NetworkRegistry.newSimpleChannel( new ResourceLocation(\"mymodid\", \"main\"), () -> PROTOCOL_VERSION, PROTOCOL_VERSION::equals, PROTOCOL_VERSION::equals ); The first argument is a name for the channel. The second argument is a Supplier<String> returning the current network protocol version. The third and fourth arguments respectively are Predicate<String> checking whether an incoming connection protocol version is network-compatible with the client or server, respectively. Here, we simply compare with the PROTOCOL_VERSION field directly, meaning that the client and server PROTOCOL_VERSION s must always match or FML will deny login.","title":"Getting Started"},{"location":"networking/simpleimpl/#the-version-checker","text":"If your mod does not require the other side to have a specific network channel, or to be a Forge instance at all, you should take care that you properly define your version compatibility checkers (the Predicate<String> parameters) to handle additional \u201cmeta-versions\u201d (defined in NetworkRegistry ) that can be received by the version checker. These are: ABSENT - if this channel is missing on the other endpoint. Note that in this case, the endpoint is still a Forge endpoint, and may have other mods. ACCEPTVANILLA - if the endpoint is a vanilla (or non-Forge) endpoint. Returning false for both means that this channel must be present on the other endpoint. If you just copy the code above, this is what it does. Note that these values are also used during the list ping compatibility check, which is responsible for showing the green check / red cross in the multiplayer server select screen.","title":"The Version Checker"},{"location":"networking/simpleimpl/#registering-packets","text":"Next, we must declare the types of messages that we would like to send and receive. This is done using INSTANCE#registerMessage , which takes 5 parameters: The first parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a local variable to hold the ID, and then call registerMessage using id++ . This will guarantee 100% unique IDs. The second parameter is the actual packet class MSG . The third parameter is a BiConsumer<MSG, FriendlyByteBuf> responsible for encoding the message into the provided FriendlyByteBuf . The fourth parameter is a Function<FriendlyByteBuf, MSG> responsible for decoding the message from the provided FriendlyByteBuf . The final parameter is a BiConsumer<MSG, Supplier<NetworkEvent.Context>> responsible for handling the message itself. The last three parameters can be method references to either static or instance methods in Java. Remember that an instance method MSG#encode(FriendlyByteBuf) still satisfies BiConsumer<MSG, FriendlyByteBuf> ; the MSG simply becomes the implicit first argument.","title":"Registering Packets"},{"location":"networking/simpleimpl/#handling-packets","text":"There are a couple things to highlight in a packet handler. A packet handler has both the message object and the network context available to it. The context allows access to the player that sent the packet (if on the server), and a way to enqueue thread-safe work. public static void handle(MyMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> { // Work that needs to be thread-safe (most work) ServerPlayer sender = ctx.get().getSender(); // the client that sent this packet // Do stuff }); ctx.get().setPacketHandled(true); } Packets sent from the server to the client should be handled in another class and wrapped via DistExecutor#unsafeRunWhenOn . // In Packet class public static void handle(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) { ctx.get().enqueueWork(() -> // Make sure it's only executed on the physical client DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> () -> ClientPacketHandlerClass.handlePacket(msg, ctx)) ); ctx.get().setPacketHandled(true); } // In ClientPacketHandlerClass public static void handlePacket(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) { // Do stuff } Note the presence of #setPacketHandled , which is used to tell the network system that the packet has successfully completed handling. Warning As of Minecraft 1.8 packets are by default handled on the network thread. That means that your handler can not interact with most game objects directly. Forge provides a convenient way to make your code execute on the main thread instead through the supplied NetworkEvent$Context . Simply call NetworkEvent$Context#enqueueWork(Runnable) , which will call the given Runnable on the main thread at the next opportunity. Warning Be defensive when handling packets on the server. A client could attempt to exploit the packet handling by sending unexpected data. A common problem is vulnerability to arbitrary chunk generation . This typically happens when the server is trusting a block position sent by a client to access blocks and block entities. When accessing blocks and block entities in unloaded areas of the level, the server will either generate or load this area from disk, then promptly write it to disk. This can be exploited to cause catastrophic damage to a server\u2019s performance and storage space without leaving a trace. To avoid this problem, a general rule of thumb is to only access blocks and block entities if Level#hasChunkAt is true.","title":"Handling Packets"},{"location":"networking/simpleimpl/#sending-packets","text":"","title":"Sending Packets"},{"location":"networking/simpleimpl/#sending-to-the-server","text":"There is but one way to send a packet to the server. This is because there is only ever one server the client can be connected to at once. To do so, we must again use that SimpleChannel that was defined earlier. Simply call INSTANCE.sendToServer(new MyMessage()) . The message will be sent to the handler for its type, if one exists.","title":"Sending to the Server"},{"location":"networking/simpleimpl/#sending-to-clients","text":"Packets can be sent directly to a client using the SimpleChannel : HANDLER.sendTo(new MyClientMessage(), serverPlayer.connection.getConnection(), NetworkDirection.PLAY_TO_CLIENT) . However, this can be quite inconvenient. Forge has some convenience functions that can be used: // Send to one player INSTANCE.send(PacketDistributor.PLAYER.with(serverPlayer), new MyMessage()); // Send to all players tracking this level chunk INSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(levelChunk), new MyMessage()); // Send to all connected players INSTANCE.send(PacketDistributor.ALL.noArg(), new MyMessage()); There are additional PacketDistributor types available; check the documentation on the PacketDistributor class for more details.","title":"Sending to Clients"},{"location":"rendering/bewlr/","text":"BlockEntityWithoutLevelRenderer BlockEntityWithoutLevelRenderer is a method to handle dynamic rendering on items. This system is much simpler than the old ItemStack system, which required a BlockEntity , and did not allow access to the ItemStack . Using BlockEntityWithoutLevelRenderer BlockEntityWithoutLevelRenderer allows you to render your item using public void renderByItem(ItemStack itemStack, TransformType transformType, PoseStack poseStack, MultiBufferSource bufferSource, int combinedLight, int combinedOverlay) . In order to use an BEWLR, the Item must first satisfy the condition that its model returns true for BakedModel#isCustomRenderer . Once that returns true, the Item\u2019s BEWLR will be accessed for rendering. If it does not have one, it will use the default ItemRenderer#getBlockEntityRenderer . To set the BEWLR for an Item, an anonymous instance of IItemRenderProperties must be consumed within Item#initializeClient . Within the anonymous instance, IItemRenderProperties#getItemStackRenderer should be overridden to return the instance of your BEWLR: // In your item class @Override public void initializeClient(Consumer<IItemRenderProperties> consumer) { consumer.accept(new IItemRenderProperties() { @Override public BlockEntityWithoutLevelRenderer getItemStackRenderer() { return myBEWLRInstance; } }); } Important Each mod should only have one instance of a custom BEWLR. That is it, no additional setup is necessary to use a BEWLR.","title":"BlockEntityWithoutLevelRenderer"},{"location":"rendering/bewlr/#blockentitywithoutlevelrenderer","text":"BlockEntityWithoutLevelRenderer is a method to handle dynamic rendering on items. This system is much simpler than the old ItemStack system, which required a BlockEntity , and did not allow access to the ItemStack .","title":"BlockEntityWithoutLevelRenderer"},{"location":"rendering/bewlr/#using-blockentitywithoutlevelrenderer","text":"BlockEntityWithoutLevelRenderer allows you to render your item using public void renderByItem(ItemStack itemStack, TransformType transformType, PoseStack poseStack, MultiBufferSource bufferSource, int combinedLight, int combinedOverlay) . In order to use an BEWLR, the Item must first satisfy the condition that its model returns true for BakedModel#isCustomRenderer . Once that returns true, the Item\u2019s BEWLR will be accessed for rendering. If it does not have one, it will use the default ItemRenderer#getBlockEntityRenderer . To set the BEWLR for an Item, an anonymous instance of IItemRenderProperties must be consumed within Item#initializeClient . Within the anonymous instance, IItemRenderProperties#getItemStackRenderer should be overridden to return the instance of your BEWLR: // In your item class @Override public void initializeClient(Consumer<IItemRenderProperties> consumer) { consumer.accept(new IItemRenderProperties() { @Override public BlockEntityWithoutLevelRenderer getItemStackRenderer() { return myBEWLRInstance; } }); } Important Each mod should only have one instance of a custom BEWLR. That is it, no additional setup is necessary to use a BEWLR.","title":"Using BlockEntityWithoutLevelRenderer"},{"location":"utilities/recipes/","text":"Recipes With the update to Minecraft 1.12, Mojang introduced a new data-driven recipe system based on JSON files. Since then, it has been adopted by Forge and expanded in Minecraft 1.13 into datapacks . Loading Recipes Forge will load all recipes which can be found within the ./data/<modid>/recipes/ folder. You can call these files whatever you want, though the vanilla convention is to name them after the output item. For multiple recipes from different sources (Smelting, Crafting, etc), one vanilla convention is to use item_name_from_smelting.json . This name is also used as the registration key, but it does not affect the operation of the recipe. The Recipe file A basic recipe file might look like the following example: { \"type\": \"minecraft:crafting_shaped\", \"pattern\": [ \"xxa\", \"x x\", \"xxx\" ], \"key\": { \"x\": { \"tag\": \"forge:gems/diamond\" }, \"a\": { \"item\": \"mymod:myfirstitem\" } }, \"result\": { \"item\": \"mymod:myitem\", \"count\": 9 } } Note When you first obtain an ingredient to a vanilla recipe, it will automatically unlock the recipe in the recipe book. To achieve the same effect, you have to use the advancement system and create a new advancement for each of your ingredients. The advancement has to exist. This does not mean it has to be visible in the advancement tree. Type The type of a recipe is specified via the type field. You can think of this as the definition of which recipe layout to use, for example minecraft:crafting_shaped or minecraft:crafting_shapeless . Groups Optionally, you can add a group to your recipes to be displayed within the recipe helper interface. All recipes with the same group string will be shown in the same group. For example, this can be used to have all door recipes shown in the recipe helper interface as a single entry, even though there are different types of doors. Types of crafting recipes Within this section, we will take a closer look on the differences between defining a shaped and a shapeless crafting recipe. Shaped crafting Shaped recipes require the pattern and key keywords. A pattern defines the slot an item must appear in using placeholder characters. You can choose whatever character you want to be a placeholder for an item. The whitespace character is reserved for an empty slot. Keys, on the other hand, define what items to use for the placeholders. A key is defined by a placeholder character and the item. Shapeless crafting A shapeless recipe does not make use of the pattern and key keywords. To define a shapeless recipe, you have to use the ingredients list. It defines which items have to be used for the crafting process. There are many more of these types which can be used here, and you can even register your own. It is even possible to define a slot that requires more than one of an item, which means multiple of these items have to be in place. Note While there is no limit on how many ingredients your recipe requires, the vanilla crafting table only allows 9 items to be placed for each crafting recipe. The following example shows how an ingredient list looks like within JSON: \"ingredients\": [ { \"tag\": \"forge:gems/diamond\" }, { \"item\": \"minecraft:nether_star\" } ], ... Results Every vanilla recipe has to have a result tag to define the output item. When crafting something, you can get out more than one item. This is achieved by defining the count number. If this is left out, meaning it doesn\u2019t exist within the result block, it defaults to 1. Negative values are not allowed here as an ItemStack cannot be smaller than 0. There is no option to use the count number anywhere else than for the result. Forge also added support for results to include NBT data via the nbt tag.","title":"Recipes"},{"location":"utilities/recipes/#recipes","text":"With the update to Minecraft 1.12, Mojang introduced a new data-driven recipe system based on JSON files. Since then, it has been adopted by Forge and expanded in Minecraft 1.13 into datapacks .","title":"Recipes"},{"location":"utilities/recipes/#loading-recipes","text":"Forge will load all recipes which can be found within the ./data/<modid>/recipes/ folder. You can call these files whatever you want, though the vanilla convention is to name them after the output item. For multiple recipes from different sources (Smelting, Crafting, etc), one vanilla convention is to use item_name_from_smelting.json . This name is also used as the registration key, but it does not affect the operation of the recipe.","title":"Loading Recipes"},{"location":"utilities/recipes/#the-recipe-file","text":"A basic recipe file might look like the following example: { \"type\": \"minecraft:crafting_shaped\", \"pattern\": [ \"xxa\", \"x x\", \"xxx\" ], \"key\": { \"x\": { \"tag\": \"forge:gems/diamond\" }, \"a\": { \"item\": \"mymod:myfirstitem\" } }, \"result\": { \"item\": \"mymod:myitem\", \"count\": 9 } } Note When you first obtain an ingredient to a vanilla recipe, it will automatically unlock the recipe in the recipe book. To achieve the same effect, you have to use the advancement system and create a new advancement for each of your ingredients. The advancement has to exist. This does not mean it has to be visible in the advancement tree.","title":"The Recipe file"},{"location":"utilities/recipes/#type","text":"The type of a recipe is specified via the type field. You can think of this as the definition of which recipe layout to use, for example minecraft:crafting_shaped or minecraft:crafting_shapeless .","title":"Type"},{"location":"utilities/recipes/#groups","text":"Optionally, you can add a group to your recipes to be displayed within the recipe helper interface. All recipes with the same group string will be shown in the same group. For example, this can be used to have all door recipes shown in the recipe helper interface as a single entry, even though there are different types of doors.","title":"Groups"},{"location":"utilities/recipes/#types-of-crafting-recipes","text":"Within this section, we will take a closer look on the differences between defining a shaped and a shapeless crafting recipe.","title":"Types of crafting recipes"},{"location":"utilities/recipes/#shaped-crafting","text":"Shaped recipes require the pattern and key keywords. A pattern defines the slot an item must appear in using placeholder characters. You can choose whatever character you want to be a placeholder for an item. The whitespace character is reserved for an empty slot. Keys, on the other hand, define what items to use for the placeholders. A key is defined by a placeholder character and the item.","title":"Shaped crafting"},{"location":"utilities/recipes/#shapeless-crafting","text":"A shapeless recipe does not make use of the pattern and key keywords. To define a shapeless recipe, you have to use the ingredients list. It defines which items have to be used for the crafting process. There are many more of these types which can be used here, and you can even register your own. It is even possible to define a slot that requires more than one of an item, which means multiple of these items have to be in place. Note While there is no limit on how many ingredients your recipe requires, the vanilla crafting table only allows 9 items to be placed for each crafting recipe. The following example shows how an ingredient list looks like within JSON: \"ingredients\": [ { \"tag\": \"forge:gems/diamond\" }, { \"item\": \"minecraft:nether_star\" } ], ...","title":"Shapeless crafting"},{"location":"utilities/recipes/#results","text":"Every vanilla recipe has to have a result tag to define the output item. When crafting something, you can get out more than one item. This is achieved by defining the count number. If this is left out, meaning it doesn\u2019t exist within the result block, it defaults to 1. Negative values are not allowed here as an ItemStack cannot be smaller than 0. There is no option to use the count number anywhere else than for the result. Forge also added support for results to include NBT data via the nbt tag.","title":"Results"},{"location":"utilities/tags/","text":"Tags Tags are generalized sets of objects in the game used for grouping related things together and providing fast membership checks. Declaring Your Own Groupings Tags are declared in your mod\u2019s datapack . For example, /data/<modid>/tags/blocks/foo/tagname.json will declare a Tag$Named<Block> with ID modid:foo/tagname . Similarly, you may append to or override tags declared in other domains, such as Vanilla, by declaring your own JSONs. For example, to add your own mod\u2019s saplings to the Vanilla sapling tag, you would specify it in /data/minecraft/tags/blocks/saplings.json , and Vanilla will merge everything into one tag at reload, if the replace option is false. If replace is true, then all entries before the json specifying replace will be removed. See the Vanilla wiki for a description of the base syntax. Forge provides two extensions on the Vanilla syntax: You may declare an optional array of the same format as the values array, but any values listed here that are not present will not cause the tag loading to error. This has been deprecated in favor of the vanilla method of specifying optional tag values. You may declare a remove array of the same format as the values array. Any values listed here will be removed from the tag. This acts as a finer grained version of the Vanilla replace option. Using Tags In Code Block, Item, Fluid, and EntityType tags are automatically sent from the server to any remote clients on login and reload. In addition, Forge adds BlockEntityType, Potion, and Enchantment tags. Function tags are not synced. BlockTags#getAllTags and ItemTags#getAllTags will retrieve the current TagCollection , from which you can retrieve a Tag object by its ID. With a Tag object in hand, membership can be tested with tag.contains(thing) , or all the objects in the tag queried with tag.getValues() . As an example: public static final Tag.Named<Item> myTag = ItemTags.bind(\"mymod:myitemgroup\"); // In some method Item unknownItem = stack.getItem(); boolean isInGroup = unknownItem.is(myTag); !!! note: The TagCollection returned by #getAllTags (and the Tag s within it) may expire if a reload happens. The static Tag$Named fields in BlockTags and ItemTags avoid this by introducing a wrapper that handles this expiring. Conventions There are several conventions that will help facilitate compatibility in the ecosystem: If there is a Vanilla tag that fits your block or item, add it to that tag. See the list of Vanilla tags . If there is a Forge tag that fits your block or item, add it to that tag. The list of tags declared by Forge can be seen on GitHub . If there is a group of something you feel should be shared by the community, use the forge namespace instead of your mod id. Tag naming conventions should follow Vanilla conventions. In particular, item and block groupings are plural instead of singular (e.g. minecraft:logs , minecraft:saplings ). Item tags should be sorted into subdirectories according to their type (e.g. forge:ingots/iron , forge:nuggets/brass , etc.). Migration from OreDictionary For recipes, tags can be used directly in the vanilla recipe format (see below). For matching items in code, see the section above. If you are declaring a new type of item grouping, follow a couple naming conventions: Use domain:type/material . When the name is a common one that all modders should adopt, use the forge domain. For example, brass ingots should be registered under the forge:ingots/brass tag and cobalt nuggets under the forge:nuggets/cobalt tag. Using Tags in Recipes and Advancements Tags are directly supported by Vanilla. See the respective Vanilla wiki pages for recipes and advancements for usage details.","title":"Tags"},{"location":"utilities/tags/#tags","text":"Tags are generalized sets of objects in the game used for grouping related things together and providing fast membership checks.","title":"Tags"},{"location":"utilities/tags/#declaring-your-own-groupings","text":"Tags are declared in your mod\u2019s datapack . For example, /data/<modid>/tags/blocks/foo/tagname.json will declare a Tag$Named<Block> with ID modid:foo/tagname . Similarly, you may append to or override tags declared in other domains, such as Vanilla, by declaring your own JSONs. For example, to add your own mod\u2019s saplings to the Vanilla sapling tag, you would specify it in /data/minecraft/tags/blocks/saplings.json , and Vanilla will merge everything into one tag at reload, if the replace option is false. If replace is true, then all entries before the json specifying replace will be removed. See the Vanilla wiki for a description of the base syntax. Forge provides two extensions on the Vanilla syntax: You may declare an optional array of the same format as the values array, but any values listed here that are not present will not cause the tag loading to error. This has been deprecated in favor of the vanilla method of specifying optional tag values. You may declare a remove array of the same format as the values array. Any values listed here will be removed from the tag. This acts as a finer grained version of the Vanilla replace option.","title":"Declaring Your Own Groupings"},{"location":"utilities/tags/#using-tags-in-code","text":"Block, Item, Fluid, and EntityType tags are automatically sent from the server to any remote clients on login and reload. In addition, Forge adds BlockEntityType, Potion, and Enchantment tags. Function tags are not synced. BlockTags#getAllTags and ItemTags#getAllTags will retrieve the current TagCollection , from which you can retrieve a Tag object by its ID. With a Tag object in hand, membership can be tested with tag.contains(thing) , or all the objects in the tag queried with tag.getValues() . As an example: public static final Tag.Named<Item> myTag = ItemTags.bind(\"mymod:myitemgroup\"); // In some method Item unknownItem = stack.getItem(); boolean isInGroup = unknownItem.is(myTag); !!! note: The TagCollection returned by #getAllTags (and the Tag s within it) may expire if a reload happens. The static Tag$Named fields in BlockTags and ItemTags avoid this by introducing a wrapper that handles this expiring.","title":"Using Tags In Code"},{"location":"utilities/tags/#conventions","text":"There are several conventions that will help facilitate compatibility in the ecosystem: If there is a Vanilla tag that fits your block or item, add it to that tag. See the list of Vanilla tags . If there is a Forge tag that fits your block or item, add it to that tag. The list of tags declared by Forge can be seen on GitHub . If there is a group of something you feel should be shared by the community, use the forge namespace instead of your mod id. Tag naming conventions should follow Vanilla conventions. In particular, item and block groupings are plural instead of singular (e.g. minecraft:logs , minecraft:saplings ). Item tags should be sorted into subdirectories according to their type (e.g. forge:ingots/iron , forge:nuggets/brass , etc.).","title":"Conventions"},{"location":"utilities/tags/#migration-from-oredictionary","text":"For recipes, tags can be used directly in the vanilla recipe format (see below). For matching items in code, see the section above. If you are declaring a new type of item grouping, follow a couple naming conventions: Use domain:type/material . When the name is a common one that all modders should adopt, use the forge domain. For example, brass ingots should be registered under the forge:ingots/brass tag and cobalt nuggets under the forge:nuggets/cobalt tag.","title":"Migration from OreDictionary"},{"location":"utilities/tags/#using-tags-in-recipes-and-advancements","text":"Tags are directly supported by Vanilla. See the respective Vanilla wiki pages for recipes and advancements for usage details.","title":"Using Tags in Recipes and Advancements"}]}